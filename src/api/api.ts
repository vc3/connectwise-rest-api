import * as querystring from 'querystring';
import * as fetch from 'isomorphic-fetch';
import { assign } from './assign';


export interface Activity {
    "id"?: number;
    "name": string;
    "type"?: ActivityTypeReference;
    "company"?: CompanyReference;
    "contact"?: ContactReference;
    "phoneNumber"?: string;
    "email"?: string;
    "status"?: ActivityStatusReference;
    "opportunity"?: OpportunityReference;
    "ticket"?: TicketReference;
    "agreement"?: AgreementReference;
    "campaign"?: CampaignReference;
    "notes"?: string;
    "dateStart"?: Date;
    "dateEnd"?: Date;
    "assignedBy"?: MemberReference;
    "assignTo": MemberReference;
    "scheduleStatus"?: ScheduleStatusReference;
    "reminder"?: ReminderReference;
    "where"?: ServiceLocationReference;
    "notifyFlag"?: boolean;
    "mobileGuid"?: Guid;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "customFields"?: Array<CustomFieldValue>;
}

export interface ActivityReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ActivityStatus {
    "id"?: number;
    "name": string;
    "defaultFlag"?: boolean;
    "inactiveFlag"?: boolean;
    "spawnFollowupFlag"?: boolean;
    "closedFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ActivityStatusReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ActivityStopwatch {

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "activityId": number;
    "activityMobileGuid"?: Guid;
    "agreement"?: AgreementReference;
    "billableOption"?: ActivityStopwatch.BillableOptionEnum;
    "businessUnitId"?: number;
    "dateEntered"?: Date;
    "endTime"?: Date;
    "id"?: number;
    "internalNotes"?: string;
    "locationId"?: number;
    "member": MemberReference;
    "mobileGuid"?: Guid;
    "notes"?: string;
    "startTime"?: Date;
    "status": ActivityStopwatch.StatusEnum;
    "totalPauseTime"?: number;
    "workRole"?: WorkRoleReference;
    "workType"?: WorkTypeReference;
}

export namespace ActivityStopwatch {

export type BillableOptionEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type StatusEnum = 'Reset' | 'Running' | 'Paused' | 'Stopped';
}
export interface ActivityType {
    "id"?: number;
    "name": string;
    "points"?: number;
    "defaultFlag"?: boolean;
    "inactiveFlag"?: boolean;
    "emailFlag"?: boolean;
    "memoFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ActivityTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Addition {
    "id"?: number;
    "product": IvItemReference;
    "quantity"?: number;
    "lessIncluded"?: number;
    "unitPrice"?: number;
    "unitCost"?: number;
    "billCustomer": Addition.BillCustomerEnum;
    "effectiveDate"?: Date;
    "cancelledDate"?: Date;
    "taxableFlag"?: boolean;
    "serialNumber"?: string;
    "invoiceDescription"?: string;
    "purchaseItemFlag"?: boolean;
    "specialOrderFlag"?: boolean;
    "agreementId"?: number;
    "description"?: string;
    "billedQuantity"?: number;
    "uom"?: string;
    "extPrice"?: number;
    "extCost"?: number;
    "sequenceNumber"?: number;
    "margin"?: number;
    "prorateCost"?: number;
    "proratePrice"?: number;
    "extendedProrateCost"?: number;
    "extendedProratePrice"?: number;
    "prorateCurrentPeriodFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace Addition {

export type BillCustomerEnum = 'Billable' | 'DoNotBill' | 'NoCharge';
}
export interface Adjustment {
    "id"?: number;
    "amount"?: number;
    "description"?: string;
    "effectiveDate"?: Date;
    "agreementId"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "identifier": string;
    "type": AdjustmentTypeReference;
    "reason"?: string;
    "notes"?: string;
    "closedFlag"?: boolean;
    "closedBy"?: string;
    "closedDate"?: Date;
}

export interface AdjustmentDetail {
    "id"?: number;
    "catalogItem": CatalogItemReference;
    "description"?: string;
    "quantityOnHand"?: number;
    "unitCost"?: number;
    "warehouse": WarehouseReference;
    "warehouseBin": WarehouseBinReference;
    "quantityAdjusted": number;
    "serialNumber"?: string;
    "adjustment"?: AdjustmentReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface AdjustmentReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface AdjustmentType {
    "id"?: number;
    "identifier": string;
    "name"?: string;
    "auditTrailFlag"?: boolean;
    "dateCreated"?: Date;
    "createdBy"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface AdjustmentTypeReference {
    "id"?: number;
    "identifier"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Agreement {
    "id"?: number;
    "name": string;
    "type": AgreementTypeReference;
    "company": CompanyReference;
    "contact": ContactReference;
    "subContractCompany"?: CompanyReference;
    "subContractContact"?: ContactReference;
    "parentAgreementId"?: number;
    "customerPO"?: string;
    "locationId"?: number;
    "businessUnitId"?: number;
    "restrictLocationFlag"?: boolean;
    "restrictDepartmentFlag"?: boolean;
    "startDate"?: Date;
    "endDate"?: Date;
    "noEndingDateFlag"?: boolean;
    "opportunity"?: OpportunityReference;
    "cancelledFlag"?: boolean;
    "dateCancelled"?: Date;
    "reasonCancelled"?: string;
    "slaId"?: number;
    "workOrder"?: string;
    "internalNotes"?: string;
    "applicationUnits"?: Agreement.ApplicationUnitsEnum;
    "applicationLimit"?: number;
    "applicationCycle"?: Agreement.ApplicationCycleEnum;
    "applicationUnlimitedFlag"?: boolean;
    "oneTimeFlag"?: boolean;
    "coverAgreementTime"?: boolean;
    "coverAgreementProduct"?: boolean;
    "coverAgreementExpense"?: boolean;
    "coverSalesTax"?: boolean;
    "carryOverUnused"?: boolean;
    "allowOverruns"?: boolean;
    "expiredDays"?: number;
    "limit"?: number;
    "expireWhenZero"?: boolean;
    "chargeToFirm"?: boolean;
    "employeeCompRate"?: Agreement.EmployeeCompRateEnum;
    "employeeCompNotExceed"?: Agreement.EmployeeCompNotExceedEnum;
    "compHourlyRate"?: number;
    "compLimitAmount"?: number;
    "billCycleId"?: number;
    "billOneTimeFlag"?: boolean;
    "billTermsId"?: number;
    "invoicingCycle"?: Agreement.InvoicingCycleEnum;
    "billToCompany"?: CompanyReference;
    "billToSite"?: SiteReference;
    "billAmount"?: number;
    "taxable"?: boolean;
    "prorateFirstBill"?: number;
    "billStartDate"?: Date;
    "taxCodeId"?: number;
    "restrictDownPayment"?: boolean;
    "invoiceDescription"?: string;
    "topComment"?: boolean;
    "bottomComment"?: boolean;
    "workRole"?: WorkRoleReference;
    "workType"?: WorkTypeReference;
    "projectTypeId"?: number;
    "invoiceTemplateSetupId"?: number;
    "billTime"?: Agreement.BillTimeEnum;
    "billExpenses"?: Agreement.BillExpensesEnum;
    "billProducts"?: Agreement.BillProductsEnum;
    "billableTimeInvoice"?: boolean;
    "billableExpenseInvoice"?: boolean;
    "billableProductInvoice"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "periodType"?: Agreement.PeriodTypeEnum;
}

export namespace Agreement {

export type ApplicationUnitsEnum = 'Amount' | 'Hours' | 'Incidents';

export type ApplicationCycleEnum = 'Contract2Weeks' | 'Contract4Weeks' | 'ContractYear' | 'CalendarMonth' | 'CalendarQuarter' | 'CalendarWeek' | 'ContractQuarter' | 'CalendarYear';

export type EmployeeCompRateEnum = 'Actual' | 'Hourly';

export type EmployeeCompNotExceedEnum = 'Billing' | 'Percent' | 'Amount';

export type InvoicingCycleEnum = 'CalendarYear' | 'ContractYear';

export type BillTimeEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillExpensesEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillProductsEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type PeriodTypeEnum = 'Current' | 'Future' | 'Both' | 'Undefined';
}
export interface AgreementReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface AgreementSite {
    "id"?: number;
    "company": CompanyReference;
    "site"?: SiteReference;
    "agreementId"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface AgreementType {
    "id"?: number;
    "name": string;
    "prefixSuffixOption": AgreementType.PrefixSuffixOptionEnum;
    "defaultFlag"?: boolean;
    "inactiveFlag"?: boolean;
    "prePaymentFlag"?: boolean;
    "invoicePreSuffix"?: string;
    "locationId"?: number;
    "businessUnitId"?: number;
    "restrictLocationFlag"?: boolean;
    "restrictDepartmentFlag"?: boolean;
    "slaId"?: number;
    "applicationUnits"?: AgreementType.ApplicationUnitsEnum;
    "applicationLimit"?: number;
    "applicationCycle"?: AgreementType.ApplicationCycleEnum;
    "applicationUnlimitedFlag"?: boolean;
    "oneTimeFlag"?: boolean;
    "coverAgreementTimeFlag"?: boolean;
    "coverAgreementProductFlag"?: boolean;
    "coverAgreementExpenseFlag"?: boolean;
    "coverSalesTaxFlag"?: boolean;
    "carryOverUnusedFlag"?: boolean;
    "allowOverrunsFlag"?: boolean;
    "expiredDays"?: number;
    "limit"?: number;
    "expireWhenZero"?: boolean;
    "chargeToFirmFlag"?: boolean;
    "employeeCompRate": AgreementType.EmployeeCompRateEnum;
    "employeeCompNotExceed": AgreementType.EmployeeCompNotExceedEnum;
    "compHourlyRate"?: number;
    "compLimitAmount"?: number;
    "billCycleId"?: number;
    "billOneTimeFlag"?: boolean;
    "billTermsId"?: number;
    "invoicingCycle": AgreementType.InvoicingCycleEnum;
    "billAmount"?: number;
    "taxableFlag"?: boolean;
    "restrictDownPaymentFlag"?: boolean;
    "invoiceDescription"?: string;
    "topCommentFlag"?: boolean;
    "bottomCommentFlag"?: boolean;
    "workRole"?: WorkRoleReference;
    "workType"?: WorkTypeReference;
    "projectTypeId"?: number;
    "invoiceTemplateSetupId"?: number;
    "billTime": AgreementType.BillTimeEnum;
    "billExpenses": AgreementType.BillExpensesEnum;
    "billProducts": AgreementType.BillProductsEnum;
    "billableTimeInvoiceFlag"?: boolean;
    "billableExpenseInvoiceFlag"?: boolean;
    "billableProductInvoiceFlag"?: boolean;
    "copyWorkRolesFlag"?: boolean;
    "copyWorkTypesFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace AgreementType {

export type PrefixSuffixOptionEnum = 'Prefix' | 'Suffix';

export type ApplicationUnitsEnum = 'Amount' | 'Hours' | 'Incidents';

export type ApplicationCycleEnum = 'Contract2Weeks' | 'Contract4Weeks' | 'ContractYear' | 'CalendarMonth' | 'CalendarQuarter' | 'CalendarWeek' | 'ContractQuarter' | 'CalendarYear';

export type EmployeeCompRateEnum = 'Actual' | 'Hourly';

export type EmployeeCompNotExceedEnum = 'Billing' | 'Percent' | 'Amount';

export type InvoicingCycleEnum = 'CalendarYear' | 'ContractYear';

export type BillTimeEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillExpensesEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillProductsEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';
}
export interface AgreementTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface AgreementWorkRole {
    "id"?: number;
    "workRole"?: WorkRoleReference;
    "locationId"?: number;
    "rateType": AgreementWorkRole.RateTypeEnum;
    "rate"?: number;
    "limitTo"?: number;
    "effectiveDate"?: Date;
    "endingDate"?: Date;
    "agreementId"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace AgreementWorkRole {

export type RateTypeEnum = 'AdjAmount' | 'Custom' | 'Multiplier';
}
export interface AgreementWorkRoleExclusion {
    "id"?: number;
    "workRole": WorkRoleReference;
    "agreementId"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface AgreementWorkType {
    "id"?: number;
    "workType"?: WorkTypeReference;
    "locationId"?: number;
    "rateType": AgreementWorkType.RateTypeEnum;
    "billTime": AgreementWorkType.BillTimeEnum;
    "rate"?: number;
    "hoursMax"?: number;
    "hoursMin"?: number;
    "roundBillHours"?: number;
    "overageRate"?: number;
    "overageRateType"?: AgreementWorkType.OverageRateTypeEnum;
    "agreementLimit"?: number;
    "site"?: SiteReference;
    "effectiveDate"?: Date;
    "endingDate"?: Date;
    "agreementId"?: number;
    "company"?: CompanyReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace AgreementWorkType {

export type RateTypeEnum = 'AdjAmount' | 'Custom' | 'Multiplier';

export type BillTimeEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type OverageRateTypeEnum = 'AdjAmount' | 'Custom' | 'Multiplier';
}
export interface AgreementWorkTypeExclusion {
    "id"?: number;
    "workType": WorkTypeReference;
    "agreementId"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface AuditTrailEntry {
    "text"?: string;
    "enteredDate"?: string;
    "enteredBy"?: string;
    "auditType"?: string;
    "auditSubType"?: string;
    "auditSource"?: string;
}

export interface Batch {
    "thruDate"?: Date;
    "transactionsClosedDate"?: Date;
    "locationId"?: number;
    "summarizeInvoices"?: number;
    "includedInvoiceIds"?: Array<number>;
    "includedExpenseIds"?: Array<number>;
    "includedProductIds"?: Array<number>;
    "excludedInvoiceIds"?: Array<number>;
    "excludedExpenseIds"?: Array<number>;
    "excludedProductIds"?: Array<number>;
    "id"?: number;
    "batchIdentifier": string;
    "exportInvoicesFlag"?: boolean;
    "exportExpensesFlag"?: boolean;
    "exportProductsFlag"?: boolean;
    "closedFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface BatchReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface BatchRequest {
    "id"?: string;
    "requests"?: Array<EndpointRequest>;
    "headers"?: DictionarystringString;
}

export interface BatchResponse {
    "id"?: string;
    "responses"?: Array<EndpointResponse>;
}

export interface BillingDeliveryReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface BillingStatusReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface BillingTermsReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Board {
    "id"?: number;
    "name": string;
    "locationId": number;
    "businessUnitId": number;
    "inactive"?: boolean;
    "signOffTemplate"?: ServiceSignoffReference;
    "sendToContact"?: boolean;
    "contactTemplateId"?: number;
    "sendToResource"?: boolean;
    "resourceTemplateId"?: number;
    "projectFlag"?: boolean;

    /**
     * This field only shows if it is Project Board.
     */
    "showDependenciesFlag"?: boolean;

    /**
     * This field only shows if it is Project Board.
     */
    "showEstimatesFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface BoardDefault {
    "id"?: number;
    "board": BoardReference;
    "serviceType"?: ServiceTypeReference;
    "defaultFlag"?: boolean;
    "agreementId"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface BoardReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CalendarReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CallbackEntry {
    "id"?: number;
    "description"?: string;
    "url": string;
    "objectId": number;
    "type": string;
    "level": string;
    "memberId"?: number;
    "inactiveFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Campaign {
    "id"?: number;
    "name": string;
    "type": CampaignTypeReference;
    "subType": CampaignSubTypeReference;
    "status"?: CampaignStatusReference;
    "startDate": Date;
    "endDate"?: Date;
    "locationId"?: number;
    "member"?: MemberReference;
    "inactive"?: boolean;
    "inactiveDaysAfterEnd"?: number;
    "notes"?: string;
    "defaultGroup"?: GroupReference;
    "marketingManagerDefaultTrackId"?: number;
    "opportunityDefaultTrackId"?: number;
    "impressions"?: number;
    "budgetRevenue"?: number;
    "budgetCost"?: number;
    "actualCost"?: number;
    "budgetGrossMargin"?: number;
    "budgetROI"?: number;
    "actualRevenue"?: number;
    "actualGrossMargin"?: number;
    "actualROI"?: number;
    "emailsSent"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CampaignAudit {
    "id"?: number;
    "emailsSent": number;
    "emailsUnsent"?: number;
    "documentsCreated"?: number;
    "emailSubject"?: string;
    "group"?: GroupReference;
    "campaignId"?: number;
    "createdBy"?: string;
    "dateCreated"?: string;
}

export interface CampaignReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CampaignStatus {
    "id"?: number;
    "name": string;
    "defaultFlag"?: boolean;
    "inactiveFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CampaignStatusReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CampaignSubType {
    "id"?: number;
    "typeId"?: number;
    "name": string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CampaignSubTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CampaignType {
    "id"?: number;
    "name": string;
    "defaultFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CampaignTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CatalogComponent {
    "id"?: number;
    "sequenceNumber"?: number;
    "quantity": number;
    "catalogItem": CatalogItemReference;
    "hidePriceFlag"?: boolean;
    "hideItemIdentifierFlag"?: boolean;
    "hideDescriptionFlag"?: boolean;
    "hideQuantityFlag"?: boolean;
    "parentCatalogItem"?: CatalogItemReference;
    "price"?: number;
    "cost"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CatalogItem {
    "id"?: number;
    "identifier": string;
    "description": string;
    "inactiveFlag"?: boolean;
    "subcategory": ProductSubCategoryReference;
    "type": ProductTypeReference;
    "productClass": CatalogItem.ProductClassEnum;
    "serializedFlag"?: boolean;
    "serializedCostFlag"?: boolean;
    "phaseProductFlag"?: boolean;
    "unitOfMeasure"?: UnitOfMeasureReference;
    "minStockLevel"?: number;
    "price"?: number;
    "cost"?: number;
    "priceAttribute"?: CatalogItem.PriceAttributeEnum;
    "taxableFlag"?: boolean;
    "customerDescription": string;
    "manufacturer"?: ManufacturerReference;
    "manufacturerPartNumber"?: string;
    "vendor"?: CompanyReference;
    "vendorSku"?: string;
    "notes"?: string;
    "integrationXRef"?: string;
    "dateEntered"?: string;
    "category"?: ProductCategoryReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace CatalogItem {

export type ProductClassEnum = 'Agreement' | 'Bundle' | 'Inventory' | 'NonInventory' | 'Service';

export type PriceAttributeEnum = 'FixedFee' | 'NotToExceed' | 'TimeAndMaterials' | 'OverrideRate';
}
export interface CatalogItemReference {
    "id"?: number;
    "identifier"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Category {
    "id"?: number;
    "name": string;
    "inactiveFlag"?: boolean;
    "priceLevelXref"?: string;
    "integrationXref"?: string;
    "locationIds"?: Array<number>;
    "addAllLocations"?: boolean;
    "removeAllLocations"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ChargeCodeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ClassificationReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Code {
    "id"?: number;
    "name": string;
    "description": string;
    "boardId"?: number;
    "locationId"?: number;
    "businessUnitId"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CommunicationTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Company {
    "id"?: number;
    "identifier": string;
    "name": string;
    "status": CompanyStatusReference;
    "type": CompanyTypeReference;

    /**
     * At least one address field is required -- addressLine1, addressLine2, city, state, and/or zip
     */
    "addressLine1"?: string;

    /**
     * At least one address field is required -- addressLine1, addressLine2, city, state, and/or zip
     */
    "addressLine2"?: string;

    /**
     * At least one address field is required -- addressLine1, addressLine2, city, state, and/or zip
     */
    "city"?: string;

    /**
     * At least one address field is required -- addressLine1, addressLine2, city, state, and/or zip
     */
    "state"?: string;

    /**
     * At least one address field is required -- addressLine1, addressLine2, city, state, and/or zip
     */
    "zip"?: string;
    "country"?: CountryReference;
    "phoneNumber"?: string;
    "faxNumber"?: string;
    "website"?: string;
    "territoryId"?: number;
    "marketId"?: number;
    "accountNumber"?: string;
    "defaultContact"?: ContactReference;
    "dateAcquired"?: Date;
    "sicCode"?: SicCodeReference;
    "parentCompany"?: CompanyReference;
    "annualRevenue"?: number;
    "numberOfEmployees"?: number;
    "ownershipType"?: OwnershipTypeReference;
    "timeZone"?: TimeZoneReference;
    "leadSource"?: string;
    "leadFlag"?: boolean;
    "unsubscribeFlag"?: boolean;
    "calendarId"?: number;
    "userDefinedField1"?: string;
    "userDefinedField2"?: string;
    "userDefinedField3"?: string;
    "userDefinedField4"?: string;
    "userDefinedField5"?: string;
    "userDefinedField6"?: string;
    "userDefinedField7"?: string;
    "userDefinedField8"?: string;
    "userDefinedField9"?: string;
    "userDefinedField10"?: string;
    "vendorIdentifier"?: string;
    "taxIdentifier"?: string;

    /**
     * New companies will be created with the default tax code unless otherwise specified.
     */
    "taxCode"?: TaxCodeReference;
    "billingTerms"?: BillingTermsReference;
    "invoiceTemplate"?: InvoiceTemplateReference;
    "pricingSchedule"?: PricingScheduleReference;

    /**
     * Based on CompanyEntityType Report
     */
    "companyEntityType"?: EntityTypeReference;
    "billToCompany"?: CompanyReference;
    "billingSite"?: SiteReference;
    "billingContact"?: ContactReference;
    "invoiceDeliveryMethod"?: BillingDeliveryReference;
    "invoiceToEmailAddress"?: string;
    "invoiceCCEmailAddress"?: string;
    "deletedFlag"?: boolean;
    "dateDeleted"?: Date;
    "deletedBy"?: string;
    "mobileGuid"?: Guid;
    "currency"?: CurrencyReference;
    "territoryManager"?: MemberReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "customFields"?: Array<CustomFieldValue>;
}

export interface CompanyCustomNote {
    "id"?: number;
    "customNote": string;
    "status": CompanyStatusReference;
    "company"?: CompanyReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CompanyManagementSummary {
    "id"?: number;
    "managementSolution"?: ManagementSolutionReference;
    "groupIdentifier": string;

    /**
     * deviceType is required if the managementSolution is Legacy
     */
    "deviceType"?: CompanyManagementSummary.DeviceTypeEnum;
    "agreement"?: AgreementReference;
    "snmpMachines"?: number;
    "totalWorkstations"?: number;
    "totalServers"?: number;
    "totalWindowsServers"?: number;
    "totalWindowsWorkstations"?: number;
    "totalManagedMachines"?: number;
    "serversOffline"?: number;
    "serversDiskSpaceLow"?: number;
    "failedBackupJobs"?: number;
    "totalNotifications"?: number;
    "successfulBackupJobs"?: number;
    "serverAvailability"?: number;
    "virusesRemoved"?: number;
    "spywareItemsRemoved"?: number;
    "windowsPatchesInstalled"?: number;
    "diskCleanups"?: number;
    "diskDefragmentations"?: number;
    "fullyPatchedMachines"?: number;
    "missingOneTwoPatchesMachines"?: number;
    "missingThreeFivePatchesMachines"?: number;
    "missingMoreFivePatchesMachines"?: number;
    "missingUnscannedPatchesMachines"?: number;
    "alertsGenerated"?: string;
    "internetConnectivity"?: number;
    "diskSpaceCleanedMb"?: number;
    "missingSecurityPatches"?: string;
    "cpuUtilization"?: number;
    "memoryUtilization"?: number;
    "company"?: CompanyReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace CompanyManagementSummary {

export type DeviceTypeEnum = 'WorkstationsAndServers' | 'BackupStats' | 'Servers' | 'Workstations';
}
export interface CompanyMerge {
    "toCompanyId": number;
    "name"?: CompanyMerge.NameEnum;
    "identifier"?: CompanyMerge.IdentifierEnum;
    "status"?: CompanyMerge.StatusEnum;
    "type"?: CompanyMerge.TypeEnum;
    "primaryAddress"?: CompanyMerge.PrimaryAddressEnum;
    "primaryContact"?: CompanyMerge.PrimaryContactEnum;
    "phone"?: CompanyMerge.PhoneEnum;
    "fax"?: CompanyMerge.FaxEnum;
    "website"?: CompanyMerge.WebsiteEnum;
    "market"?: CompanyMerge.MarketEnum;
    "territory"?: CompanyMerge.TerritoryEnum;
    "revenue"?: CompanyMerge.RevenueEnum;
    "revenueYear"?: CompanyMerge.RevenueYearEnum;
    "numberOfEmployees"?: CompanyMerge.NumberOfEmployeesEnum;
    "sicCode"?: CompanyMerge.SicCodeEnum;
    "dateAcquired"?: CompanyMerge.DateAcquiredEnum;
    "timeZone"?: CompanyMerge.TimeZoneEnum;
    "sourceList"?: CompanyMerge.SourceListEnum;
    "userDefinedField1"?: CompanyMerge.UserDefinedField1Enum;
    "userDefinedField2"?: CompanyMerge.UserDefinedField2Enum;
    "userDefinedField3"?: CompanyMerge.UserDefinedField3Enum;
    "userDefinedField4"?: CompanyMerge.UserDefinedField4Enum;
    "userDefinedField5"?: CompanyMerge.UserDefinedField5Enum;
    "userDefinedField6"?: CompanyMerge.UserDefinedField6Enum;
    "userDefinedField7"?: CompanyMerge.UserDefinedField7Enum;
    "userDefinedField8"?: CompanyMerge.UserDefinedField8Enum;
    "userDefinedField9"?: CompanyMerge.UserDefinedField9Enum;
    "userDefinedField10"?: CompanyMerge.UserDefinedField10Enum;
    "billingAddress"?: CompanyMerge.BillingAddressEnum;
    "billingContact"?: CompanyMerge.BillingContactEnum;
    "taxCode"?: CompanyMerge.TaxCodeEnum;
    "accountNumber"?: CompanyMerge.AccountNumberEnum;
    "billingTerms"?: CompanyMerge.BillingTermsEnum;
    "notes"?: CompanyMerge.NotesEnum;
    "sites"?: CompanyMerge.SitesEnum;
    "activities"?: CompanyMerge.ActivitiesEnum;
    "opportunities"?: CompanyMerge.OpportunitiesEnum;
    "services"?: CompanyMerge.ServicesEnum;
    "projects"?: CompanyMerge.ProjectsEnum;
    "contacts"?: CompanyMerge.ContactsEnum;
    "documents"?: CompanyMerge.DocumentsEnum;
}

export namespace CompanyMerge {

export type NameEnum = 'From' | 'To';

export type IdentifierEnum = 'From' | 'To';

export type StatusEnum = 'From' | 'To';

export type TypeEnum = 'From' | 'To';

export type PrimaryAddressEnum = 'From' | 'To';

export type PrimaryContactEnum = 'From' | 'To';

export type PhoneEnum = 'From' | 'To';

export type FaxEnum = 'From' | 'To';

export type WebsiteEnum = 'From' | 'To';

export type MarketEnum = 'From' | 'To';

export type TerritoryEnum = 'From' | 'To';

export type RevenueEnum = 'From' | 'To';

export type RevenueYearEnum = 'From' | 'To';

export type NumberOfEmployeesEnum = 'From' | 'To';

export type SicCodeEnum = 'From' | 'To';

export type DateAcquiredEnum = 'From' | 'To';

export type TimeZoneEnum = 'From' | 'To';

export type SourceListEnum = 'From' | 'To';

export type UserDefinedField1Enum = 'From' | 'To';

export type UserDefinedField2Enum = 'From' | 'To';

export type UserDefinedField3Enum = 'From' | 'To';

export type UserDefinedField4Enum = 'From' | 'To';

export type UserDefinedField5Enum = 'From' | 'To';

export type UserDefinedField6Enum = 'From' | 'To';

export type UserDefinedField7Enum = 'From' | 'To';

export type UserDefinedField8Enum = 'From' | 'To';

export type UserDefinedField9Enum = 'From' | 'To';

export type UserDefinedField10Enum = 'From' | 'To';

export type BillingAddressEnum = 'From' | 'To';

export type BillingContactEnum = 'From' | 'To';

export type TaxCodeEnum = 'From' | 'To';

export type AccountNumberEnum = 'From' | 'To';

export type BillingTermsEnum = 'From' | 'To';

export type NotesEnum = 'Discard' | 'Merge';

export type SitesEnum = 'Discard' | 'Merge';

export type ActivitiesEnum = 'Discard' | 'Merge';

export type OpportunitiesEnum = 'Discard' | 'Merge';

export type ServicesEnum = 'Discard' | 'Merge';

export type ProjectsEnum = 'Discard' | 'Merge';

export type ContactsEnum = 'Discard' | 'Merge';

export type DocumentsEnum = 'Discard' | 'Merge';
}
export interface CompanyNote {
    "id"?: number;
    "text": string;
    "type"?: NoteTypeReference;
    "flagged"?: boolean;
    "enteredBy"?: string;
    "company"?: CompanyReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

/**
 * If chargeToId is not specified, we asume you enter time against the company specified
 */
export interface CompanyReference {
    "id"?: number;
    "identifier"?: string;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CompanySite {
    "id"?: number;
    "name": string;
    "addressLine1"?: string;
    "addressLine2"?: string;
    "city"?: string;
    "state"?: string;
    "zip"?: string;
    "country"?: CountryReference;
    "phoneNumber"?: string;
    "faxNumber"?: string;
    "taxCodeId"?: number;
    "expenseReimbursement"?: number;
    "primaryAddressFlag"?: boolean;
    "defaultShippingFlag"?: boolean;
    "defaultBillingFlag"?: boolean;
    "defaultMailingFlag"?: boolean;
    "calendar"?: CalendarReference;
    "timeZone"?: TimeZoneReference;
    "company"?: CompanyReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CompanyStatus {
    "id"?: number;
    "name": string;
    "defaultFlag"?: boolean;
    "inactiveFlag"?: boolean;
    "notifyFlag"?: boolean;
    "disallowSavingFlag"?: boolean;
    "notificationMessage"?: string;
    "customNoteFlag"?: boolean;
    "cancelOpenTracksFlag"?: boolean;
    "track"?: TrackReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CompanyStatusReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CompanyTeam {
    "id"?: number;
    "company"?: CompanyReference;
    "teamRole": TeamRoleReference;
    "locationId"?: number;
    "businessUnitId"?: number;
    "contact"?: ContactReference;
    "member"?: MemberReference;
    "accountManagerFlag"?: boolean;
    "techFlag"?: boolean;
    "salesFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CompanyType {
    "id"?: number;
    "name": string;
    "defaultFlag"?: boolean;
    "vendorFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CompanyTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Configuration {
    "id"?: number;
    "name": string;
    "type": ConfigurationTypeReference;
    "status"?: ConfigurationStatusReference;
    "company": CompanyReference;
    "contact"?: ContactReference;
    "site"?: SiteReference;
    "locationId"?: number;
    "businessUnitId"?: number;
    "deviceIdentifier"?: string;
    "serialNumber"?: string;
    "modelNumber"?: string;
    "tagNumber"?: string;
    "purchaseDate"?: Date;
    "installationDate"?: Date;
    "installedBy"?: MemberReference;
    "warrantyExpirationDate"?: Date;
    "vendorNotes"?: string;
    "notes"?: string;
    "macAddress"?: string;
    "lastLoginName"?: string;
    "billFlag"?: boolean;
    "backupSuccesses"?: number;
    "backupIncomplete"?: number;
    "backupFailed"?: number;
    "backupRestores"?: number;
    "lastBackupDate"?: Date;
    "backupServerName"?: string;
    "backupBillableSpaceGb"?: number;
    "backupProtectedDeviceList"?: string;
    "backupYear"?: number;
    "backupMonth"?: number;
    "ipAddress"?: string;
    "defaultGateway"?: string;
    "osType"?: string;
    "osInfo"?: string;
    "cpuSpeed"?: string;
    "ram"?: string;
    "localHardDrives"?: string;
    "parentConfigurationId"?: number;
    "vendor"?: CompanyReference;
    "manufacturer"?: ManufacturerReference;
    "questions"?: Array<ConfigurationQuestion>;
    "activeFlag"?: boolean;
    "managementLink"?: string;
    "remoteLink"?: string;
    "sla"?: SLAReference;
    "mobileGuid"?: Guid;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "displayVendorFlag"?: boolean;
    "customFields"?: Array<CustomFieldValue>;
}

export interface ConfigurationQuestion {
    "answerId"?: number;
    "questionId"?: number;
    "question"?: string;
    "answer"?: string;
    "sequenceNumber"?: number;
    "numberOfDecimals"?: number;
    "fieldType"?: ConfigurationQuestion.FieldTypeEnum;
    "requiredFlag"?: boolean;
}

export namespace ConfigurationQuestion {

export type FieldTypeEnum = 'Text' | 'Button' | 'Currency' | 'Date' | 'Hyperlink' | 'IPAddress' | 'Checkbox' | 'Number' | 'Percent' | 'TextArea' | 'Password';
}
export interface ConfigurationReference {
    "id"?: number;
    "deviceIdentifier"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ConfigurationStatus {
    "id"?: number;
    "description": string;
    "closedFlag"?: boolean;
    "defaultFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ConfigurationStatusReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ConfigurationType {
    "id"?: number;
    "name": string;
    "inactiveFlag"?: boolean;
    "systemFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ConfigurationTypeQuestion {
    "id"?: number;
    "configurationTypeId"?: number;
    "fieldType": ConfigurationTypeQuestion.FieldTypeEnum;
    "entryType": ConfigurationTypeQuestion.EntryTypeEnum;
    "sequenceNumber"?: number;
    "question": string;
    "numberOfDecimals"?: number;
    "requiredFlag"?: boolean;
    "inactiveFlag"?: boolean;
    "possibleAnswers"?: Array<string>;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace ConfigurationTypeQuestion {

export type FieldTypeEnum = 'Text' | 'Button' | 'Currency' | 'Date' | 'Hyperlink' | 'IPAddress' | 'Checkbox' | 'Number' | 'Percent' | 'TextArea' | 'Password';

export type EntryTypeEnum = 'EntryField' | 'List' | 'Option';
}
export interface ConfigurationTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ConnectWiseHostedSetup {
    "id"?: number;

    /**
     * Can be obtained via ConnectWiseHostedApiScreen report
     */
    "screenId": number;
    "description": string;
    "url": string;
    "type": ConnectWiseHostedSetup.TypeEnum;
    "origin"?: string;
    "podHeight"?: number;
    "toolbarButtonDialogHeight"?: number;
    "toolbarButtonDialogWidth"?: number;

    /**
     * Only required for ToolbarButtons
     */
    "toolbarButtonText"?: string;
    "toolbarButtonToolTip"?: string;
    "toolbarButtonIconDocumentId"?: number;
    "disabledFlag"?: boolean;
    "createdBy"?: string;
    "dateCreated"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace ConnectWiseHostedSetup {

export type TypeEnum = 'Tab' | 'Pod' | 'ToolbarButton';
}
export interface Contact {
    "id"?: number;
    "firstName": string;
    "lastName"?: string;
    "type"?: ContactTypeReference;
    "company"?: CompanyReference;
    "site"?: SiteReference;
    "addressLine1"?: string;
    "addressLine2"?: string;
    "city"?: string;
    "state"?: string;
    "zip"?: string;
    "country"?: string;
    "relationship"?: RelationshipReference;
    "department"?: ContactDepartmentReference;
    "inactiveFlag"?: boolean;
    "defaultMergeContactId"?: number;
    "securityIdentifier"?: string;
    "managerContactId"?: number;
    "assistantContactId"?: number;
    "title"?: string;
    "school"?: string;
    "nickName"?: string;
    "marriedFlag"?: boolean;
    "childrenFlag"?: boolean;
    "significantOther"?: string;
    "portalPassword"?: string;
    "portalSecurityLevel"?: number;
    "disablePortalLoginFlag"?: boolean;
    "unsubscribeFlag"?: boolean;
    "gender"?: Contact.GenderEnum;
    "birthDay"?: Date;
    "anniversary"?: Date;
    "presence"?: Contact.PresenceEnum;
    "mobileGuid"?: Guid;
    "facebookUrl"?: string;
    "twitterUrl"?: string;
    "linkedInUrl"?: string;
    "defaultBillingFlag"?: boolean;
    "communicationItems"?: Array<ContactCommunicationItem>;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "customFields"?: Array<CustomFieldValue>;
}

export namespace Contact {

export type GenderEnum = 'Male' | 'Female';

export type PresenceEnum = 'Online' | 'DoNotDisturb' | 'Away' | 'Offline' | 'NoAgent';
}
export interface ContactCommunication {
    "id"?: number;
    "contactId"?: number;
    "type": CommunicationTypeReference;
    "value": string;
    "extension"?: string;
    "defaultFlag"?: boolean;
    "mobileGuid"?: Guid;
    "communicationType"?: ContactCommunication.CommunicationTypeEnum;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace ContactCommunication {

export type CommunicationTypeEnum = 'Phone' | 'Fax' | 'Email';
}
export interface ContactCommunicationItem {
    "id"?: number;
    "type": CommunicationTypeReference;
    "value": string;
    "extension"?: string;
    "defaultFlag"?: boolean;
    "communicationType"?: ContactCommunicationItem.CommunicationTypeEnum;
}

export namespace ContactCommunicationItem {

export type CommunicationTypeEnum = 'Phone' | 'Fax' | 'Email';
}
export interface ContactDepartment {
    "id"?: number;
    "name": string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ContactDepartmentReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ContactNote {
    "id"?: number;
    "contactId"?: number;
    "text": string;
    "type"?: NoteTypeReference;
    "flagged"?: boolean;
    "enteredBy"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ContactReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ContactRelationship {
    "id"?: number;
    "name": string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ContactType {
    "id"?: number;
    "description": string;
    "defaultFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ContactTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Conversion {
    "id"?: number;
    "quantity": number;
    "uomType": UnitOfMeasureReference;
    "parentUOM"?: UnitOfMeasureReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Count {
    "count"?: number;
}

export interface CountryReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Currency {
    "id"?: number;
    "currencyIdentifier": string;
    "name"?: string;
    "symbol"?: string;
    "displayIdFlag"?: boolean;
    "displaySymbolFlag"?: boolean;
    "isoCode"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CurrencyReference {
    "id"?: number;
    "identifier"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CustomFieldValue {
    "id"?: number;
    "caption"?: string;
    "type"?: CustomFieldValue.TypeEnum;
    "entryMethod"?: CustomFieldValue.EntryMethodEnum;
    "numberOfDecimals"?: number;
    "value"?: string;
}

export namespace CustomFieldValue {

export type TypeEnum = 'Text' | 'Button' | 'Currency' | 'Date' | 'Hyperlink' | 'IPAddress' | 'Checkbox' | 'Number' | 'Percent' | 'TextArea' | 'Password';

export type EntryMethodEnum = 'EntryField' | 'List' | 'Option';
}
export interface DictionarystringString {
    "comparer"?: IEqualityComparerstring;
    "count"?: number;
    "keys"?: KeyCollection;
    "systemCollectionsGenericIDictionary&lt;TKey,TValue&gt;Keys"?: ICollectionstring;
    "systemCollectionsGenericIReadOnlyDictionary&lt;TKey,TValue&gt;Keys"?: Array<string>;
    "values"?: ValueCollection;
    "systemCollectionsGenericIDictionary&lt;TKey,TValue&gt;Values"?: ICollectionstring;
    "systemCollectionsGenericIReadOnlyDictionary&lt;TKey,TValue&gt;Values"?: Array<string>;
    "this[]"?: string;
    "systemCollectionsGenericICollection&lt;SystemCollectionsGenericKeyValuePair&lt;TKey,TValue&gt;&gt;IsReadOnly"?: boolean;
    "systemCollectionsICollectionIsSynchronized"?: boolean;
    "systemCollectionsICollectionSyncRoot"?: string;
    "systemCollectionsIDictionaryIsFixedSize"?: boolean;
    "systemCollectionsIDictionaryIsReadOnly"?: boolean;
    "systemCollectionsIDictionaryKeys"?: ICollection;
    "systemCollectionsIDictionaryValues"?: ICollection;
    "systemCollectionsIDictionaryItem"?: string;
}

export interface DocumentInfo {
    "id"?: number;
    "title"?: string;
    "fileName"?: string;
    "serverFileName"?: string;
    "owner"?: string;
    "linkFlag"?: boolean;
    "imageFlag"?: boolean;
    "publicFlag"?: boolean;
    "readOnlyFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface DocumentReference {
    "id"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface EmailOpened {
    "id"?: number;
    "campaignId"?: number;
    "contactId": number;
    "dateOpened"?: Date;
}

export interface EndpointRequest {
    "id"?: string;
    "contentType"?: string;
    "method"?: string;
    "relativeUrl"?: string;
    "body"?: string;
}

export interface EndpointResponse {
    "id"?: string;
    "code"?: number;
    "message"?: string;
    "sort"?: number;
}

/**
 * Based on CompanyEntityType Report
 */
export interface EntityTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Error {
    "code"?: string;
    "message"?: string;
    "errors"?: Array<ValidationError>;
}

export interface ExcludedMember {
    "id"?: number;
    "memberId": number;
    "boardId"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ExpenseEntry {
    "id"?: number;

    /**
     * Company or chargeToType is required
     */
    "company"?: CompanyReference;
    "chargeToId"?: number;

    /**
     * Company or chargeToType is required
     */
    "chargeToType"?: ExpenseEntry.ChargeToTypeEnum;
    "type": ExpenseTypeReference;
    "member"?: MemberReference;
    "paymentMethod"?: PaymentMethodReference;
    "classification"?: ClassificationReference;
    "amount": number;
    "billableOption": ExpenseEntry.BillableOptionEnum;
    "date": Date;
    "locationId"?: number;
    "businessUnitId"?: number;
    "notes"?: string;
    "agreement"?: AgreementReference;
    "invoiceAmount"?: number;
    "taxes"?: Array<ExpenseTax>;
    "invoice"?: InvoiceReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace ExpenseEntry {

export type ChargeToTypeEnum = 'ServiceTicket' | 'ProjectTicket' | 'ChargeCode' | 'Activity';

export type BillableOptionEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';
}
export interface ExpenseTax {
    "id"?: number;
    "amount"?: number;
    "type"?: ExpenseTaxTypeReference;
}

export interface ExpenseTaxTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ExpenseType {
    "id"?: number;
    "name": string;
    "amountCaption": string;
    "reimbursementRate"?: number;
    "billExpenses": ExpenseType.BillExpensesEnum;
    "invoiceMarkupOption": ExpenseType.InvoiceMarkupOptionEnum;
    "invoiceMarkupAmount"?: number;
    "advancedAmountFlag"?: boolean;
    "mileageFlag"?: boolean;
    "quantityFlag"?: boolean;
    "inactiveFlag"?: boolean;
    "maxAmount"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace ExpenseType {

export type BillExpensesEnum = 'Billable' | 'DoNotBill' | 'NoCharge';

export type InvoiceMarkupOptionEnum = 'Percent' | 'Amount' | 'Mile';
}
export interface ExpenseTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface FilterValues {
    "conditions"?: string;
    "orderBy"?: string;
    "childconditions"?: string;
    "customfieldconditions"?: string;
}

export interface Forecast {
    "id"?: number;
    "name"?: string;
    "revenue"?: number;
    "cost"?: number;
    "type": Forecast.TypeEnum;
    "status"?: OpportunityStatusReference;
    "includedFlag"?: boolean;
    "recurring"?: ProductRecurring;
    "percent"?: number;
    "margin"?: number;
    "opportunityId"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace Forecast {

export type TypeEnum = 'Product' | 'Service' | 'Agreement' | 'Other1' | 'Other2';
}
export interface FormSubmitted {
    "id"?: number;
    "campaignId"?: number;
    "contactId": number;
    "dateSubmitted"?: Date;
    "url": string;
    "queryString"?: string;
    "pageType"?: string;
    "pageSubType"?: string;
    "topic"?: string;
    "version"?: string;
    "status"?: string;
}

export interface GenericIdIdentifierReference {
    "id"?: number;
    "identifier"?: string;
}

export interface Group {
    "id"?: number;
    "name": string;
    "publicDescription"?: string;
    "publicFlag"?: boolean;
    "inactiveFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface GroupReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Guid {
}

export interface ICollection {
}

export interface ICollectionstring {
}

export interface IEqualityComparerstring {
}

export interface Info {
    "version"?: string;
    "isCloud"?: boolean;
    "serverTimeZone"?: string;
}

export interface Invoice {
    "id"?: number;
    "invoiceNumber"?: string;
    "type": Invoice.TypeEnum;
    "status"?: BillingStatusReference;
    "company": CompanyReference;
    "billToCompany"?: CompanyReference;
    "shipToCompany"?: CompanyReference;
    "applyToType"?: Invoice.ApplyToTypeEnum;
    "applyToId"?: number;
    "attention"?: string;
    "billingSite"?: SiteReference;
    "shippingSite"?: SiteReference;
    "billingTerms"?: BillingTermsReference;
    "reference"?: string;
    "customerPO"?: string;

    /**
     * Can be obtained via InvoiceTemplate report
     */
    "templateSetupId"?: number;

    /**
     * Can be obtained via InvoiceEmailTemplate report
     */
    "emailTemplateId"?: number;
    "addToBatchEmailList"?: boolean;
    "date"?: Date;
    "restrictDownpaymentFlag"?: boolean;
    "locationId"?: number;
    "departmentId"?: number;
    "territoryId"?: number;
    "topComment"?: string;
    "bottomComment"?: string;
    "taxableFlag"?: boolean;
    "taxCode"?: TaxCodeReference;
    "internalNotes"?: string;
    "downpaymentPreviouslyTaxedFlag"?: boolean;
    "serviceTotal"?: number;
    "dueDate"?: Date;
    "expenseTotal"?: number;
    "productTotal"?: number;
    "previousProgressApplied"?: number;
    "serviceAdjustmentAmount"?: number;
    "agreementAmount"?: number;
    "downpaymentApplied"?: number;
    "subtotal"?: number;
    "total"?: number;
    "remainingDownpayment"?: number;
    "salesTax"?: number;
    "adjustmentReason"?: string;
    "adjustedBy"?: string;
    "payments"?: number;
    "credits"?: number;
    "balance"?: number;
    "specialInvoiceFlag"?: boolean;
}

export namespace Invoice {

export type TypeEnum = 'Agreement' | 'CreditMemo' | 'DownPayment' | 'Miscellaneous' | 'Progress' | 'Standard';

export type ApplyToTypeEnum = 'All' | 'Agreement' | 'Project' | 'ProjectPhase' | 'SalesOrder' | 'Ticket';
}
export interface InvoiceReference {
    "id"?: number;
    "identifier"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface InvoiceTemplateReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Item {
    "id"?: number;
    "name": string;
    "inactive"?: boolean;
    "typeAssociations"?: Array<TypeAssociations>;
    "addAllSubTypes"?: boolean;
    "removeAllSubTypes"?: boolean;
    "typeId"?: number;
    "boardId"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface IvItemReference {
    "id"?: number;
    "identifier"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface JObject {
}

export interface KeyCollection {
    "count"?: number;
    "systemCollectionsGenericICollection&lt;TKey&gt;IsReadOnly"?: boolean;
    "systemCollectionsICollectionIsSynchronized"?: boolean;
    "systemCollectionsICollectionSyncRoot"?: string;
}

export interface KnowledgeBaseArticle {
    "id"?: number;
    "title": string;
    "issue": string;
    "resolution": string;
    "locationId"?: number;
    "businessUnitId"?: number;
    "boardId"?: number;
    "categoryId"?: number;
    "subCategoryId"?: number;
    "dateCreated"?: string;
    "createdBy"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Link {
    "id"?: number;
    "name": string;
    "tableReferenceId": number;
    "url"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface LinkClicked {
    "id"?: number;
    "campaignId"?: number;
    "contactId": number;
    "dateClicked"?: Date;
    "url": string;
    "queryString"?: string;
}

export interface Location {
    "id"?: number;
    "name": string;
    "where": Location.WhereEnum;
    "defaultFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace Location {

export type WhereEnum = 'OnSite' | 'Remote' | 'InHouse';
}
export interface ManagementSolutionReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Manufacturer {
    "id"?: number;
    "name": string;
    "inactiveFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ManufacturerReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface MarketingCompany {
    "id": number;
    "groupId"?: number;
    "defaultContactFlag"?: boolean;
    "allContactsFlag"?: boolean;
    "unsubscribeFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface MarketingContact {
    "id": number;
    "groupId"?: number;
    "note"?: string;
    "unsubscribeFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Member {
    "adminFlag"?: boolean;
    "allowExpensesEnteredAgainstCompaniesFlag"?: boolean;
    "allowInCellEntryOnTimeSheet"?: boolean;
    "billableForecast"?: number;
    "calendar"?: CalendarReference;
    "calendarSyncIntegrationFlag"?: boolean;
    "country"?: CountryReference;
    "dailyCapacity"?: number;
    "daysTolerance"?: number;
    "defaultDepartmentId": number;
    "defaultEmail": Member.DefaultEmailEnum;
    "defaultLocationId": number;
    "defaultPhone": Member.DefaultPhoneEnum;
    "disableOnlineFlag"?: boolean;
    "enableLdapAuthenticationFlag"?: boolean;
    "enableMobileFlag"?: boolean;
    "enableMobileGpsFlag"?: boolean;
    "enterTimeAgainstCompanyFlag"?: boolean;
    "expenseApprover": MemberReference;
    "firstName": string;
    "hideMemberInDispatchPortalFlag"?: boolean;
    "hireDate": Date;
    "homeEmail"?: string;
    "homeExtension"?: string;
    "homePhone"?: string;
    "hourlyCost"?: number;
    "hourlyRate"?: number;
    "id"?: number;
    "identifier": string;
    "inactiveDate"?: Date;
    "inactiveFlag"?: boolean;
    "includeInUtilizationReportingFlag"?: boolean;
    "lastLogin"?: string;
    "lastName": string;

    /**
     * F = Regular Member, A = API Member, C = StreamlineIT Member, X = Subcontractor Member
     */
    "licenseClass": Member.LicenseClassEnum;
    "mapiName"?: string;
    "middleInitial"?: string;
    "minimumHours"?: number;
    "mobileEmail"?: string;
    "mobileExtension"?: string;
    "mobilePhone"?: string;
    "notes"?: string;
    "officeEmail"?: string;
    "officeExtension"?: string;
    "officePhone"?: string;
    "projectDefaultBoard"?: ProjectBoardReference;
    "projectDefaultDepartmentId"?: number;
    "projectDefaultLocationId"?: number;
    "reportsTo"?: MemberReference;
    "requireExpenseEntryFlag"?: boolean;
    "requireStartAndEndTimeOnTimeEntryFlag"?: boolean;
    "requireTimeSheetEntryFlag"?: boolean;
    "restrictDefaultSalesTerritoryFlag"?: boolean;
    "restrictDefaultWarehouseBinFlag"?: boolean;
    "restrictDefaultWarehouseFlag"?: boolean;
    "restrictDepartmentFlag"?: boolean;
    "restrictLocationFlag"?: boolean;
    "restrictProjectDefaultDepartmentFlag"?: boolean;
    "restrictProjectDefaultLocationFlag"?: boolean;
    "restrictScheduleFlag"?: boolean;
    "restrictServiceDefaultDepartmentFlag"?: boolean;
    "restrictServiceDefaultLocationFlag"?: boolean;
    "salesDefaultLocationId": number;
    "scheduleCapacity"?: number;
    "scheduleDefaultDepartmentId"?: number;
    "scheduleDefaultLocationId"?: number;
    "securityLevel"?: string;
    "securityLocationId"?: number;
    "securityRole"?: SecurityRoleReference;
    "serviceDefaultBoard"?: BoardReference;
    "serviceDefaultDepartmentId"?: number;
    "serviceDefaultLocationId"?: number;
    "serviceLocation"?: ServiceLocationReference;
    "serviceTeams"?: Array<number>;
    "timeApprover": MemberReference;
    "timeReminderEmailFlag"?: boolean;
    "timeSheetStartDate"?: Date;
    "timeZone": TimeZoneReference;
    "title"?: string;
    "type"?: MemberTypeReference;
    "vendorNumber"?: string;
    "warehouse"?: WarehouseReference;
    "warehouseBin"?: WarehouseBinReference;
    "workRole": WorkRoleReference;
    "workType"?: WorkTypeReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "systemFlag"?: boolean;
}

export namespace Member {

export type DefaultEmailEnum = 'Office' | 'Mobile' | 'Home';

export type DefaultPhoneEnum = 'Office' | 'Mobile' | 'Home';

export type LicenseClassEnum = 'F' | 'A' | 'C' | 'X';
}
/**
 * Activity schedule requires a member
 */
export interface MemberReference {
    "id"?: number;
    "identifier"?: string;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface MemberTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface MenuEntry {
    "id"?: number;
    "menuLocation": MenuLocationReference;
    "caption": string;
    "link": string;
    "newWindowFlag": boolean;
    "locationIds"?: Array<number>;
    "origin"?: string;
    "addAllLocations"?: boolean;
    "removeAllLocations"?: boolean;
    "smallMenuIconId"?: number;
    "largeMenuIconId"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface MenuLocationReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

/**
 * Metadata of the entity
 */
export interface Metadata {
}

export interface NoteTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Opportunity {
    "id"?: number;
    "name": string;
    "expectedCloseDate"?: Date;
    "type"?: OpportunityTypeReference;
    "stage"?: OpportunityStageReference;
    "status"?: OpportunityStatusReference;
    "priority"?: OpportunityPriorityReference;
    "notes"?: string;
    "probability"?: OpportunityProbabilityReference;
    "source"?: string;
    "rating"?: OpportunityRatingReference;
    "campaign"?: CampaignReference;
    "primarySalesRep": MemberReference;
    "secondarySalesRep"?: MemberReference;
    "locationId"?: number;
    "businessUnitId"?: number;
    "company": CompanyReference;
    "contact": ContactReference;
    "site": SiteReference;
    "customerPO"?: string;
    "pipelineChangeDate"?: Date;
    "dateBecameLead"?: Date;
    "closedDate"?: Date;
    "closedBy"?: MemberReference;
    "totalSalesTax"?: number;
    "shipToCompany"?: CompanyReference;
    "shipToContact"?: ContactReference;
    "shipToSite"?: SiteReference;
    "billToCompany"?: CompanyReference;
    "billToContact"?: ContactReference;
    "billToSite"?: SiteReference;
    "billingTerms"?: BillingTermsReference;
    "taxCode"?: TaxCodeReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "customFields"?: Array<CustomFieldValue>;
}

export interface OpportunityContact {
    "id"?: number;
    "contact": ContactReference;
    "company"?: CompanyReference;
    "role"?: OpportunitySalesRoleReference;
    "notes"?: string;
    "referralFlag"?: boolean;
    "opportunityId"?: number;
    "phoneNumber"?: string;
    "emailAddress"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface OpportunityNote {
    "id"?: number;
    "opportunityId"?: number;
    "type"?: NoteTypeReference;
    "text": string;
    "flagged"?: boolean;
    "enteredBy"?: string;
    "mobileGuid"?: Guid;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface OpportunityPriorityReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface OpportunityProbabilityReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface OpportunityRating {
    "id"?: number;
    "name": string;
    "sortOrder"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface OpportunityRatingReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface OpportunityReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface OpportunitySalesRoleReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface OpportunityStageReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface OpportunityStatus {
    "id"?: number;
    "name": string;
    "wonFlag"?: boolean;
    "lostFlag"?: boolean;
    "closedFlag"?: boolean;
    "inactiveFlag"?: boolean;
    "defaultFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "enteredBy"?: string;
    "dateEntered"?: Date;
}

export interface OpportunityStatusReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface OpportunityToAgreementConversion {
    "agreementId"?: number;
    "name"?: string;
    "type"?: AgreementTypeReference;
    "startDate"?: string;
    "endDate"?: string;
    "noEndingDateFlag"?: boolean;
    "billCycleId"?: number;
    "billOneTimeFlag"?: boolean;
    "locationId"?: number;
    "businessUnitId"?: number;
    "includeAllNotesFlag"?: boolean;
    "includeAllDocumentsFlag"?: boolean;
    "includeAllProductsFlag"?: boolean;
    "includeNoteIds"?: Array<number>;
    "includeDocumentIds"?: Array<number>;
    "includeProductIds"?: Array<number>;
}

export interface OpportunityToProjectConversion {
    "projectId"?: number;
    "name"?: string;
    "status"?: ProjectStatusReference;
    "locationId"?: number;
    "businessUnitId"?: number;
    "board"?: ProjectBoardReference;
    "manager"?: MemberReference;
    "estimatedStart"?: string;
    "estimatedEnd"?: string;
    "includeAllNotesFlag"?: boolean;
    "includeAllDocumentsFlag"?: boolean;
    "includeAllProductsFlag"?: boolean;
    "includeNoteIds"?: Array<number>;
    "includeDocumentIds"?: Array<number>;
    "includeProductIds"?: Array<number>;
}

export interface OpportunityToSalesOrderConversion {
    "salesOrderId"?: number;
    "name"?: string;
    "includeAllNotesFlag"?: boolean;
    "includeAllDocumentsFlag"?: boolean;
    "includeAllProductsFlag"?: boolean;
    "includeNoteIds"?: Array<number>;
    "includeDocumentIds"?: Array<number>;
    "includeProductIds"?: Array<number>;
}

export interface OpportunityToServiceTicketConversion {
    "ticketId"?: number;
    "summary"?: string;
    "includeAllNotesFlag"?: boolean;
    "includeAllDocumentsFlag"?: boolean;
    "includeAllProductsFlag"?: boolean;
    "includeNoteIds"?: Array<number>;
    "includeDocumentIds"?: Array<number>;
    "includeProductIds"?: Array<number>;
}

export interface OpportunityType {
    "id"?: number;
    "description": string;
    "inactiveFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface OpportunityTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Order {
    "id"?: number;
    "company": CompanyReference;
    "contact"?: ContactReference;
    "phone"?: string;
    "phoneExt"?: string;
    "email"?: string;
    "site"?: SiteReference;
    "status": OrderStatusReference;
    "opportunity"?: OpportunityReference;
    "orderDate"?: Date;
    "dueDate"?: Date;
    "billingTerms"?: BillingTermsReference;
    "taxCode"?: TaxCodeReference;
    "poNumber"?: string;
    "locationId"?: number;
    "businessUnitId"?: number;
    "salesRep": MemberReference;
    "notes"?: string;
    "billClosedFlag"?: boolean;
    "billShippedFlag"?: boolean;
    "restrictDownpaymentFlag"?: boolean;
    "description"?: string;
    "topCommentFlag"?: boolean;
    "bottomCommentFlag"?: boolean;
    "shipToCompany"?: CompanyReference;
    "shipToContact"?: ContactReference;
    "shipToSite"?: SiteReference;
    "billToCompany"?: CompanyReference;
    "billToContact"?: ContactReference;
    "billToSite"?: SiteReference;
    "productIds"?: Array<number>;
    "documentIds"?: Array<number>;
    "invoiceIds"?: Array<number>;
    "configIds"?: Array<number>;
    "total"?: number;
    "taxTotal"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface OrderStatus {
    "id"?: number;
    "name": string;
    "defaultFlag"?: boolean;
    "inactiveFlag"?: boolean;
    "sortOrder"?: number;
    "closedFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface OrderStatusReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface OwnershipTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface PatchOperation {
    "op"?: string;
    "path"?: string;
    "value"?: string;
}

export interface Payment {
    "id"?: number;
    "type"?: string;
    "invoice"?: InvoiceReference;
    "amount": number;
    "paymentDate"?: Date;
    "appliedBy"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface PaymentMethodReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface PhaseStatusReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface PortalSecurity {
    "identifier"?: string;
    "enabled"?: boolean;
}

export interface PricingBreak {
    "id"?: number;
    "detailId"?: number;
    "amount"?: number;
    "quantityStart"?: number;
    "quantityEnd"?: number;
    "priceMethod": PricingBreak.PriceMethodEnum;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace PricingBreak {

export type PriceMethodEnum = 'FlatRateForRange' | 'PercentMarkupFromCost' | 'PercentMarkdownFromPrice' | 'PricePerUnit';
}
export interface PricingDetail {
    "id"?: number;
    "product"?: CatalogItemReference;
    "category"?: ProductCategoryReference;
    "subCategory"?: ProductSubCategoryReference;
    "startDate": Date;
    "endDate"?: Date;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface PricingSchedule {
    "id"?: number;
    "name": string;
    "inactiveFlag"?: boolean;
    "defaultFlag"?: boolean;
    "companies"?: Array<number>;
    "setAllCompaniesFlag"?: boolean;
    "removeAllCompaniesFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface PricingScheduleReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Priority {
    "id"?: number;
    "name": string;
    "color": string;
    "sortOrder"?: number;
    "defaultFlag"?: boolean;
    "imageLink"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface PriorityReference {
    "id"?: number;
    "name"?: string;
    "sort"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Product {
    "identifier"?: Product.IdentifierEnum;

    /**
     * Password is only available on response of install request
     */
    "password"?: string;
    "installedFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace Product {

export type IdentifierEnum = 'CloudConsole' | 'CampaignDirector' | 'UserCentric' | 'ChatAssist';
}
export interface ProductCategoryReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ProductComponent {
    "id"?: number;
    "sequenceNumber"?: number;
    "quantity": number;
    "catalogItem": CatalogItemReference;
    "hidePriceFlag"?: boolean;
    "hideItemIdentifierFlag"?: boolean;
    "hideDescriptionFlag"?: boolean;
    "hideQuantityFlag"?: boolean;
    "vendor"?: CompanyReference;
    "parentProductItem"?: ProductItemReference;
    "productItem"?: ProductItemReference;
    "price"?: number;
    "cost"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ProductItem {
    "id"?: number;
    "catalogItem": CatalogItemReference;
    "chargeToId": number;
    "chargeToType": ProductItem.ChargeToTypeEnum;
    "description"?: string;
    "sequenceNumber"?: number;
    "quantity"?: number;
    "price"?: number;
    "cost"?: number;
    "discount"?: number;
    "priceMethod"?: ProductItem.PriceMethodEnum;
    "billableOption": ProductItem.BillableOptionEnum;
    "agreement"?: AgreementReference;
    "locationId"?: number;
    "businessUnitId"?: number;
    "vendor"?: CompanyReference;
    "vendorSku"?: string;
    "taxableFlag"?: boolean;
    "dropshipFlag"?: boolean;
    "specialOrderFlag"?: boolean;
    "phaseProductFlag"?: boolean;
    "cancelledFlag"?: boolean;
    "quantityCancelled"?: number;
    "cancelledReason"?: string;
    "customerDescription"?: string;
    "internalNotes"?: string;
    "productSuppliedFlag"?: boolean;
    "subContractorShipToId"?: number;
    "subContractorAmountLimit"?: number;
    "recurring"?: ProductRecurring;
    "sla"?: SLAReference;
    "entityType"?: EntityTypeReference;
    "forecastDetailId"?: number;
    "cancelledBy"?: number;
    "cancelledDate"?: Date;
    "warehouse"?: string;
    "warehouseBin"?: string;
    "purchaseDate"?: Date;
    "integrationXRef"?: string;
    "listPrice"?: number;
    "serialNumberIds"?: Array<number>;
    "company"?: CompanyReference;
    "forecastStatus"?: OpportunityStatusReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "bypassForecastUpdate"?: boolean;
}

export namespace ProductItem {

export type ChargeToTypeEnum = 'Ticket' | 'Project' | 'Invoice' | 'Opportunity' | 'SalesOrder';

export type PriceMethodEnum = 'FlatRateForRange' | 'PercentMarkupFromCost' | 'PercentMarkdownFromPrice' | 'PricePerUnit';

export type BillableOptionEnum = 'Billable' | 'DoNotBill' | 'NoCharge';
}
export interface ProductItemReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ProductPickingShippingDetail {
    "id"?: number;
    "pickedQuantity": number;
    "shippedQuantity": number;
    "warehouse": WarehouseReference;
    "warehouseBin": WarehouseBinReference;
    "shipmentMethod"?: ShipmentMethodReference;
    "serialNumber"?: string;
    "serialNumberIds"?: Array<number>;
    "trackingNumber"?: string;
    "productItem"?: ProductItemReference;
    "lineNumber"?: number;
    "quantity"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ProductRecurring {
    "recurringRevenue": number;
    "recurringCost": number;
    "startDate": Date;
    "endDate": Date;
    "billCycleId": number;
    "cycles": number;
    "cycleType": ProductRecurring.CycleTypeEnum;
}

export namespace ProductRecurring {

export type CycleTypeEnum = 'CalendarYear' | 'ContractYear';
}
export interface ProductReference {
    "id"?: number;
    "description"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ProductSubCategoryReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ProductType {
    "id"?: number;
    "name": string;
    "inactiveFlag"?: boolean;
    "typeXref"?: ProductType.TypeXrefEnum;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace ProductType {

export type TypeXrefEnum = 'InventoryPart' | 'NonInventoryPart' | 'OtherCharge' | 'Service';
}
export interface ProductTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Project {
    "id"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "actualEnd"?: string;
    "actualHours"?: number;
    "actualStart"?: string;
    "agreement"?: AgreementReference;
    "billExpenses"?: Project.BillExpensesEnum;
    "billingAmount"?: number;
    "billingAttention"?: string;
    "billingMethod": Project.BillingMethodEnum;
    "billingRateType"?: Project.BillingRateTypeEnum;
    "billingTerms"?: BillingTermsReference;
    "billProducts"?: Project.BillProductsEnum;
    "billProjectAfterClosedFlag"?: boolean;
    "billTime"?: Project.BillTimeEnum;
    "billToCompany"?: CompanyReference;
    "billToContact"?: ContactReference;
    "billToSite"?: SiteReference;
    "billUnapprovedTimeAndExpense"?: boolean;
    "board": ProjectBoardReference;
    "budgetAnalysis"?: Project.BudgetAnalysisEnum;
    "budgetFlag"?: boolean;
    "budgetHours"?: number;
    "businessUnitId"?: number;
    "company": CompanyReference;
    "contact"?: ContactReference;
    "customerPO"?: string;
    "description"?: string;
    "downpayment"?: number;
    "estimatedEnd": Date;
    "estimatedExpenseRevenue"?: number;
    "estimatedHours"?: number;
    "estimatedProductRevenue"?: number;
    "estimatedStart": Date;
    "estimatedTimeRevenue"?: number;
    "expenseApprover"?: MemberReference;
    "includeDependenciesFlag"?: boolean;
    "includeEstimatesFlag"?: boolean;
    "locationId"?: number;
    "manager"?: MemberReference;
    "name": string;
    "opportunity"?: OpportunityReference;
    "projectTemplateId"?: number;
    "restrictDownPaymentFlag"?: boolean;
    "scheduledEnd"?: string;
    "scheduledHours"?: number;
    "scheduledStart"?: string;
    "shipToCompany"?: CompanyReference;
    "shipToContact"?: ContactReference;
    "shipToSite"?: SiteReference;
    "site"?: SiteReference;
    "status"?: ProjectStatusReference;
    "timeApprover"?: MemberReference;
    "type"?: ProjectTypeReference;
}

export namespace Project {

export type BillExpensesEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillingMethodEnum = 'ActualRates' | 'FixedFee' | 'NotToExceed' | 'OverrideRate';

export type BillingRateTypeEnum = 'WorkRole' | 'StaffMember';

export type BillProductsEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillTimeEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BudgetAnalysisEnum = 'ActualHours' | 'BillableHours';
}
export interface ProjectBoardReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ProjectContact {
    "id"?: number;
    "projectId"?: number;
    "contact": ContactReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ProjectNote {
    "id"?: number;
    "projectId"?: number;
    "text": string;
    "type"?: NoteTypeReference;
    "flagged"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ProjectPhase {
    "id"?: number;
    "projectId"?: number;
    "description": string;
    "board"?: ProjectBoardReference;
    "status"?: PhaseStatusReference;
    "agreement"?: AgreementReference;
    "opportunity"?: OpportunityReference;
    "parentPhase"?: ProjectPhaseReference;
    "wbsCode"?: string;
    "billTime"?: ProjectPhase.BillTimeEnum;
    "billExpenses"?: ProjectPhase.BillExpensesEnum;
    "billProducts"?: ProjectPhase.BillProductsEnum;
    "markAsMilestoneFlag"?: boolean;
    "notes"?: string;
    "deadlineDate"?: Date;
    "billSeparatelyFlag"?: boolean;

    /**
     * billingMethod is required if the phase billSeparatelyFlag is true
     */
    "billingMethod"?: ProjectPhase.BillingMethodEnum;
    "scheduledHours"?: number;
    "scheduledStart"?: string;
    "scheduledEnd"?: string;
    "actualHours"?: number;
    "actualStart"?: string;
    "actualEnd"?: string;
    "budgetHours"?: number;
    "locationId"?: number;
    "businessUnitId"?: number;
    "hourlyRate"?: number;
    "billingStartDate"?: Date;

    /**
     * This phase can only be billed after it has been closed
     */
    "billPhaseClosedFlag"?: boolean;

    /**
     * This phase can only be billed after the project has been closed
     */
    "billProjectClosedFlag"?: boolean;
    "downpayment"?: number;
    "poNumber"?: string;
    "poAmount"?: number;
    "estimatedTimeCost"?: number;
    "estimatedExpenseCost"?: number;
    "estimatedProductCost"?: number;
    "estimatedTimeRevenue"?: number;
    "estimatedExpenseRevenue"?: number;
    "estimatedProductRevenue"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace ProjectPhase {

export type BillTimeEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillExpensesEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillProductsEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillingMethodEnum = 'ActualRates' | 'FixedFee' | 'NotToExceed' | 'OverrideRate';
}
export interface ProjectPhaseReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ProjectReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ProjectRoleReference {
    "id"?: number;
    "identifier"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ProjectStatusReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ProjectTeammember {
    "id"?: number;
    "projectId"?: number;
    "hours"?: number;
    "member": MemberReference;
    "projectRole": ProjectRoleReference;
    "workRole"?: WorkRoleReference;
    "startDate"?: Date;
    "endDate"?: Date;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ProjectTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface PurchaseOrder {
    "id"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "businessUnitId"?: number;
    "cancelReason"?: string;
    "closedFlag"?: boolean;
    "customerCity"?: string;
    "customerCompany"?: CompanyReference;
    "customerContact"?: ContactReference;
    "customerCountry"?: CountryReference;
    "customerExtension"?: string;
    "customerName"?: string;
    "customerPhone"?: string;
    "customerSite"?: SiteReference;
    "customerSiteName"?: string;
    "customerState"?: string;
    "customerStreetLine1"?: string;
    "customerStreetLine2"?: string;
    "customerZip"?: string;
    "dateClosed"?: Date;
    "dropShipCustomerFlag"?: boolean;
    "enteredBy"?: string;
    "freightCost"?: number;
    "freightPackingSlip"?: string;
    "freightTaxTotal"?: number;
    "internalNotes"?: string;
    "locationId": number;
    "poDate"?: Date;
    "poNumber"?: string;
    "salesTax"?: number;
    "shipmentDate"?: Date;
    "shipmentMethod"?: ShipmentMethodReference;
    "shippingInstructions"?: string;
    "status": PurchaseOrderStatusReference;
    "subTotal"?: number;
    "taxCode"?: TaxCodeReference;
    "taxFreightFlag"?: boolean;
    "taxPoFlag"?: boolean;
    "terms": BillingTermsReference;
    "total"?: number;
    "trackingNumber"?: string;

    /**
     * Determines whether or not to update all of the shipment info for each associated line item when new shipment info is passed in
     */
    "updateShipmentInfo"?: boolean;

    /**
     * Determines whether or not to update vendor order number for each associated line item when new vendor order number is passed in
     */
    "updateVendorOrderNumber"?: boolean;
    "vendorCompany": CompanyReference;
    "vendorContact"?: ContactReference;
    "vendorInvoiceDate"?: Date;
    "vendorInvoiceNumber"?: string;
    "vendorOrderNumber"?: string;
    "vendorSite"?: SiteReference;
    "warehouse"?: WarehouseReference;
}

export interface PurchaseOrderLineItem {
    "id"?: number;
    "backorderedFlag"?: boolean;
    "canceledBy"?: string;
    "canceledFlag"?: boolean;
    "canceledReason"?: string;
    "closedFlag"?: boolean;
    "dateCanceled"?: Date;
    "dateCanceledUtc"?: Date;
    "description": string;
    "displayInternalNotesFlag"?: boolean;
    "expectedShipDate"?: Date;
    "internalNotes"?: string;
    "lineNumber": number;
    "packingSlip"?: string;
    "product": IvItemReference;
    "purchaseOrderId"?: number;
    "quantity": number;
    "receivedQuantity"?: number;
    "serialNumbers"?: string;
    "shipDate"?: Date;
    "shipmentMethod"?: ShipmentMethodReference;
    "tax"?: number;
    "trackingNumber"?: string;
    "unitCost"?: number;
    "unitOfMeasure": UnitOfMeasureReference;
    "vendorOrderNumber"?: string;
    "warehouse"?: WarehouseReference;
    "warehouseBin"?: WarehouseBinReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface PurchaseOrderReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface PurchaseOrderStatusReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface RelationshipReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ReminderReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Report {
    "name"?: string;
}

export interface ReportDataResponse {
    "columnDefinitions"?: Array<JObject>;
    "rowValues"?: Array<JObject>;
}

export interface RequestPasswordRequest {
    "email": string;
}

export interface SLAReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface SalesTeamReference {
    "id"?: number;
    "identifier"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ScheduleEntry {
    "id"?: number;
    "objectId"?: number;
    "name"?: string;

    /**
     * Activity schedule requires a member
     */
    "member"?: MemberReference;
    "where"?: ServiceLocationReference;
    "dateStart"?: Date;
    "dateEnd"?: Date;
    "reminder"?: ReminderReference;
    "status"?: ScheduleStatusReference;
    "type": ScheduleTypeReference;
    "span"?: ScheduleSpanReference;
    "doneFlag"?: boolean;
    "acknowledgedFlag"?: boolean;
    "ownerFlag"?: boolean;
    "allowScheduleConflictsFlag"?: boolean;
    "addMemberToProjectFlag"?: boolean;
    "projectRoleId"?: number;
    "mobileGuid"?: Guid;
    "closeDate"?: Date;
    "hours"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ScheduleEntryReference {
    "id"?: number;
    "description"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ScheduleReminderTime {
    "id"?: number;

    /**
     * Time is calculated in minutes
     */
    "time"?: number;
    "description"?: string;
    "defaultFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ScheduleSpanReference {
    "id"?: number;
    "identifier"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ScheduleStatus {
    "id"?: number;
    "name": string;
    "defaultFlag"?: boolean;
    "showAsTentativeFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ScheduleStatusReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ScheduleStopwatch {

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "agreement"?: AgreementReference;
    "billableOption"?: ScheduleStopwatch.BillableOptionEnum;
    "businessUnitId"?: number;
    "dateEntered"?: Date;
    "endTime"?: Date;
    "id"?: number;
    "internalNotes"?: string;
    "locationId"?: number;
    "member": MemberReference;
    "mobileGuid"?: Guid;
    "notes"?: string;
    "scheduleId": number;
    "scheduleMobileGuid"?: Guid;
    "startTime"?: Date;
    "status": ScheduleStopwatch.StatusEnum;
    "totalPauseTime"?: number;
    "workRole"?: WorkRoleReference;
    "workType"?: WorkTypeReference;
}

export namespace ScheduleStopwatch {

export type BillableOptionEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type StatusEnum = 'Reset' | 'Running' | 'Paused' | 'Stopped';
}
export interface ScheduleType {
    "id"?: number;
    "name": string;
    "identifier": string;
    "chargeCode"?: ChargeCodeReference;
    "where"?: ServiceLocationReference;
    "systemFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ScheduleTypeReference {
    "id"?: number;
    "identifier"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface SecurityRoleReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ServiceCodeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ServiceItemReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ServiceLocationReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ServiceNote {
    "id"?: number;
    "ticketId"?: number;
    "text"?: string;
    "detailDescriptionFlag"?: boolean;
    "internalAnalysisFlag"?: boolean;
    "resolutionFlag"?: boolean;
    "member"?: MemberReference;
    "contact"?: ContactReference;
    "customerUpdatedFlag"?: boolean;
    "processNotifications"?: boolean;
    "dateCreated"?: string;
    "createdBy"?: string;
    "internalFlag"?: boolean;
    "externalFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ServiceSignoffReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ServiceSourceReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ServiceStatusReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ServiceSubTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ServiceTeamReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ServiceTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ShipmentMethod {
    "id"?: number;
    "name": string;
    "defaultFlag"?: boolean;
    "trackingUrl"?: string;
    "shippingType"?: ShipmentMethod.ShippingTypeEnum;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace ShipmentMethod {

export type ShippingTypeEnum = 'None' | 'FedExTwoDay' | 'FedExPriority' | 'FedExGround' | 'UpsNextDay' | 'UpsSecondDay' | 'UpsGround' | 'CourierService' | 'UspsPriority' | 'UspsExpress';
}
export interface ShipmentMethodReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface SicCodeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface SiteReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Source {
    "id"?: number;
    "name": string;
    "defaultFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "enteredBy"?: string;
    "dateEntered"?: Date;
}

export interface Status {
    "id"?: number;
    "name": string;
    "boardId"?: number;
    "sortOrder"?: number;
    "displayOnBoard"?: boolean;
    "inactive"?: boolean;
    "closedStatus"?: boolean;
    "timeEntryNotAllowed"?: boolean;
    "defaultFlag"?: boolean;
    "escalationStatus"?: Status.EscalationStatusEnum;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace Status {

export type EscalationStatusEnum = 'NotResponded' | 'Responded' | 'ResolutionPlan' | 'Resolved' | 'NoEscalation';
}
export interface SubCategory {
    "id"?: number;
    "name": string;
    "inactiveFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface SubType {
    "id"?: number;
    "name": string;
    "inactive"?: boolean;
    "typeAssociationIds"?: Array<number>;
    "addAllTypes"?: boolean;
    "removeAllTypes"?: boolean;
    "boardId"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface SuccessResponse {
    "success"?: boolean;
    "message"?: string;
}

export interface Survey {
    "id"?: number;
    "name": string;
    "inactiveFlag"?: boolean;
    "headerIncludeLogoFlag"?: boolean;
    "headerText"?: string;
    "headerTextVisibleFlag"?: boolean;
    "footerText"?: string;
    "footerTextVisibleFlag"?: boolean;
    "thankYouText"?: string;
    "notifyWho"?: GenericIdIdentifierReference;
    "notifyWhoVisibleFlag"?: boolean;
    "notifyMember"?: MemberReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface SurveyQuestion {
    "id"?: number;
    "sequenceNumber"?: number;
    "type": SurveyQuestion.TypeEnum;
    "question": string;
    "options"?: Array<SurveyQuestionOption>;
    "includeFlag"?: boolean;
    "requiredFlag"?: boolean;
    "noAnswerPoints"?: number;
    "surveyId"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace SurveyQuestion {

export type TypeEnum = 'OpenEnded' | 'Selection';
}
export interface SurveyQuestionOption {
    "includeFlag"?: boolean;
    "caption": string;
    "points"?: number;
}

export interface SurveyResult {
    "id"?: number;
    "ticketId": number;
    "emailAddress"?: string;
    "footerResponse"?: string;
    "contactMeFlag"?: boolean;
    "contact"?: ContactReference;
    "results"?: Array<SurveyResultDetail>;
    "totalPoints"?: number;
    "company"?: CompanyReference;
    "surveyId"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface SurveyResultDetail {
    "questionId": number;

    /**
     * If question type is Selection, this should be the option array index
     */
    "answer"?: string;
}

export interface Task {
    "id"?: number;
    "ticketId"?: number;
    "notes"?: string;
    "closedFlag"?: boolean;
    "priority"?: number;
    "schedule"?: ScheduleEntryReference;
    "code"?: ServiceCodeReference;
    "resolution"?: string;
    "childScheduleAction"?: Task.ChildScheduleActionEnum;
    "childTicketId"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace Task {

export type ChildScheduleActionEnum = 'Transfer' | 'Delete' | 'Done';
}
export interface TaxCode {
    "id"?: number;
    "identifier": string;
    "description": string;
    "invoiceCaption": string;
    "country"?: CountryReference;
    "effectiveDate": Date;
    "defaultFlag"?: boolean;
    "displayOnInvoiceFlag"?: boolean;
    "canadaCalculateGSTFlag"?: boolean;
    "cancelDate"?: Date;
    "levelOneRate"?: number;
    "levelOneRateType"?: TaxCode.LevelOneRateTypeEnum;
    "levelOneTaxableMax"?: number;
    "levelOneCaption"?: string;
    "levelOneTaxCodeXref"?: string;
    "levelOneAgencyXref"?: string;
    "levelOneServicesFlag"?: boolean;
    "levelOneExpensesFlag"?: boolean;
    "levelOneProductsFlag"?: boolean;
    "levelOneApplySingleUnitFlag"?: boolean;
    "levelOneApplySingleUnitMin"?: number;
    "levelOneApplySingleUnitMax"?: number;
    "levelTwoRate"?: number;
    "levelTwoRateType"?: TaxCode.LevelTwoRateTypeEnum;
    "levelTwoTaxableMax"?: number;
    "levelTwoCaption"?: string;
    "levelTwoTaxCodeXref"?: string;
    "levelTwoAgencyXref"?: string;
    "levelTwoServicesFlag"?: boolean;
    "levelTwoExpensesFlag"?: boolean;
    "levelTwoProductsFlag"?: boolean;
    "levelTwoApplySingleUnitFlag"?: boolean;
    "levelTwoApplySingleUnitMin"?: number;
    "levelTwoApplySingleUnitMax"?: number;
    "levelThreeRate"?: number;
    "levelThreeRateType"?: TaxCode.LevelThreeRateTypeEnum;
    "levelThreeTaxableMax"?: number;
    "levelThreeCaption"?: string;
    "levelThreeTaxCodeXref"?: string;
    "levelThreeAgencyXref"?: string;
    "levelThreeServicesFlag"?: boolean;
    "levelThreeExpensesFlag"?: boolean;
    "levelThreeProductsFlag"?: boolean;
    "levelThreeApplySingleUnitFlag"?: boolean;
    "levelThreeApplySingleUnitMin"?: number;
    "levelThreeApplySingleUnitMax"?: number;
    "levelFourRate"?: number;
    "levelFourRateType"?: TaxCode.LevelFourRateTypeEnum;
    "levelFourTaxableMax"?: number;
    "levelFourCaption"?: string;
    "levelFourTaxCodeXref"?: string;
    "levelFourAgencyXref"?: string;
    "levelFourServicesFlag"?: boolean;
    "levelFourExpensesFlag"?: boolean;
    "levelFourProductsFlag"?: boolean;
    "levelFourApplySingleUnitFlag"?: boolean;
    "levelFourApplySingleUnitMin"?: number;
    "levelFourApplySingleUnitMax"?: number;
    "levelFiveRate"?: number;
    "levelFiveRateType"?: TaxCode.LevelFiveRateTypeEnum;
    "levelFiveTaxableMax"?: number;
    "levelFiveCaption"?: string;
    "levelFiveTaxCodeXref"?: string;
    "levelFiveAgencyXref"?: string;
    "levelFiveServicesFlag"?: boolean;
    "levelFiveExpensesFlag"?: boolean;
    "levelFiveProductsFlag"?: boolean;
    "levelFiveApplySingleUnitFlag"?: boolean;
    "levelFiveApplySingleUnitMin"?: number;
    "levelFiveApplySingleUnitMax"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace TaxCode {

export type LevelOneRateTypeEnum = 'Amount' | 'Percent';

export type LevelTwoRateTypeEnum = 'Amount' | 'Percent';

export type LevelThreeRateTypeEnum = 'Amount' | 'Percent';

export type LevelFourRateTypeEnum = 'Amount' | 'Percent';

export type LevelFiveRateTypeEnum = 'Amount' | 'Percent';
}
/**
 * New companies will be created with the default tax code unless otherwise specified.
 */
export interface TaxCodeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface TaxCodeXRef {
    "id"?: number;
    "description": string;
    "defaultFlag"?: boolean;
    "levelOne"?: TaxCodeXRef.LevelOneEnum;
    "levelTwo"?: TaxCodeXRef.LevelTwoEnum;
    "levelThree"?: TaxCodeXRef.LevelThreeEnum;
    "levelFour"?: TaxCodeXRef.LevelFourEnum;
    "levelFive"?: TaxCodeXRef.LevelFiveEnum;
    "taxCode"?: TaxCodeReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace TaxCodeXRef {

export type LevelOneEnum = 'NonTaxable' | 'Taxable';

export type LevelTwoEnum = 'NonTaxable' | 'Taxable';

export type LevelThreeEnum = 'NonTaxable' | 'Taxable';

export type LevelFourEnum = 'NonTaxable' | 'Taxable';

export type LevelFiveEnum = 'NonTaxable' | 'Taxable';
}
export interface Team {
    "id"?: number;
    "type"?: Team.TypeEnum;
    "member"?: MemberReference;
    "salesTeam"?: SalesTeamReference;
    "commissionPercent"?: number;
    "referralFlag"?: boolean;
    "opportunityId"?: number;
    "responsibleFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "name": string;
    "teamLeader": MemberReference;
    "members"?: Array<number>;
    "defaultFlag"?: boolean;
    "notifyOnTicketDelete"?: boolean;
    "boardId"?: number;
    "locationId"?: number;
    "businessUnitId"?: number;
}

export namespace Team {

export type TypeEnum = 'Individual' | 'Team';
}
export interface TeamRoleReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Ticket {
    "id"?: number;
    "summary": string;
    "recordType"?: Ticket.RecordTypeEnum;
    "board"?: BoardReference;
    "status"?: ServiceStatusReference;
    "project"?: ProjectReference;
    "phase"?: ProjectPhaseReference;
    "wbsCode"?: string;
    "company": CompanyReference;
    "site"?: SiteReference;
    "siteName"?: string;
    "addressLine1"?: string;
    "addressLine2"?: string;
    "city"?: string;
    "stateIdentifier"?: string;
    "zip"?: string;
    "country"?: CountryReference;
    "contact"?: ContactReference;
    "contactName"?: string;
    "contactPhoneNumber"?: string;
    "contactPhoneExtension"?: string;
    "contactEmailAddress"?: string;
    "type"?: ServiceTypeReference;
    "subType"?: ServiceSubTypeReference;
    "item"?: ServiceItemReference;
    "team"?: ServiceTeamReference;
    "owner"?: MemberReference;
    "priority"?: PriorityReference;
    "serviceLocation"?: ServiceLocationReference;
    "source"?: ServiceSourceReference;
    "requiredDate"?: Date;
    "budgetHours"?: number;
    "opportunity"?: OpportunityReference;
    "agreement"?: AgreementReference;
    "severity"?: Ticket.SeverityEnum;
    "impact"?: Ticket.ImpactEnum;
    "externalXRef"?: string;
    "poNumber"?: string;
    "knowledgeBaseCategoryId"?: number;
    "knowledgeBaseSubCategoryId"?: number;
    "allowAllClientsPortalView"?: boolean;
    "customerUpdatedFlag"?: boolean;
    "automaticEmailContactFlag"?: boolean;
    "automaticEmailResourceFlag"?: boolean;
    "automaticEmailCcFlag"?: boolean;
    "automaticEmailCc"?: string;

    /**
     * Only available for POST, will not be returned in the response
     */
    "initialDescription"?: string;

    /**
     * Only available for POST, will not be returned in the response
     */
    "initialInternalAnalysis"?: string;

    /**
     * Only available for POST, will not be returned in the response
     */
    "initialResolution"?: string;
    "contactEmailLookup"?: string;

    /**
     * Can be set to false to skip notification processing when adding or updating a ticket (Defaults to True)
     */
    "processNotifications"?: boolean;
    "skipCallback"?: boolean;
    "closedDate"?: string;
    "closedBy"?: string;
    "closedFlag"?: boolean;
    "dateEntered"?: string;
    "enteredBy"?: string;
    "actualHours"?: number;
    "approved"?: boolean;
    "subBillingMethod"?: Ticket.SubBillingMethodEnum;
    "subBillingAmount"?: number;
    "subDateAccepted"?: string;
    "dateResolved"?: string;
    "dateResplan"?: string;
    "dateResponded"?: string;
    "resolveMinutes"?: number;
    "resPlanMinutes"?: number;
    "respondMinutes"?: number;
    "isInSla"?: boolean;
    "knowledgeBaseLinkId"?: number;
    "resources"?: string;
    "parentTicketId"?: number;
    "hasChildTicket"?: boolean;
    "knowledgeBaseLinkType"?: Ticket.KnowledgeBaseLinkTypeEnum;
    "billTime"?: Ticket.BillTimeEnum;
    "billExpenses"?: Ticket.BillExpensesEnum;
    "billProducts"?: Ticket.BillProductsEnum;
    "predecessorType"?: Ticket.PredecessorTypeEnum;
    "predecessorId"?: number;
    "predecessorClosedFlag"?: boolean;
    "lagDays"?: number;
    "lagNonworkingDaysFlag"?: boolean;
    "estimatedStartDate"?: Date;
    "duration"?: number;
    "locationId"?: number;
    "businessUnitId"?: number;
    "mobileGuid"?: Guid;
    "sla"?: SLAReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "customFields"?: Array<CustomFieldValue>;
}

export namespace Ticket {

export type RecordTypeEnum = 'ServiceTicket' | 'ProjectTicket' | 'ProjectIssue';

export type SeverityEnum = 'Low' | 'Medium' | 'High';

export type ImpactEnum = 'Low' | 'Medium' | 'High';

export type SubBillingMethodEnum = 'ActualRates' | 'FixedFee' | 'NotToExceed' | 'OverrideRate';

export type KnowledgeBaseLinkTypeEnum = 'ServiceTicket' | 'ProjectTicket' | 'ProjectIssue' | 'KnowledgeBaseArticle' | 'Time' | 'Activity';

export type BillTimeEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillExpensesEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillProductsEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type PredecessorTypeEnum = 'Ticket' | 'Phase';
}
export interface TicketReference {
    "id"?: number;
    "summary"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface TicketStopwatch {

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "agreement"?: AgreementReference;
    "billableOption"?: TicketStopwatch.BillableOptionEnum;
    "businessUnitId"?: number;
    "dateEntered"?: Date;
    "endTime"?: Date;
    "id"?: number;
    "internalNotes"?: string;
    "locationId"?: number;
    "member": MemberReference;
    "mobileGuid"?: Guid;
    "notes"?: string;
    "serviceStatus"?: ServiceStatusReference;
    "startTime"?: Date;
    "status": TicketStopwatch.StatusEnum;
    "ticket": TicketReference;
    "ticketMobileGuid"?: Guid;
    "totalPauseTime"?: number;
    "workRole"?: WorkRoleReference;
    "workType"?: WorkTypeReference;
    "showNotesInDiscussionFlag"?: boolean;
    "showNotesInInternalFlag"?: boolean;
    "showNotesInResolutionFlag"?: boolean;
    "emailNotesToContactFlag"?: boolean;
    "emailNotesToResourcesFlag"?: boolean;
}

export namespace TicketStopwatch {

export type BillableOptionEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type StatusEnum = 'Reset' | 'Running' | 'Paused' | 'Stopped';
}
export interface TimeEntry {
    "id"?: number;

    /**
     * If chargeToId is not specified, we asume you enter time against the company specified
     */
    "company"?: CompanyReference;

    /**
     * If chargeToId is not specified, we asume you enter time against the company specified
     */
    "chargeToId"?: number;

    /**
     * If chargeToId is not specified, we asume you enter time against the company specified
     */
    "chargeToType"?: TimeEntry.ChargeToTypeEnum;
    "member"?: MemberReference;
    "locationId"?: number;
    "businessUnitId"?: number;
    "workType"?: WorkTypeReference;
    "workRole"?: WorkRoleReference;
    "agreement"?: AgreementReference;
    "timeStart": Date;
    "timeEnd"?: Date;
    "hoursDeduct"?: number;
    "actualHours"?: number;
    "billableOption"?: TimeEntry.BillableOptionEnum;
    "notes"?: string;
    "internalNotes"?: string;
    "addToDetailDescriptionFlag"?: boolean;
    "addToInternalAnalysisFlag"?: boolean;
    "addToResolutionFlag"?: boolean;

    /**
     * This is an action flag. To update this value use the /service/tickets endpoint automaticEmailResourceFlag field
     */
    "emailResourceFlag"?: boolean;

    /**
     * This is an action flag. To update this value use the /service/tickets endpoint automaticEmailContactFlag field
     */
    "emailContactFlag"?: boolean;

    /**
     * This is an action flag. To update this value use the /service/tickets endpoint automaticEmailCcFlag field
     */
    "emailCcFlag"?: boolean;

    /**
     * To update this value use the /service/tickets endpoint automaticEmailCc field
     */
    "emailCc"?: string;
    "hoursBilled"?: number;
    "enteredBy"?: string;
    "dateEntered"?: Date;
    "invoice"?: InvoiceReference;

    /**
     * This field may only be Updated, it is defaulted on Create
     */
    "hourlyRate"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "customFields"?: Array<CustomFieldValue>;
}

export namespace TimeEntry {

export type ChargeToTypeEnum = 'ServiceTicket' | 'ProjectTicket' | 'ChargeCode' | 'Activity';

export type BillableOptionEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';
}
export interface TimeEntryReference {
    "id"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface TimeZoneReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Token {
    "publicKey"?: string;
    "privateKey"?: string;
    "expiration"?: string;
}

export interface Track {
    "id"?: number;
    "trackId": number;
    "name"?: string;
    "startDate"?: string;
    "endDate"?: string;
    "actionTaken"?: number;
    "actionRemaining"?: number;
    "startedBy"?: string;
    "company"?: CompanyReference;
    "contact"?: ContactReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface TrackReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Transaction {
    "id"?: number;
    "batch"?: BatchReference;
    "billingLogId"?: number;
    "invoiceNumber"?: string;
    "type"?: Transaction.TypeEnum;
    "description"?: string;
    "cost"?: number;
    "item"?: string;
    "inventory"?: string;
    "salesCode"?: string;
    "cogs"?: string;
    "glAccount"?: string;
    "currency"?: CurrencyReference;
    "debitAmount"?: number;
    "creditAmount"?: number;
    "balance"?: string;
    "product"?: ProductReference;
    "quantity"?: number;
    "unitOfMeasure"?: UnitOfMeasureReference;
    "serializedFlag"?: boolean;
    "serialNumber"?: string;
    "shipmentMethod"?: ShipmentMethodReference;
    "packingSlip"?: string;
    "ticket"?: TicketReference;
    "project"?: ProjectReference;
    "phase"?: ProjectPhaseReference;
    "expenseClass"?: Transaction.ExpenseClassEnum;
    "expenseType"?: ExpenseTypeReference;
    "timeEntry"?: TimeEntryReference;
    "activity"?: ActivityReference;
    "segment1"?: string;
    "segment2"?: string;
    "segment3"?: string;
    "segment4"?: string;
    "segment5"?: string;
    "segment6"?: string;
    "segment7"?: string;
    "segment8"?: string;
    "segment9"?: string;
    "segment10"?: string;

    /**
     * Used to determine if Avalara tax is enabled.
     */
    "avalaraTaxFlag"?: boolean;
    "itemTaxableFlag"?: boolean;
    "taxCode"?: TaxCodeReference;

    /**
     * Set to true if transaction is taxable at the state level.
     */
    "stateTaxFlag"?: boolean;
    "stateTaxXref"?: string;
    "stateTaxAmount"?: number;

    /**
     * Set to true if transaction is taxable at the county level.
     */
    "countyTaxFlag"?: boolean;
    "countyTaxXref"?: string;
    "countyTaxAmount"?: number;

    /**
     * Set to true if transaction is taxable at the city level.
     */
    "cityTaxFlag"?: boolean;
    "cityTaxXref"?: string;
    "cityTaxAmount"?: number;

    /**
     * Set to true if transaction is taxable at the country level.
     */
    "countryTaxFlag"?: boolean;
    "countryTaxXref"?: string;
    "countryTaxAmount"?: number;

    /**
     * Set to true if transaction is taxable at the composite level.
     */
    "compositeTaxFlag"?: boolean;
    "compositeTaxXref"?: string;
    "compositeTaxAmount"?: number;
    "taxTotal"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace Transaction {

export type TypeEnum = 'AP' | 'AR' | 'EE' | 'EI' | 'EO' | 'IA' | 'IT' | 'P' | 'PF' | 'R' | 'RA' | 'RD' | 'RE' | 'RP' | 'ST' | 'SD' | 'ET' | 'RM' | 'FT' | 'PT';

export type ExpenseClassEnum = 'NonReimbursable' | 'Reimbursable' | 'Personal';
}
export interface Type {
    "id"?: number;
    "name": string;
    "category"?: Type.CategoryEnum;
    "defaultFlag"?: boolean;
    "inactive"?: boolean;
    "requestForChange"?: boolean;
    "boardId"?: number;
    "locationId"?: number;
    "businessUnitId"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace Type {

export type CategoryEnum = 'Reactive' | 'Proactive';
}
export interface TypeAssociations {
    "typeId"?: number;
    "subTypeAssociationIds"?: Array<number>;
}

export interface UnitOfMeasure {
    "id"?: number;
    "name": string;
    "inactiveFlag"?: boolean;
    "defaultFlag"?: boolean;
    "uomScheduleXref"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface UnitOfMeasureReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface UnpostedExpense {
    "id"?: number;
    "locationId"?: number;
    "departmentId"?: number;
    "company"?: CompanyReference;
    "accountNumber"?: string;
    "creditAccount"?: string;
    "expenseDetailId"?: number;
    "expenseType"?: ExpenseTypeReference;
    "classification"?: UnpostedExpense.ClassificationEnum;
    "glType"?: UnpostedExpense.GlTypeEnum;
    "member"?: MemberReference;
    "dateExpense"?: Date;
    "chargeCode"?: ChargeCodeReference;
    "chargeDescription"?: string;
    "inPolicy"?: boolean;
    "paymentMethod"?: PaymentMethodReference;
    "currency"?: CurrencyReference;
    "total"?: number;
    "billableAmount"?: number;
    "nonBillableAmount"?: number;
    "agreement"?: AgreementReference;
    "agreementAmountCovered"?: number;
    "ticket"?: TicketReference;
    "project"?: ProjectReference;
    "projectPhase"?: ProjectPhaseReference;
    "taxCode"?: TaxCodeReference;

    /**
     * Used to determine if Avalara tax is enabled.
     */
    "avalaraTaxFlag"?: boolean;
    "itemTaxableFlag"?: boolean;
    "salesTaxAmount"?: number;

    /**
     * Set to true if transaction is taxable at the state level.
     */
    "stateTaxFlag"?: boolean;
    "stateTaxXref"?: string;
    "stateTaxAmount"?: number;

    /**
     * Set to true if transaction is taxable at the county level.
     */
    "countyTaxFlag"?: boolean;
    "countyTaxXref"?: string;
    "countyTaxAmount"?: number;

    /**
     * Set to true if transaction is taxable at the city level.
     */
    "cityTaxFlag"?: boolean;
    "cityTaxXref"?: string;
    "cityTaxAmount"?: number;

    /**
     * Set to true if transaction is taxable at the country level.
     */
    "countryTaxFlag"?: boolean;
    "countryTaxXref"?: string;
    "countryTaxAmount"?: number;

    /**
     * Set to true if transaction is taxable at the composite level.
     */
    "compositeTaxFlag"?: boolean;
    "compositeTaxXref"?: string;
    "compositeTaxAmount"?: number;
    "dateClosed"?: Date;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace UnpostedExpense {

export type ClassificationEnum = 'NonReimbursable' | 'Reimbursable' | 'Personal';

export type GlTypeEnum = 'AP' | 'AR' | 'EE' | 'EI' | 'EO' | 'IA' | 'IT' | 'P' | 'PF' | 'R' | 'RA' | 'RD' | 'RE' | 'RP' | 'ST' | 'SD' | 'ET' | 'RM' | 'FT' | 'PT';
}
export interface UnpostedInvoice {
    "id"?: number;
    "billingLogId"?: number;
    "locationId"?: number;
    "departmentId"?: number;
    "company"?: CompanyReference;
    "accountNumber"?: string;
    "billToCompany"?: CompanyReference;
    "billToSite"?: SiteReference;
    "shipToCompany"?: CompanyReference;
    "shipToSite"?: SiteReference;
    "invoiceNumber"?: string;
    "invoiceDate"?: Date;
    "invoiceType"?: UnpostedInvoice.InvoiceTypeEnum;
    "description"?: string;
    "billingTerms"?: BillingTermsReference;
    "dueDays"?: string;
    "dueDate"?: Date;
    "currency"?: CurrencyReference;
    "subTotal"?: number;
    "total"?: number;
    "invoiceTaxableFlag"?: boolean;
    "taxCode"?: TaxCodeReference;

    /**
     * Used to determine if Avalara tax is enabled.
     */
    "avalaraTaxFlag"?: boolean;
    "itemTaxableFlag"?: boolean;
    "salesTaxAmount"?: number;

    /**
     * Set to true if transaction is taxable at the state level.
     */
    "stateTaxFlag"?: boolean;
    "stateTaxXref"?: string;
    "stateTaxAmount"?: number;

    /**
     * Set to true if transaction is taxable at the county level.
     */
    "countyTaxFlag"?: boolean;
    "countyTaxXref"?: string;
    "countyTaxAmount"?: number;

    /**
     * Set to true if transaction is taxable at the city level.
     */
    "cityTaxFlag"?: boolean;
    "cityTaxXref"?: string;
    "cityTaxAmount"?: number;

    /**
     * Set to true if transaction is taxable at the country level.
     */
    "countryTaxFlag"?: boolean;
    "countryTaxXref"?: string;
    "countryTaxAmount"?: number;

    /**
     * Set to true if transaction is taxable at the composite level.
     */
    "compositeTaxFlag"?: boolean;
    "compositeTaxXref"?: string;
    "compositeTaxAmount"?: number;
    "createdBy"?: string;
    "dateClosed"?: Date;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace UnpostedInvoice {

export type InvoiceTypeEnum = 'Agreement' | 'CreditMemo' | 'DownPayment' | 'Miscellaneous' | 'Progress' | 'Standard';
}
export interface UnpostedProcurement {
    "id"?: number;
    "description"?: string;
    "locationId"?: number;
    "departmentId"?: number;
    "procurementType"?: UnpostedProcurement.ProcurementTypeEnum;
    "purchaseOrder"?: PurchaseOrderReference;
    "purchaseDate"?: Date;
    "trackingNumber"?: string;
    "billingTerms"?: BillingTermsReference;
    "currency"?: CurrencyReference;
    "total"?: number;
    "taxCode"?: TaxCodeReference;

    /**
     * Used to determine if Avalara tax is enabled.
     */
    "avalaraTaxFlag"?: boolean;
    "itemTaxableFlag"?: boolean;
    "purchaseOrderTaxableFlag"?: boolean;

    /**
     * Set to true if transaction is taxable at the state level.
     */
    "stateTaxFlag"?: boolean;
    "stateTaxXref"?: string;
    "stateTaxAmount"?: number;

    /**
     * Set to true if transaction is taxable at the county level.
     */
    "countyTaxFlag"?: boolean;
    "countyTaxXref"?: string;
    "countyTaxAmount"?: number;

    /**
     * Set to true if transaction is taxable at the city level.
     */
    "cityTaxFlag"?: boolean;
    "cityTaxXref"?: string;
    "cityTaxAmount"?: number;

    /**
     * Set to true if transaction is taxable at the country level.
     */
    "countryTaxFlag"?: boolean;
    "countryTaxXref"?: string;
    "countryTaxAmount"?: number;

    /**
     * Set to true if transaction is taxable at the composite level.
     */
    "compositeTaxFlag"?: boolean;
    "compositeTaxXref"?: string;
    "compositeTaxAmount"?: number;
    "taxTotal"?: number;
    "customer"?: CompanyReference;
    "vendor"?: CompanyReference;
    "vendorAccountNumber"?: string;
    "vendorInvoiceNumber"?: string;
    "vendorInvoiceDate"?: Date;
    "taxFreightFlag"?: boolean;
    "freightTaxTotal"?: number;
    "freightCost"?: number;
    "dateClosed"?: Date;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace UnpostedProcurement {

export type ProcurementTypeEnum = 'Purchase' | 'Adjustment' | 'Transfer';
}
export interface UserDefinedField {

    /**
     * ID of the custom user defined field
     */
    "id"?: number;

    /**
     * Id of the Pod where the custom field will be placed
     */
    "podId": number;

    /**
     * Field caption
     */
    "caption": string;

    /**
     * Must be between 1 and 50.  This defines the order in which the custom fields will appear
     */
    "sequenceNumber": number;

    /**
     * Help text to accompany the custom field
     */
    "helpText"?: string;
    "fieldTypeIdentifier": UserDefinedField.FieldTypeIdentifierEnum;

    /**
     * Only valid for Number or percent
     */
    "numberDecimals"?: number;
    "entryTypeIdentifier"?: UserDefinedField.EntryTypeIdentifierEnum;
    "requiredFlag"?: boolean;
    "displayOnScreenFlag"?: boolean;
    "readOnlyFlag"?: boolean;

    /**
     * Denotes that this custom field is included on a list view
     */
    "listViewFlag"?: boolean;

    /**
     * Only available with Button Field Type. Required when entryTypeIdentifier is button
     */
    "buttonUrl"?: string;
    "options"?: Array<UserDefinedFieldOption>;
    "businessUnitIds"?: Array<number>;
    "locationIds"?: Array<number>;
    "addAllBusinessUnits"?: boolean;
    "removeAllBusinessUnits"?: boolean;
    "addAllLocations"?: boolean;
    "removeAllLocations"?: boolean;

    /**
     * Date in UTC the custom field was created
     */
    "dateCreated"?: Date;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace UserDefinedField {

export type FieldTypeIdentifierEnum = 'Text' | 'Button' | 'Date' | 'Hyperlink' | 'Checkbox' | 'Number' | 'Percent' | 'TextArea';

export type EntryTypeIdentifierEnum = 'EntryField' | 'List' | 'Option';
}
export interface UserDefinedFieldOption {
    "id"?: number;
    "optionValue": string;
    "defaultFlag"?: boolean;
    "inactiveFlag"?: boolean;
    "sortOrder"?: number;
}

export interface ValidatePortalRequest {
    "email": string;
    "password": string;
}

export interface ValidatePortalResponse {
    "success"?: boolean;
    "contactId"?: number;
}

export interface ValidationError {
    "code"?: string;
    "message"?: string;
    "resource"?: string;
    "field"?: string;
}

export interface ValueCollection {
    "count"?: number;
    "systemCollectionsGenericICollection&lt;TValue&gt;IsReadOnly"?: boolean;
    "systemCollectionsICollectionIsSynchronized"?: boolean;
    "systemCollectionsICollectionSyncRoot"?: string;
}

export interface WarehouseBinReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface WarehouseReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface WorkRoleReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface WorkTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}


//export namespace  {
    'use strict';

    export class AccountingBatchTransactionsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Transactions Count
         * @param id
         * @param conditions
         */
        public financeAccountingBatchesIdTransactionsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/accounting/batches/{id}/transactions/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAccountingBatchesIdTransactionsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Transactions
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeAccountingBatchesIdTransactionsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Transaction>> {
            const localVarPath = this.basePath + '/finance/accounting/batches/{id}/transactions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAccountingBatchesIdTransactionsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Transaction By Id
         * @param id
         * @param transactionId
         */
        public financeAccountingBatchesIdTransactionsTransactionIdGet (params: {  id: number; transactionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Transaction> {
            const localVarPath = this.basePath + '/finance/accounting/batches/{id}/transactions/{transactionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'transactionId' + '}', String(params.transactionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAccountingBatchesIdTransactionsTransactionIdGet');
            }
            // verify required parameter 'transactionId' is set
            if (params.transactionId == null) {
                throw new Error('Missing required parameter transactionId when calling financeAccountingBatchesIdTransactionsTransactionIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AccountingBatchesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Batches Count
         * @param conditions
         */
        public financeAccountingBatchesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/accounting/batches/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Batches
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeAccountingBatchesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Batch>> {
            const localVarPath = this.basePath + '/finance/accounting/batches';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Batch By Id
         * @param id
         */
        public financeAccountingBatchesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/accounting/batches/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAccountingBatchesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Batch By Id
         * @param id
         */
        public financeAccountingBatchesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Batch> {
            const localVarPath = this.basePath + '/finance/accounting/batches/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAccountingBatchesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Batch
         * @param batch
         */
        public financeAccountingBatchesPost (params: {  batch: Batch; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Batch> {
            const localVarPath = this.basePath + '/finance/accounting/batches';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'batch' is set
            if (params.batch == null) {
                throw new Error('Missing required parameter batch when calling financeAccountingBatchesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.batch),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AccountingUnpostedExpensesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Unposted Expenses Count
         * @param conditions
         */
        public financeAccountingUnpostedexpensesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/accounting/unpostedexpenses/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Unposted Expenses
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeAccountingUnpostedexpensesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<UnpostedExpense>> {
            const localVarPath = this.basePath + '/finance/accounting/unpostedexpenses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Unposted Expense By Id
         * @param id
         */
        public financeAccountingUnpostedexpensesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<UnpostedExpense> {
            const localVarPath = this.basePath + '/finance/accounting/unpostedexpenses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAccountingUnpostedexpensesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AccountingUnpostedProcurementsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Unposted Procurements Count
         * @param conditions
         */
        public financeAccountingUnpostedprocurementCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/accounting/unpostedprocurement/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Unposted Procurements
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeAccountingUnpostedprocurementGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<UnpostedProcurement>> {
            const localVarPath = this.basePath + '/finance/accounting/unpostedprocurement';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Unposted Procurement By Id
         * @param id
         */
        public financeAccountingUnpostedprocurementIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<UnpostedProcurement> {
            const localVarPath = this.basePath + '/finance/accounting/unpostedprocurement/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAccountingUnpostedprocurementIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AccountingUnpostedinvoicesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Unposted Invoices Count
         * @param conditions
         */
        public financeAccountingUnpostedinvoicesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/accounting/unpostedinvoices/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Unposted Invoices
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeAccountingUnpostedinvoicesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<UnpostedInvoice>> {
            const localVarPath = this.basePath + '/finance/accounting/unpostedinvoices';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Unposted Invoice By Id
         * @param id
         */
        public financeAccountingUnpostedinvoicesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<UnpostedInvoice> {
            const localVarPath = this.basePath + '/finance/accounting/unpostedinvoices/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAccountingUnpostedinvoicesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ActivitiesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Activities Count
         * @param conditions
         * @param customFieldConditions
         */
        public salesActivitiesCountGet (params: {  conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/sales/activities/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.customFieldConditions !== undefined) {
                queryParameters['customFieldConditions'] = params.customFieldConditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Activities
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public salesActivitiesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Activity>> {
            const localVarPath = this.basePath + '/sales/activities';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Activity By Id
         * @param id
         */
        public salesActivitiesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/sales/activities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesActivitiesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Activity By Id
         * @param id
         */
        public salesActivitiesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Activity> {
            const localVarPath = this.basePath + '/sales/activities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesActivitiesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Activity
         * @param id
         * @param operations
         */
        public salesActivitiesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Activity> {
            const localVarPath = this.basePath + '/sales/activities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesActivitiesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling salesActivitiesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Activity
         * @param id
         * @param activity
         */
        public salesActivitiesIdPut (params: {  id: number; activity: Activity; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Activity> {
            const localVarPath = this.basePath + '/sales/activities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesActivitiesIdPut');
            }
            // verify required parameter 'activity' is set
            if (params.activity == null) {
                throw new Error('Missing required parameter activity when calling salesActivitiesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.activity),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Activity
         * @param activity
         */
        public salesActivitiesPost (params: {  activity: Activity; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Activity> {
            const localVarPath = this.basePath + '/sales/activities';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'activity' is set
            if (params.activity == null) {
                throw new Error('Missing required parameter activity when calling salesActivitiesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.activity),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ActivityStatusesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Activity Statuses Count
         * @param conditions
         */
        public salesActivitiesStatusesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/sales/activities/statuses/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Activity Statuses
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public salesActivitiesStatusesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ActivityStatus>> {
            const localVarPath = this.basePath + '/sales/activities/statuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Activity Status By Id
         * @param id
         */
        public salesActivitiesStatusesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/sales/activities/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesActivitiesStatusesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Activity Status By Id
         * @param id
         */
        public salesActivitiesStatusesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityStatus> {
            const localVarPath = this.basePath + '/sales/activities/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesActivitiesStatusesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Activity Status
         * @param id
         * @param operations
         */
        public salesActivitiesStatusesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityStatus> {
            const localVarPath = this.basePath + '/sales/activities/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesActivitiesStatusesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling salesActivitiesStatusesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Activity Status
         * @param id
         * @param activityStatus
         */
        public salesActivitiesStatusesIdPut (params: {  id: number; activityStatus: ActivityStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityStatus> {
            const localVarPath = this.basePath + '/sales/activities/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesActivitiesStatusesIdPut');
            }
            // verify required parameter 'activityStatus' is set
            if (params.activityStatus == null) {
                throw new Error('Missing required parameter activityStatus when calling salesActivitiesStatusesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.activityStatus),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Activity Status
         * @param activityStatus
         */
        public salesActivitiesStatusesPost (params: {  activityStatus: ActivityStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityStatus> {
            const localVarPath = this.basePath + '/sales/activities/statuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'activityStatus' is set
            if (params.activityStatus == null) {
                throw new Error('Missing required parameter activityStatus when calling salesActivitiesStatusesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.activityStatus),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ActivityStopwatchesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Activity Stopwatches Count
         * @param conditions
         */
        public timeActivitystopwatchesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/time/activitystopwatches/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Activity Stopwatches
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public timeActivitystopwatchesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ActivityStopwatch>> {
            const localVarPath = this.basePath + '/time/activitystopwatches';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Activity Stopwatch By Id
         * @param id
         */
        public timeActivitystopwatchesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/time/activitystopwatches/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeActivitystopwatchesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Activity Stopwatch By Id
         * @param id
         */
        public timeActivitystopwatchesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityStopwatch> {
            const localVarPath = this.basePath + '/time/activitystopwatches/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeActivitystopwatchesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Activity Stopwatch
         * @param id
         * @param operations
         */
        public timeActivitystopwatchesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityStopwatch> {
            const localVarPath = this.basePath + '/time/activitystopwatches/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeActivitystopwatchesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling timeActivitystopwatchesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Activity Stopwatch
         * @param id
         * @param activityStopwatch
         */
        public timeActivitystopwatchesIdPut (params: {  id: number; activityStopwatch: ActivityStopwatch; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityStopwatch> {
            const localVarPath = this.basePath + '/time/activitystopwatches/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeActivitystopwatchesIdPut');
            }
            // verify required parameter 'activityStopwatch' is set
            if (params.activityStopwatch == null) {
                throw new Error('Missing required parameter activityStopwatch when calling timeActivitystopwatchesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.activityStopwatch),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Activity Stopwatch
         * @param activityStopwatch
         */
        public timeActivitystopwatchesPost (params: {  activityStopwatch: ActivityStopwatch; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityStopwatch> {
            const localVarPath = this.basePath + '/time/activitystopwatches';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'activityStopwatch' is set
            if (params.activityStopwatch == null) {
                throw new Error('Missing required parameter activityStopwatch when calling timeActivitystopwatchesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.activityStopwatch),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ActivityTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Activity Types Count
         * @param conditions
         */
        public salesActivitiesTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/sales/activities/types/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Activity Types
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public salesActivitiesTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ActivityType>> {
            const localVarPath = this.basePath + '/sales/activities/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Activity Type By Id
         * @param id
         */
        public salesActivitiesTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/sales/activities/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesActivitiesTypesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Activity Type By Id
         * @param id
         */
        public salesActivitiesTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityType> {
            const localVarPath = this.basePath + '/sales/activities/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesActivitiesTypesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Activity Type
         * @param id
         * @param operations
         */
        public salesActivitiesTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityType> {
            const localVarPath = this.basePath + '/sales/activities/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesActivitiesTypesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling salesActivitiesTypesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Activity Type
         * @param id
         * @param activityType
         */
        public salesActivitiesTypesIdPut (params: {  id: number; activityType: ActivityType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityType> {
            const localVarPath = this.basePath + '/sales/activities/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesActivitiesTypesIdPut');
            }
            // verify required parameter 'activityType' is set
            if (params.activityType == null) {
                throw new Error('Missing required parameter activityType when calling salesActivitiesTypesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.activityType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Activity Type
         * @param activityType
         */
        public salesActivitiesTypesPost (params: {  activityType: ActivityType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityType> {
            const localVarPath = this.basePath + '/sales/activities/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'activityType' is set
            if (params.activityType == null) {
                throw new Error('Missing required parameter activityType when calling salesActivitiesTypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.activityType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AdjustmentDetailsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Adjustment Detail Count
         * @param id
         * @param conditions
         */
        public procurementAdjustmentsIdDetailsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/adjustments/{id}/details/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementAdjustmentsIdDetailsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Adjustment Detail By Id
         * @param id
         * @param detailId
         */
        public procurementAdjustmentsIdDetailsDetailIdDelete (params: {  id: number; detailId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/adjustments/{id}/details/{detailId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'detailId' + '}', String(params.detailId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementAdjustmentsIdDetailsDetailIdDelete');
            }
            // verify required parameter 'detailId' is set
            if (params.detailId == null) {
                throw new Error('Missing required parameter detailId when calling procurementAdjustmentsIdDetailsDetailIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Adjustment Detail By Id
         * @param id
         * @param detailId
         */
        public procurementAdjustmentsIdDetailsDetailIdGet (params: {  id: number; detailId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AdjustmentDetail> {
            const localVarPath = this.basePath + '/procurement/adjustments/{id}/details/{detailId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'detailId' + '}', String(params.detailId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementAdjustmentsIdDetailsDetailIdGet');
            }
            // verify required parameter 'detailId' is set
            if (params.detailId == null) {
                throw new Error('Missing required parameter detailId when calling procurementAdjustmentsIdDetailsDetailIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Adjustment Detail
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementAdjustmentsIdDetailsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AdjustmentDetail>> {
            const localVarPath = this.basePath + '/procurement/adjustments/{id}/details'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementAdjustmentsIdDetailsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Adjustment Detail
         * @param id
         * @param adjustmentDetail
         */
        public procurementAdjustmentsIdDetailsPost (params: {  id: number; adjustmentDetail: AdjustmentDetail; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AdjustmentDetail> {
            const localVarPath = this.basePath + '/procurement/adjustments/{id}/details'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementAdjustmentsIdDetailsPost');
            }
            // verify required parameter 'adjustmentDetail' is set
            if (params.adjustmentDetail == null) {
                throw new Error('Missing required parameter adjustmentDetail when calling procurementAdjustmentsIdDetailsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.adjustmentDetail),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AdjustmentTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Adjustment Types Count
         * @param conditions
         */
        public procurementAdjustmentsTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/adjustments/types/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Adjustment Types
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementAdjustmentsTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AdjustmentType>> {
            const localVarPath = this.basePath + '/procurement/adjustments/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Adjustment Types By Id
         * @param id
         */
        public procurementAdjustmentsTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/adjustments/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementAdjustmentsTypesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Adjustment Types By Id
         * @param id
         */
        public procurementAdjustmentsTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AdjustmentType> {
            const localVarPath = this.basePath + '/procurement/adjustments/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementAdjustmentsTypesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Adjustment Types
         * @param id
         * @param operations
         */
        public procurementAdjustmentsTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AdjustmentType> {
            const localVarPath = this.basePath + '/procurement/adjustments/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementAdjustmentsTypesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementAdjustmentsTypesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Adjustment Types
         * @param id
         * @param adjustmentTypes
         */
        public procurementAdjustmentsTypesIdPut (params: {  id: number; adjustmentTypes: AdjustmentType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AdjustmentType> {
            const localVarPath = this.basePath + '/procurement/adjustments/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementAdjustmentsTypesIdPut');
            }
            // verify required parameter 'adjustmentTypes' is set
            if (params.adjustmentTypes == null) {
                throw new Error('Missing required parameter adjustmentTypes when calling procurementAdjustmentsTypesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.adjustmentTypes),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Adjustment Types
         * @param adjustmentTypes
         */
        public procurementAdjustmentsTypesPost (params: {  adjustmentTypes: AdjustmentType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AdjustmentType> {
            const localVarPath = this.basePath + '/procurement/adjustments/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'adjustmentTypes' is set
            if (params.adjustmentTypes == null) {
                throw new Error('Missing required parameter adjustmentTypes when calling procurementAdjustmentsTypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.adjustmentTypes),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AdjustmentsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Adjustment Count
         * @param conditions
         */
        public procurementAdjustmentsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/adjustments/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Adjustment
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementAdjustmentsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Adjustment>> {
            const localVarPath = this.basePath + '/procurement/adjustments';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Adjustment By Id
         * @param id
         */
        public procurementAdjustmentsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/adjustments/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementAdjustmentsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Adjustment By Id
         * @param id
         */
        public procurementAdjustmentsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Adjustment> {
            const localVarPath = this.basePath + '/procurement/adjustments/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementAdjustmentsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Adjustment
         * @param id
         * @param operations
         */
        public procurementAdjustmentsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Adjustment> {
            const localVarPath = this.basePath + '/procurement/adjustments/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementAdjustmentsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementAdjustmentsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Adjustment
         * @param id
         * @param adjustment
         */
        public procurementAdjustmentsIdPut (params: {  id: number; adjustment: Adjustment; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Adjustment> {
            const localVarPath = this.basePath + '/procurement/adjustments/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementAdjustmentsIdPut');
            }
            // verify required parameter 'adjustment' is set
            if (params.adjustment == null) {
                throw new Error('Missing required parameter adjustment when calling procurementAdjustmentsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.adjustment),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Adjustment
         * @param adjustment
         */
        public procurementAdjustmentsPost (params: {  adjustment: Adjustment; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Adjustment> {
            const localVarPath = this.basePath + '/procurement/adjustments';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'adjustment' is set
            if (params.adjustment == null) {
                throw new Error('Missing required parameter adjustment when calling procurementAdjustmentsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.adjustment),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AgreementAdditionsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Delete Addition By Id
         * @param id
         * @param additionId
         */
        public financeAgreementsIdAdditionsAdditionIdDelete (params: {  id: number; additionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/additions/{additionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'additionId' + '}', String(params.additionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdAdditionsAdditionIdDelete');
            }
            // verify required parameter 'additionId' is set
            if (params.additionId == null) {
                throw new Error('Missing required parameter additionId when calling financeAgreementsIdAdditionsAdditionIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Addition By Id
         * @param id
         * @param additionId
         */
        public financeAgreementsIdAdditionsAdditionIdGet (params: {  id: number; additionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Addition> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/additions/{additionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'additionId' + '}', String(params.additionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdAdditionsAdditionIdGet');
            }
            // verify required parameter 'additionId' is set
            if (params.additionId == null) {
                throw new Error('Missing required parameter additionId when calling financeAgreementsIdAdditionsAdditionIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Addition
         * @param id
         * @param additionId
         * @param operations
         */
        public financeAgreementsIdAdditionsAdditionIdPatch (params: {  id: number; additionId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Addition> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/additions/{additionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'additionId' + '}', String(params.additionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdAdditionsAdditionIdPatch');
            }
            // verify required parameter 'additionId' is set
            if (params.additionId == null) {
                throw new Error('Missing required parameter additionId when calling financeAgreementsIdAdditionsAdditionIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeAgreementsIdAdditionsAdditionIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Addition
         * @param id
         * @param additionId
         * @param addition
         */
        public financeAgreementsIdAdditionsAdditionIdPut (params: {  id: number; additionId: number; addition: Addition; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Addition> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/additions/{additionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'additionId' + '}', String(params.additionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdAdditionsAdditionIdPut');
            }
            // verify required parameter 'additionId' is set
            if (params.additionId == null) {
                throw new Error('Missing required parameter additionId when calling financeAgreementsIdAdditionsAdditionIdPut');
            }
            // verify required parameter 'addition' is set
            if (params.addition == null) {
                throw new Error('Missing required parameter addition when calling financeAgreementsIdAdditionsAdditionIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.addition),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Additions Count
         * @param id
         * @param conditions
         * @param customFieldConditions
         */
        public financeAgreementsIdAdditionsCountGet (params: {  id: number; conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/additions/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdAdditionsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.customFieldConditions !== undefined) {
                queryParameters['customFieldConditions'] = params.customFieldConditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Additions
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeAgreementsIdAdditionsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Addition>> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/additions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdAdditionsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Addition
         * @param id
         * @param addition
         */
        public financeAgreementsIdAdditionsPost (params: {  id: number; addition: Addition; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Addition> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/additions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdAdditionsPost');
            }
            // verify required parameter 'addition' is set
            if (params.addition == null) {
                throw new Error('Missing required parameter addition when calling financeAgreementsIdAdditionsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.addition),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AgreementAdjustmentsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Delete Adjustment By Id
         * @param id
         * @param adjustmentId
         */
        public financeAgreementsIdAdjustmentsAdjustmentIdDelete (params: {  id: number; adjustmentId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/adjustments/{adjustmentId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'adjustmentId' + '}', String(params.adjustmentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdAdjustmentsAdjustmentIdDelete');
            }
            // verify required parameter 'adjustmentId' is set
            if (params.adjustmentId == null) {
                throw new Error('Missing required parameter adjustmentId when calling financeAgreementsIdAdjustmentsAdjustmentIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Adjustment By Id
         * @param id
         * @param adjustmentId
         */
        public financeAgreementsIdAdjustmentsAdjustmentIdGet (params: {  id: number; adjustmentId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Adjustment> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/adjustments/{adjustmentId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'adjustmentId' + '}', String(params.adjustmentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdAdjustmentsAdjustmentIdGet');
            }
            // verify required parameter 'adjustmentId' is set
            if (params.adjustmentId == null) {
                throw new Error('Missing required parameter adjustmentId when calling financeAgreementsIdAdjustmentsAdjustmentIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Adjustment
         * @param id
         * @param adjustmentId
         * @param operations
         */
        public financeAgreementsIdAdjustmentsAdjustmentIdPatch (params: {  id: number; adjustmentId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Adjustment> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/adjustments/{adjustmentId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'adjustmentId' + '}', String(params.adjustmentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdAdjustmentsAdjustmentIdPatch');
            }
            // verify required parameter 'adjustmentId' is set
            if (params.adjustmentId == null) {
                throw new Error('Missing required parameter adjustmentId when calling financeAgreementsIdAdjustmentsAdjustmentIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeAgreementsIdAdjustmentsAdjustmentIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Adjustment
         * @param id
         * @param adjustmentId
         * @param adjustment
         */
        public financeAgreementsIdAdjustmentsAdjustmentIdPut (params: {  id: number; adjustmentId: number; adjustment: Adjustment; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Adjustment> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/adjustments/{adjustmentId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'adjustmentId' + '}', String(params.adjustmentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdAdjustmentsAdjustmentIdPut');
            }
            // verify required parameter 'adjustmentId' is set
            if (params.adjustmentId == null) {
                throw new Error('Missing required parameter adjustmentId when calling financeAgreementsIdAdjustmentsAdjustmentIdPut');
            }
            // verify required parameter 'adjustment' is set
            if (params.adjustment == null) {
                throw new Error('Missing required parameter adjustment when calling financeAgreementsIdAdjustmentsAdjustmentIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.adjustment),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Adjustments Count
         * @param id
         * @param conditions
         * @param customFieldConditions
         */
        public financeAgreementsIdAdjustmentsCountGet (params: {  id: number; conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/adjustments/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdAdjustmentsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.customFieldConditions !== undefined) {
                queryParameters['customFieldConditions'] = params.customFieldConditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Adjustments
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeAgreementsIdAdjustmentsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Adjustment>> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/adjustments'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdAdjustmentsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Adjustment
         * @param id
         * @param adjustment
         */
        public financeAgreementsIdAdjustmentsPost (params: {  id: number; adjustment: Adjustment; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Adjustment> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/adjustments'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdAdjustmentsPost');
            }
            // verify required parameter 'adjustment' is set
            if (params.adjustment == null) {
                throw new Error('Missing required parameter adjustment when calling financeAgreementsIdAdjustmentsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.adjustment),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AgreementBoardDefaultsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Delete Board Default By Id
         * @param id
         * @param boardDefaultId
         */
        public financeAgreementsIdBoardDefaultsBoardDefaultIdDelete (params: {  id: number; boardDefaultId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/boardDefaults/{boardDefaultId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'boardDefaultId' + '}', String(params.boardDefaultId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdBoardDefaultsBoardDefaultIdDelete');
            }
            // verify required parameter 'boardDefaultId' is set
            if (params.boardDefaultId == null) {
                throw new Error('Missing required parameter boardDefaultId when calling financeAgreementsIdBoardDefaultsBoardDefaultIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Board Default By Id
         * @param id
         * @param boardDefaultId
         */
        public financeAgreementsIdBoardDefaultsBoardDefaultIdGet (params: {  id: number; boardDefaultId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardDefault> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/boardDefaults/{boardDefaultId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'boardDefaultId' + '}', String(params.boardDefaultId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdBoardDefaultsBoardDefaultIdGet');
            }
            // verify required parameter 'boardDefaultId' is set
            if (params.boardDefaultId == null) {
                throw new Error('Missing required parameter boardDefaultId when calling financeAgreementsIdBoardDefaultsBoardDefaultIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Board Default
         * @param id
         * @param boardDefaultId
         * @param operations
         */
        public financeAgreementsIdBoardDefaultsBoardDefaultIdPatch (params: {  id: number; boardDefaultId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardDefault> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/boardDefaults/{boardDefaultId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'boardDefaultId' + '}', String(params.boardDefaultId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdBoardDefaultsBoardDefaultIdPatch');
            }
            // verify required parameter 'boardDefaultId' is set
            if (params.boardDefaultId == null) {
                throw new Error('Missing required parameter boardDefaultId when calling financeAgreementsIdBoardDefaultsBoardDefaultIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeAgreementsIdBoardDefaultsBoardDefaultIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Board Default
         * @param id
         * @param boardDefaultId
         * @param boardDefault
         */
        public financeAgreementsIdBoardDefaultsBoardDefaultIdPut (params: {  id: number; boardDefaultId: number; boardDefault: BoardDefault; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardDefault> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/boardDefaults/{boardDefaultId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'boardDefaultId' + '}', String(params.boardDefaultId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdBoardDefaultsBoardDefaultIdPut');
            }
            // verify required parameter 'boardDefaultId' is set
            if (params.boardDefaultId == null) {
                throw new Error('Missing required parameter boardDefaultId when calling financeAgreementsIdBoardDefaultsBoardDefaultIdPut');
            }
            // verify required parameter 'boardDefault' is set
            if (params.boardDefault == null) {
                throw new Error('Missing required parameter boardDefault when calling financeAgreementsIdBoardDefaultsBoardDefaultIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.boardDefault),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Board Defaults Count
         * @param id
         * @param conditions
         */
        public financeAgreementsIdBoardDefaultsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/boardDefaults/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdBoardDefaultsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Board Defaults
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeAgreementsIdBoardDefaultsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<BoardDefault>> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/boardDefaults'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdBoardDefaultsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Board Default
         * @param id
         * @param boardDefault
         */
        public financeAgreementsIdBoardDefaultsPost (params: {  id: number; boardDefault: BoardDefault; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardDefault> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/boardDefaults'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdBoardDefaultsPost');
            }
            // verify required parameter 'boardDefault' is set
            if (params.boardDefault == null) {
                throw new Error('Missing required parameter boardDefault when calling financeAgreementsIdBoardDefaultsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.boardDefault),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AgreementSitesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Sites Count
         * @param id
         * @param conditions
         */
        public financeAgreementsIdSitesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/sites/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdSitesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Sites
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeAgreementsIdSitesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AgreementSite>> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/sites'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdSitesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Site
         * @param id
         * @param site
         */
        public financeAgreementsIdSitesPost (params: {  id: number; site: AgreementSite; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementSite> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/sites'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdSitesPost');
            }
            // verify required parameter 'site' is set
            if (params.site == null) {
                throw new Error('Missing required parameter site when calling financeAgreementsIdSitesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.site),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Site By Id
         * @param id
         * @param siteId
         */
        public financeAgreementsIdSitesSiteIdDelete (params: {  id: number; siteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/sites/{siteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'siteId' + '}', String(params.siteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdSitesSiteIdDelete');
            }
            // verify required parameter 'siteId' is set
            if (params.siteId == null) {
                throw new Error('Missing required parameter siteId when calling financeAgreementsIdSitesSiteIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Site By Id
         * @param id
         * @param siteId
         */
        public financeAgreementsIdSitesSiteIdGet (params: {  id: number; siteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementSite> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/sites/{siteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'siteId' + '}', String(params.siteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdSitesSiteIdGet');
            }
            // verify required parameter 'siteId' is set
            if (params.siteId == null) {
                throw new Error('Missing required parameter siteId when calling financeAgreementsIdSitesSiteIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Site
         * @param id
         * @param siteId
         * @param operations
         */
        public financeAgreementsIdSitesSiteIdPatch (params: {  id: number; siteId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementSite> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/sites/{siteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'siteId' + '}', String(params.siteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdSitesSiteIdPatch');
            }
            // verify required parameter 'siteId' is set
            if (params.siteId == null) {
                throw new Error('Missing required parameter siteId when calling financeAgreementsIdSitesSiteIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeAgreementsIdSitesSiteIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Site
         * @param id
         * @param siteId
         * @param site
         */
        public financeAgreementsIdSitesSiteIdPut (params: {  id: number; siteId: number; site: AgreementSite; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementSite> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/sites/{siteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'siteId' + '}', String(params.siteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdSitesSiteIdPut');
            }
            // verify required parameter 'siteId' is set
            if (params.siteId == null) {
                throw new Error('Missing required parameter siteId when calling financeAgreementsIdSitesSiteIdPut');
            }
            // verify required parameter 'site' is set
            if (params.site == null) {
                throw new Error('Missing required parameter site when calling financeAgreementsIdSitesSiteIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.site),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AgreementTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Agreement Types Count
         * @param conditions
         */
        public financeAgreementsTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/agreements/types/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Agreement Types
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeAgreementsTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AgreementType>> {
            const localVarPath = this.basePath + '/finance/agreements/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Agreement Type By Id
         * @param id
         */
        public financeAgreementsTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/agreements/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsTypesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Agreement Type By Id
         * @param id
         */
        public financeAgreementsTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementType> {
            const localVarPath = this.basePath + '/finance/agreements/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsTypesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Agreement Type
         * @param id
         * @param operations
         */
        public financeAgreementsTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementType> {
            const localVarPath = this.basePath + '/finance/agreements/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsTypesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeAgreementsTypesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Agreement Type
         * @param id
         * @param agreementType
         */
        public financeAgreementsTypesIdPut (params: {  id: number; agreementType: AgreementType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementType> {
            const localVarPath = this.basePath + '/finance/agreements/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsTypesIdPut');
            }
            // verify required parameter 'agreementType' is set
            if (params.agreementType == null) {
                throw new Error('Missing required parameter agreementType when calling financeAgreementsTypesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.agreementType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Agreement Type
         * @param agreementType
         */
        public financeAgreementsTypesPost (params: {  agreementType: AgreementType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementType> {
            const localVarPath = this.basePath + '/finance/agreements/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'agreementType' is set
            if (params.agreementType == null) {
                throw new Error('Missing required parameter agreementType when calling financeAgreementsTypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.agreementType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AgreementWorkRoleExclusionsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Work Role Exclusions Count
         * @param id
         * @param conditions
         */
        public financeAgreementsIdWorkRoleExclusionsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/workRoleExclusions/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorkRoleExclusionsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Work Role Exclusions
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeAgreementsIdWorkRoleExclusionsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AgreementWorkRoleExclusion>> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/workRoleExclusions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorkRoleExclusionsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Work Role Exclusion
         * @param id
         * @param workRoleExclusion
         */
        public financeAgreementsIdWorkRoleExclusionsPost (params: {  id: number; workRoleExclusion: AgreementWorkRoleExclusion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementWorkRoleExclusion> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/workRoleExclusions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorkRoleExclusionsPost');
            }
            // verify required parameter 'workRoleExclusion' is set
            if (params.workRoleExclusion == null) {
                throw new Error('Missing required parameter workRoleExclusion when calling financeAgreementsIdWorkRoleExclusionsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.workRoleExclusion),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Work Role Exclusion By Id
         * @param id
         * @param workRoleExclusionId
         */
        public financeAgreementsIdWorkRoleExclusionsWorkRoleExclusionIdDelete (params: {  id: number; workRoleExclusionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/workRoleExclusions/{workRoleExclusionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'workRoleExclusionId' + '}', String(params.workRoleExclusionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorkRoleExclusionsWorkRoleExclusionIdDelete');
            }
            // verify required parameter 'workRoleExclusionId' is set
            if (params.workRoleExclusionId == null) {
                throw new Error('Missing required parameter workRoleExclusionId when calling financeAgreementsIdWorkRoleExclusionsWorkRoleExclusionIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AgreementWorkRolesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Work Roles Count
         * @param id
         * @param conditions
         */
        public financeAgreementsIdWorkrolesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/workroles/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorkrolesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Work Roles
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeAgreementsIdWorkrolesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AgreementWorkRole>> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/workroles'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorkrolesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Work Role
         * @param id
         * @param workRole
         */
        public financeAgreementsIdWorkrolesPost (params: {  id: number; workRole: AgreementWorkRole; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementWorkRole> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/workroles'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorkrolesPost');
            }
            // verify required parameter 'workRole' is set
            if (params.workRole == null) {
                throw new Error('Missing required parameter workRole when calling financeAgreementsIdWorkrolesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.workRole),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Work Role By Id
         * @param id
         * @param workRoleId
         */
        public financeAgreementsIdWorkrolesWorkRoleIdDelete (params: {  id: number; workRoleId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/workroles/{workRoleId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'workRoleId' + '}', String(params.workRoleId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorkrolesWorkRoleIdDelete');
            }
            // verify required parameter 'workRoleId' is set
            if (params.workRoleId == null) {
                throw new Error('Missing required parameter workRoleId when calling financeAgreementsIdWorkrolesWorkRoleIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Work Role By Id
         * @param id
         * @param workRoleId
         */
        public financeAgreementsIdWorkrolesWorkRoleIdGet (params: {  id: number; workRoleId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementWorkRole> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/workroles/{workRoleId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'workRoleId' + '}', String(params.workRoleId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorkrolesWorkRoleIdGet');
            }
            // verify required parameter 'workRoleId' is set
            if (params.workRoleId == null) {
                throw new Error('Missing required parameter workRoleId when calling financeAgreementsIdWorkrolesWorkRoleIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Work Role
         * @param id
         * @param workRoleId
         * @param operations
         */
        public financeAgreementsIdWorkrolesWorkRoleIdPatch (params: {  id: number; workRoleId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementWorkRole> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/workroles/{workRoleId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'workRoleId' + '}', String(params.workRoleId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorkrolesWorkRoleIdPatch');
            }
            // verify required parameter 'workRoleId' is set
            if (params.workRoleId == null) {
                throw new Error('Missing required parameter workRoleId when calling financeAgreementsIdWorkrolesWorkRoleIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeAgreementsIdWorkrolesWorkRoleIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Work Role
         * @param id
         * @param workRoleId
         * @param workRole
         */
        public financeAgreementsIdWorkrolesWorkRoleIdPut (params: {  id: number; workRoleId: number; workRole: AgreementWorkRole; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementWorkRole> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/workroles/{workRoleId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'workRoleId' + '}', String(params.workRoleId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorkrolesWorkRoleIdPut');
            }
            // verify required parameter 'workRoleId' is set
            if (params.workRoleId == null) {
                throw new Error('Missing required parameter workRoleId when calling financeAgreementsIdWorkrolesWorkRoleIdPut');
            }
            // verify required parameter 'workRole' is set
            if (params.workRole == null) {
                throw new Error('Missing required parameter workRole when calling financeAgreementsIdWorkrolesWorkRoleIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.workRole),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AgreementWorkTypeExclusionsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Work Type Exclusions Count
         * @param id
         * @param conditions
         */
        public financeAgreementsIdWorkTypeExclusionsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/workTypeExclusions/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorkTypeExclusionsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Work Type Exclusions
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeAgreementsIdWorkTypeExclusionsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AgreementWorkTypeExclusion>> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/workTypeExclusions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorkTypeExclusionsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Work Type Exclusion
         * @param id
         * @param workTypeExclusion
         */
        public financeAgreementsIdWorkTypeExclusionsPost (params: {  id: number; workTypeExclusion: AgreementWorkTypeExclusion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementWorkTypeExclusion> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/workTypeExclusions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorkTypeExclusionsPost');
            }
            // verify required parameter 'workTypeExclusion' is set
            if (params.workTypeExclusion == null) {
                throw new Error('Missing required parameter workTypeExclusion when calling financeAgreementsIdWorkTypeExclusionsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.workTypeExclusion),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Work Type Exclusion By Id
         * @param id
         * @param workTypeExclusionId
         */
        public financeAgreementsIdWorkTypeExclusionsWorkTypeExclusionIdDelete (params: {  id: number; workTypeExclusionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/workTypeExclusions/{workTypeExclusionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'workTypeExclusionId' + '}', String(params.workTypeExclusionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorkTypeExclusionsWorkTypeExclusionIdDelete');
            }
            // verify required parameter 'workTypeExclusionId' is set
            if (params.workTypeExclusionId == null) {
                throw new Error('Missing required parameter workTypeExclusionId when calling financeAgreementsIdWorkTypeExclusionsWorkTypeExclusionIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AgreementWorkTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Work Types Count
         * @param id
         * @param conditions
         */
        public financeAgreementsIdWorktypesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/worktypes/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorktypesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Work Types
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeAgreementsIdWorktypesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AgreementWorkType>> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/worktypes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorktypesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Work Type
         * @param id
         * @param workType
         */
        public financeAgreementsIdWorktypesPost (params: {  id: number; workType: AgreementWorkType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementWorkType> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/worktypes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorktypesPost');
            }
            // verify required parameter 'workType' is set
            if (params.workType == null) {
                throw new Error('Missing required parameter workType when calling financeAgreementsIdWorktypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.workType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Work Type By Id
         * @param id
         * @param worktypeId
         */
        public financeAgreementsIdWorktypesWorktypeIdDelete (params: {  id: number; worktypeId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/worktypes/{worktypeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'worktypeId' + '}', String(params.worktypeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorktypesWorktypeIdDelete');
            }
            // verify required parameter 'worktypeId' is set
            if (params.worktypeId == null) {
                throw new Error('Missing required parameter worktypeId when calling financeAgreementsIdWorktypesWorktypeIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Work Type By Id
         * @param id
         * @param worktypeId
         */
        public financeAgreementsIdWorktypesWorktypeIdGet (params: {  id: number; worktypeId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementWorkType> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/worktypes/{worktypeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'worktypeId' + '}', String(params.worktypeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorktypesWorktypeIdGet');
            }
            // verify required parameter 'worktypeId' is set
            if (params.worktypeId == null) {
                throw new Error('Missing required parameter worktypeId when calling financeAgreementsIdWorktypesWorktypeIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Work Type
         * @param id
         * @param worktypeId
         * @param operations
         */
        public financeAgreementsIdWorktypesWorktypeIdPatch (params: {  id: number; worktypeId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementWorkType> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/worktypes/{worktypeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'worktypeId' + '}', String(params.worktypeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorktypesWorktypeIdPatch');
            }
            // verify required parameter 'worktypeId' is set
            if (params.worktypeId == null) {
                throw new Error('Missing required parameter worktypeId when calling financeAgreementsIdWorktypesWorktypeIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeAgreementsIdWorktypesWorktypeIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Work Type
         * @param id
         * @param worktypeId
         * @param workType
         */
        public financeAgreementsIdWorktypesWorktypeIdPut (params: {  id: number; worktypeId: number; workType: AgreementWorkType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementWorkType> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/worktypes/{worktypeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'worktypeId' + '}', String(params.worktypeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorktypesWorktypeIdPut');
            }
            // verify required parameter 'worktypeId' is set
            if (params.worktypeId == null) {
                throw new Error('Missing required parameter worktypeId when calling financeAgreementsIdWorktypesWorktypeIdPut');
            }
            // verify required parameter 'workType' is set
            if (params.workType == null) {
                throw new Error('Missing required parameter workType when calling financeAgreementsIdWorktypesWorktypeIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.workType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AgreementsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Agreements Count
         * @param conditions
         * @param customFieldConditions
         */
        public financeAgreementsCountGet (params: {  conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/agreements/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.customFieldConditions !== undefined) {
                queryParameters['customFieldConditions'] = params.customFieldConditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Agreements
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeAgreementsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Agreement>> {
            const localVarPath = this.basePath + '/finance/agreements';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Configuration Association
         * @param id
         * @param configurationId
         */
        public financeAgreementsIdConfigurationsConfigurationIdDelete (params: {  id: number; configurationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/configurations/{configurationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'configurationId' + '}', String(params.configurationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdConfigurationsConfigurationIdDelete');
            }
            // verify required parameter 'configurationId' is set
            if (params.configurationId == null) {
                throw new Error('Missing required parameter configurationId when calling financeAgreementsIdConfigurationsConfigurationIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Configuration Association
         * @param id
         * @param configurationId
         */
        public financeAgreementsIdConfigurationsConfigurationIdGet (params: {  id: number; configurationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationReference> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/configurations/{configurationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'configurationId' + '}', String(params.configurationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdConfigurationsConfigurationIdGet');
            }
            // verify required parameter 'configurationId' is set
            if (params.configurationId == null) {
                throw new Error('Missing required parameter configurationId when calling financeAgreementsIdConfigurationsConfigurationIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Agreement Configurations Count
         * @param id
         */
        public financeAgreementsIdConfigurationsCountGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/configurations/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdConfigurationsCountGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Agreement Configurations
         * @param id
         * @param page
         * @param pageSize
         */
        public financeAgreementsIdConfigurationsGet (params: {  id: number; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ConfigurationReference>> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/configurations'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdConfigurationsGet');
            }
            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Configuration Association
         * @param id
         * @param configuration
         */
        public financeAgreementsIdConfigurationsPost (params: {  id: number; configuration: ConfigurationReference; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationReference> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/configurations'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdConfigurationsPost');
            }
            // verify required parameter 'configuration' is set
            if (params.configuration == null) {
                throw new Error('Missing required parameter configuration when calling financeAgreementsIdConfigurationsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.configuration),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Agreement By Id
         * @param id
         */
        public financeAgreementsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/agreements/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Agreement By Id
         * @param id
         */
        public financeAgreementsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Agreement> {
            const localVarPath = this.basePath + '/finance/agreements/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Agreement
         * @param id
         * @param operations
         */
        public financeAgreementsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Agreement> {
            const localVarPath = this.basePath + '/finance/agreements/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeAgreementsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Agreement
         * @param id
         * @param agreement
         */
        public financeAgreementsIdPut (params: {  id: number; agreement: Agreement; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Agreement> {
            const localVarPath = this.basePath + '/finance/agreements/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdPut');
            }
            // verify required parameter 'agreement' is set
            if (params.agreement == null) {
                throw new Error('Missing required parameter agreement when calling financeAgreementsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.agreement),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Agreement
         * @param agreement
         */
        public financeAgreementsPost (params: {  agreement: Agreement; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Agreement> {
            const localVarPath = this.basePath + '/finance/agreements';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'agreement' is set
            if (params.agreement == null) {
                throw new Error('Missing required parameter agreement when calling financeAgreementsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.agreement),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AuditTrailApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Members Count
         * @param type
         * @param id
         * @param deviceIdentifier
         */
        public systemAudittrailCountGet (params: {  type?: string; id?: number; deviceIdentifier?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/audittrail/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.type !== undefined) {
                queryParameters['type'] = params.type;
            }

            if (params.id !== undefined) {
                queryParameters['id'] = params.id;
            }

            if (params.deviceIdentifier !== undefined) {
                queryParameters['deviceIdentifier'] = params.deviceIdentifier;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Audit Trail
         * @param type
         * @param id
         * @param deviceIdentifier
         * @param page
         * @param pageSize
         */
        public systemAudittrailGet (params: {  type?: string; id?: number; deviceIdentifier?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AuditTrailEntry>> {
            const localVarPath = this.basePath + '/system/audittrail';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.type !== undefined) {
                queryParameters['type'] = params.type;
            }

            if (params.id !== undefined) {
                queryParameters['id'] = params.id;
            }

            if (params.deviceIdentifier !== undefined) {
                queryParameters['deviceIdentifier'] = params.deviceIdentifier;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BatchApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Process Batch Requests
         * @param request
         */
        public systemBatchPost (params: {  request: BatchRequest; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BatchResponse> {
            const localVarPath = this.basePath + '/system/batch';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'request' is set
            if (params.request == null) {
                throw new Error('Missing required parameter request when calling systemBatchPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.request),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BoardExcludedMembersApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Excluded Members Count
         * @param id
         * @param conditions
         */
        public serviceBoardsIdExcludedMembersCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/boards/{id}/excludedMembers/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdExcludedMembersCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Excluded Member By Id
         * @param id
         * @param excludedMemberId
         */
        public serviceBoardsIdExcludedMembersExcludedMemberIdDelete (params: {  id: number; excludedMemberId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/boards/{id}/excludedMembers/{excludedMemberId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'excludedMemberId' + '}', String(params.excludedMemberId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdExcludedMembersExcludedMemberIdDelete');
            }
            // verify required parameter 'excludedMemberId' is set
            if (params.excludedMemberId == null) {
                throw new Error('Missing required parameter excludedMemberId when calling serviceBoardsIdExcludedMembersExcludedMemberIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Excluded Member By Id
         * @param id
         * @param excludedMemberId
         */
        public serviceBoardsIdExcludedMembersExcludedMemberIdGet (params: {  id: number; excludedMemberId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ExcludedMember> {
            const localVarPath = this.basePath + '/service/boards/{id}/excludedMembers/{excludedMemberId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'excludedMemberId' + '}', String(params.excludedMemberId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdExcludedMembersExcludedMemberIdGet');
            }
            // verify required parameter 'excludedMemberId' is set
            if (params.excludedMemberId == null) {
                throw new Error('Missing required parameter excludedMemberId when calling serviceBoardsIdExcludedMembersExcludedMemberIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Excluded Members
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceBoardsIdExcludedMembersGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ExcludedMember>> {
            const localVarPath = this.basePath + '/service/boards/{id}/excludedMembers'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdExcludedMembersGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Excluded Member
         * @param id
         * @param excludedMember
         */
        public serviceBoardsIdExcludedMembersPost (params: {  id: number; excludedMember: ExcludedMember; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ExcludedMember> {
            const localVarPath = this.basePath + '/service/boards/{id}/excludedMembers'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdExcludedMembersPost');
            }
            // verify required parameter 'excludedMember' is set
            if (params.excludedMember == null) {
                throw new Error('Missing required parameter excludedMember when calling serviceBoardsIdExcludedMembersPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.excludedMember),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BoardItemsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Items Count
         * @param id
         * @param conditions
         */
        public serviceBoardsIdItemsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/boards/{id}/items/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdItemsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Items
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceBoardsIdItemsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Item>> {
            const localVarPath = this.basePath + '/service/boards/{id}/items'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdItemsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Item By Id
         * @param id
         * @param itemId
         */
        public serviceBoardsIdItemsItemIdDelete (params: {  id: number; itemId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/boards/{id}/items/{itemId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'itemId' + '}', String(params.itemId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdItemsItemIdDelete');
            }
            // verify required parameter 'itemId' is set
            if (params.itemId == null) {
                throw new Error('Missing required parameter itemId when calling serviceBoardsIdItemsItemIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Item By Id
         * @param id
         * @param itemId
         */
        public serviceBoardsIdItemsItemIdGet (params: {  id: number; itemId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Item> {
            const localVarPath = this.basePath + '/service/boards/{id}/items/{itemId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'itemId' + '}', String(params.itemId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdItemsItemIdGet');
            }
            // verify required parameter 'itemId' is set
            if (params.itemId == null) {
                throw new Error('Missing required parameter itemId when calling serviceBoardsIdItemsItemIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Item
         * @param id
         * @param itemId
         * @param operations
         */
        public serviceBoardsIdItemsItemIdPatch (params: {  id: number; itemId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Item> {
            const localVarPath = this.basePath + '/service/boards/{id}/items/{itemId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'itemId' + '}', String(params.itemId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdItemsItemIdPatch');
            }
            // verify required parameter 'itemId' is set
            if (params.itemId == null) {
                throw new Error('Missing required parameter itemId when calling serviceBoardsIdItemsItemIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceBoardsIdItemsItemIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Item
         * @param id
         * @param itemId
         * @param item
         */
        public serviceBoardsIdItemsItemIdPut (params: {  id: number; itemId: number; item: Item; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Item> {
            const localVarPath = this.basePath + '/service/boards/{id}/items/{itemId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'itemId' + '}', String(params.itemId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdItemsItemIdPut');
            }
            // verify required parameter 'itemId' is set
            if (params.itemId == null) {
                throw new Error('Missing required parameter itemId when calling serviceBoardsIdItemsItemIdPut');
            }
            // verify required parameter 'item' is set
            if (params.item == null) {
                throw new Error('Missing required parameter item when calling serviceBoardsIdItemsItemIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.item),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Item
         * @param id
         * @param item
         */
        public serviceBoardsIdItemsPost (params: {  id: number; item: Item; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Item> {
            const localVarPath = this.basePath + '/service/boards/{id}/items'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdItemsPost');
            }
            // verify required parameter 'item' is set
            if (params.item == null) {
                throw new Error('Missing required parameter item when calling serviceBoardsIdItemsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.item),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BoardStatusesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Statuses Count
         * @param id
         * @param conditions
         */
        public serviceBoardsIdStatusesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/boards/{id}/statuses/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdStatusesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Statuses
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceBoardsIdStatusesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Status>> {
            const localVarPath = this.basePath + '/service/boards/{id}/statuses'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdStatusesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Statuses
         * @param id
         * @param status
         */
        public serviceBoardsIdStatusesPost (params: {  id: number; status: Status; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Status> {
            const localVarPath = this.basePath + '/service/boards/{id}/statuses'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdStatusesPost');
            }
            // verify required parameter 'status' is set
            if (params.status == null) {
                throw new Error('Missing required parameter status when calling serviceBoardsIdStatusesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.status),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Status By Id
         * @param id
         * @param statusId
         */
        public serviceBoardsIdStatusesStatusIdDelete (params: {  id: number; statusId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/boards/{id}/statuses/{statusId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'statusId' + '}', String(params.statusId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdStatusesStatusIdDelete');
            }
            // verify required parameter 'statusId' is set
            if (params.statusId == null) {
                throw new Error('Missing required parameter statusId when calling serviceBoardsIdStatusesStatusIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Status By Id
         * @param id
         * @param statusId
         */
        public serviceBoardsIdStatusesStatusIdGet (params: {  id: number; statusId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Status> {
            const localVarPath = this.basePath + '/service/boards/{id}/statuses/{statusId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'statusId' + '}', String(params.statusId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdStatusesStatusIdGet');
            }
            // verify required parameter 'statusId' is set
            if (params.statusId == null) {
                throw new Error('Missing required parameter statusId when calling serviceBoardsIdStatusesStatusIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Status
         * @param id
         * @param statusId
         * @param operations
         */
        public serviceBoardsIdStatusesStatusIdPatch (params: {  id: number; statusId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Status> {
            const localVarPath = this.basePath + '/service/boards/{id}/statuses/{statusId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'statusId' + '}', String(params.statusId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdStatusesStatusIdPatch');
            }
            // verify required parameter 'statusId' is set
            if (params.statusId == null) {
                throw new Error('Missing required parameter statusId when calling serviceBoardsIdStatusesStatusIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceBoardsIdStatusesStatusIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Statuses
         * @param id
         * @param statusId
         * @param status
         */
        public serviceBoardsIdStatusesStatusIdPut (params: {  id: number; statusId: number; status: Status; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Status> {
            const localVarPath = this.basePath + '/service/boards/{id}/statuses/{statusId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'statusId' + '}', String(params.statusId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdStatusesStatusIdPut');
            }
            // verify required parameter 'statusId' is set
            if (params.statusId == null) {
                throw new Error('Missing required parameter statusId when calling serviceBoardsIdStatusesStatusIdPut');
            }
            // verify required parameter 'status' is set
            if (params.status == null) {
                throw new Error('Missing required parameter status when calling serviceBoardsIdStatusesStatusIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.status),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BoardSubTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Subtypes Count
         * @param id
         * @param conditions
         */
        public serviceBoardsIdSubtypesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/boards/{id}/subtypes/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdSubtypesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Subtypes
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceBoardsIdSubtypesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<SubType>> {
            const localVarPath = this.basePath + '/service/boards/{id}/subtypes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdSubtypesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Subtype
         * @param id
         * @param subType
         */
        public serviceBoardsIdSubtypesPost (params: {  id: number; subType: SubType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SubType> {
            const localVarPath = this.basePath + '/service/boards/{id}/subtypes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdSubtypesPost');
            }
            // verify required parameter 'subType' is set
            if (params.subType == null) {
                throw new Error('Missing required parameter subType when calling serviceBoardsIdSubtypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.subType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Subtype By Id
         * @param id
         * @param subtypeId
         */
        public serviceBoardsIdSubtypesSubtypeIdDelete (params: {  id: number; subtypeId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/boards/{id}/subtypes/{subtypeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'subtypeId' + '}', String(params.subtypeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdSubtypesSubtypeIdDelete');
            }
            // verify required parameter 'subtypeId' is set
            if (params.subtypeId == null) {
                throw new Error('Missing required parameter subtypeId when calling serviceBoardsIdSubtypesSubtypeIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Subtype By Id
         * @param id
         * @param subtypeId
         */
        public serviceBoardsIdSubtypesSubtypeIdGet (params: {  id: number; subtypeId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SubType> {
            const localVarPath = this.basePath + '/service/boards/{id}/subtypes/{subtypeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'subtypeId' + '}', String(params.subtypeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdSubtypesSubtypeIdGet');
            }
            // verify required parameter 'subtypeId' is set
            if (params.subtypeId == null) {
                throw new Error('Missing required parameter subtypeId when calling serviceBoardsIdSubtypesSubtypeIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Subtype
         * @param id
         * @param subtypeId
         * @param operations
         */
        public serviceBoardsIdSubtypesSubtypeIdPatch (params: {  id: number; subtypeId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SubType> {
            const localVarPath = this.basePath + '/service/boards/{id}/subtypes/{subtypeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'subtypeId' + '}', String(params.subtypeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdSubtypesSubtypeIdPatch');
            }
            // verify required parameter 'subtypeId' is set
            if (params.subtypeId == null) {
                throw new Error('Missing required parameter subtypeId when calling serviceBoardsIdSubtypesSubtypeIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceBoardsIdSubtypesSubtypeIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Subtype
         * @param id
         * @param subtypeId
         * @param subType
         */
        public serviceBoardsIdSubtypesSubtypeIdPut (params: {  id: number; subtypeId: number; subType: SubType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SubType> {
            const localVarPath = this.basePath + '/service/boards/{id}/subtypes/{subtypeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'subtypeId' + '}', String(params.subtypeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdSubtypesSubtypeIdPut');
            }
            // verify required parameter 'subtypeId' is set
            if (params.subtypeId == null) {
                throw new Error('Missing required parameter subtypeId when calling serviceBoardsIdSubtypesSubtypeIdPut');
            }
            // verify required parameter 'subType' is set
            if (params.subType == null) {
                throw new Error('Missing required parameter subType when calling serviceBoardsIdSubtypesSubtypeIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.subType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BoardTeamsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Teams Count
         * @param id
         * @param conditions
         */
        public serviceBoardsIdTeamsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/boards/{id}/teams/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdTeamsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Teams
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceBoardsIdTeamsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Team>> {
            const localVarPath = this.basePath + '/service/boards/{id}/teams'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdTeamsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Team
         * @param id
         * @param team
         */
        public serviceBoardsIdTeamsPost (params: {  id: number; team: Team; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Team> {
            const localVarPath = this.basePath + '/service/boards/{id}/teams'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdTeamsPost');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling serviceBoardsIdTeamsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.team),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Team By Id
         * @param id
         * @param teamId
         */
        public serviceBoardsIdTeamsTeamIdDelete (params: {  id: number; teamId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/boards/{id}/teams/{teamId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'teamId' + '}', String(params.teamId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdTeamsTeamIdDelete');
            }
            // verify required parameter 'teamId' is set
            if (params.teamId == null) {
                throw new Error('Missing required parameter teamId when calling serviceBoardsIdTeamsTeamIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Team By Id
         * @param id
         * @param teamId
         */
        public serviceBoardsIdTeamsTeamIdGet (params: {  id: number; teamId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Team> {
            const localVarPath = this.basePath + '/service/boards/{id}/teams/{teamId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'teamId' + '}', String(params.teamId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdTeamsTeamIdGet');
            }
            // verify required parameter 'teamId' is set
            if (params.teamId == null) {
                throw new Error('Missing required parameter teamId when calling serviceBoardsIdTeamsTeamIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Team
         * @param id
         * @param teamId
         * @param operations
         */
        public serviceBoardsIdTeamsTeamIdPatch (params: {  id: number; teamId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Team> {
            const localVarPath = this.basePath + '/service/boards/{id}/teams/{teamId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'teamId' + '}', String(params.teamId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdTeamsTeamIdPatch');
            }
            // verify required parameter 'teamId' is set
            if (params.teamId == null) {
                throw new Error('Missing required parameter teamId when calling serviceBoardsIdTeamsTeamIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceBoardsIdTeamsTeamIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Team
         * @param id
         * @param teamId
         * @param team
         */
        public serviceBoardsIdTeamsTeamIdPut (params: {  id: number; teamId: number; team: Team; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Team> {
            const localVarPath = this.basePath + '/service/boards/{id}/teams/{teamId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'teamId' + '}', String(params.teamId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdTeamsTeamIdPut');
            }
            // verify required parameter 'teamId' is set
            if (params.teamId == null) {
                throw new Error('Missing required parameter teamId when calling serviceBoardsIdTeamsTeamIdPut');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling serviceBoardsIdTeamsTeamIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.team),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BoardTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Types Count
         * @param id
         * @param conditions
         */
        public serviceBoardsIdTypesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/boards/{id}/types/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdTypesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Types
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceBoardsIdTypesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Type>> {
            const localVarPath = this.basePath + '/service/boards/{id}/types'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdTypesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Type
         * @param id
         * @param type
         */
        public serviceBoardsIdTypesPost (params: {  id: number; type: Type; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Type> {
            const localVarPath = this.basePath + '/service/boards/{id}/types'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdTypesPost');
            }
            // verify required parameter 'type' is set
            if (params.type == null) {
                throw new Error('Missing required parameter type when calling serviceBoardsIdTypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.type),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Type By Id
         * @param id
         * @param typeId
         */
        public serviceBoardsIdTypesTypeIdDelete (params: {  id: number; typeId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/boards/{id}/types/{typeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'typeId' + '}', String(params.typeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdTypesTypeIdDelete');
            }
            // verify required parameter 'typeId' is set
            if (params.typeId == null) {
                throw new Error('Missing required parameter typeId when calling serviceBoardsIdTypesTypeIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Type By Id
         * @param id
         * @param typeId
         */
        public serviceBoardsIdTypesTypeIdGet (params: {  id: number; typeId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Type> {
            const localVarPath = this.basePath + '/service/boards/{id}/types/{typeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'typeId' + '}', String(params.typeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdTypesTypeIdGet');
            }
            // verify required parameter 'typeId' is set
            if (params.typeId == null) {
                throw new Error('Missing required parameter typeId when calling serviceBoardsIdTypesTypeIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Types
         * @param id
         * @param typeId
         * @param operations
         */
        public serviceBoardsIdTypesTypeIdPatch (params: {  id: number; typeId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Type> {
            const localVarPath = this.basePath + '/service/boards/{id}/types/{typeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'typeId' + '}', String(params.typeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdTypesTypeIdPatch');
            }
            // verify required parameter 'typeId' is set
            if (params.typeId == null) {
                throw new Error('Missing required parameter typeId when calling serviceBoardsIdTypesTypeIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceBoardsIdTypesTypeIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Types
         * @param id
         * @param typeId
         * @param type
         */
        public serviceBoardsIdTypesTypeIdPut (params: {  id: number; typeId: number; type: Type; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Type> {
            const localVarPath = this.basePath + '/service/boards/{id}/types/{typeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'typeId' + '}', String(params.typeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdTypesTypeIdPut');
            }
            // verify required parameter 'typeId' is set
            if (params.typeId == null) {
                throw new Error('Missing required parameter typeId when calling serviceBoardsIdTypesTypeIdPut');
            }
            // verify required parameter 'type' is set
            if (params.type == null) {
                throw new Error('Missing required parameter type when calling serviceBoardsIdTypesTypeIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.type),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Sub Type Association
         * @param id
         * @param typeId
         */
        public serviceBoardsIdTypesTypeIdSubTypeAssociationGet (params: {  id: number; typeId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<number> {
            const localVarPath = this.basePath + '/service/boards/{id}/types/{typeId}/subTypeAssociation'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'typeId' + '}', String(params.typeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdTypesTypeIdSubTypeAssociationGet');
            }
            // verify required parameter 'typeId' is set
            if (params.typeId == null) {
                throw new Error('Missing required parameter typeId when calling serviceBoardsIdTypesTypeIdSubTypeAssociationGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BoardsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Boards Count
         * @param conditions
         */
        public serviceBoardsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/boards/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Boards
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceBoardsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Board>> {
            const localVarPath = this.basePath + '/service/boards';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Board By Id
         * @param id
         */
        public serviceBoardsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/boards/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Board By Id
         * @param id
         */
        public serviceBoardsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Board> {
            const localVarPath = this.basePath + '/service/boards/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Board
         * @param id
         * @param operations
         */
        public serviceBoardsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Board> {
            const localVarPath = this.basePath + '/service/boards/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceBoardsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Board
         * @param id
         * @param board
         */
        public serviceBoardsIdPut (params: {  id: number; board: Board; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Board> {
            const localVarPath = this.basePath + '/service/boards/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdPut');
            }
            // verify required parameter 'board' is set
            if (params.board == null) {
                throw new Error('Missing required parameter board when calling serviceBoardsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.board),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Board
         * @param board
         */
        public serviceBoardsPost (params: {  board: Board; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Board> {
            const localVarPath = this.basePath + '/service/boards';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'board' is set
            if (params.board == null) {
                throw new Error('Missing required parameter board when calling serviceBoardsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.board),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CallbacksApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Callback Entries Count
         * @param conditions
         */
        public systemCallbacksCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/callbacks/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Callback Entries
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemCallbacksGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CallbackEntry>> {
            const localVarPath = this.basePath + '/system/callbacks';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Callback Entry By Id
         * @param id
         */
        public systemCallbacksIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/callbacks/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemCallbacksIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Callback Entry By Id
         * @param id
         */
        public systemCallbacksIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CallbackEntry> {
            const localVarPath = this.basePath + '/system/callbacks/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemCallbacksIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Callback Entry
         * @param id
         * @param operations
         */
        public systemCallbacksIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CallbackEntry> {
            const localVarPath = this.basePath + '/system/callbacks/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemCallbacksIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemCallbacksIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Callback Entry
         * @param id
         * @param callbackEntry
         */
        public systemCallbacksIdPut (params: {  id: number; callbackEntry: CallbackEntry; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CallbackEntry> {
            const localVarPath = this.basePath + '/system/callbacks/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemCallbacksIdPut');
            }
            // verify required parameter 'callbackEntry' is set
            if (params.callbackEntry == null) {
                throw new Error('Missing required parameter callbackEntry when calling systemCallbacksIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.callbackEntry),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Callback Entry
         * @param callbackEntry
         */
        public systemCallbacksPost (params: {  callbackEntry: CallbackEntry; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CallbackEntry> {
            const localVarPath = this.basePath + '/system/callbacks';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'callbackEntry' is set
            if (params.callbackEntry == null) {
                throw new Error('Missing required parameter callbackEntry when calling systemCallbacksPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.callbackEntry),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CampaignAuditsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Delete Campaign Audit By Id
         * @param id
         * @param auditId
         */
        public marketingCampaignsIdAuditsAuditIdDelete (params: {  id: number; auditId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/audits/{auditId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'auditId' + '}', String(params.auditId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdAuditsAuditIdDelete');
            }
            // verify required parameter 'auditId' is set
            if (params.auditId == null) {
                throw new Error('Missing required parameter auditId when calling marketingCampaignsIdAuditsAuditIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Campaign Audit By Id
         * @param id
         * @param auditId
         */
        public marketingCampaignsIdAuditsAuditIdGet (params: {  id: number; auditId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignAudit> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/audits/{auditId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'auditId' + '}', String(params.auditId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdAuditsAuditIdGet');
            }
            // verify required parameter 'auditId' is set
            if (params.auditId == null) {
                throw new Error('Missing required parameter auditId when calling marketingCampaignsIdAuditsAuditIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Campaign Audit
         * @param id
         * @param auditId
         * @param operations
         */
        public marketingCampaignsIdAuditsAuditIdPatch (params: {  id: number; auditId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignAudit> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/audits/{auditId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'auditId' + '}', String(params.auditId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdAuditsAuditIdPatch');
            }
            // verify required parameter 'auditId' is set
            if (params.auditId == null) {
                throw new Error('Missing required parameter auditId when calling marketingCampaignsIdAuditsAuditIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling marketingCampaignsIdAuditsAuditIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Campaign Audit
         * @param id
         * @param auditId
         * @param campaignAudit
         */
        public marketingCampaignsIdAuditsAuditIdPut (params: {  id: number; auditId: number; campaignAudit: CampaignAudit; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignAudit> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/audits/{auditId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'auditId' + '}', String(params.auditId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdAuditsAuditIdPut');
            }
            // verify required parameter 'auditId' is set
            if (params.auditId == null) {
                throw new Error('Missing required parameter auditId when calling marketingCampaignsIdAuditsAuditIdPut');
            }
            // verify required parameter 'campaignAudit' is set
            if (params.campaignAudit == null) {
                throw new Error('Missing required parameter campaignAudit when calling marketingCampaignsIdAuditsAuditIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.campaignAudit),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Campaign Audits Count
         * @param id
         * @param conditions
         */
        public marketingCampaignsIdAuditsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/audits/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdAuditsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Campaign Audits
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public marketingCampaignsIdAuditsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CampaignAudit>> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/audits'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdAuditsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Campaign Audit
         * @param id
         * @param campaignAudit
         */
        public marketingCampaignsIdAuditsPost (params: {  id: number; campaignAudit: CampaignAudit; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignAudit> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/audits'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdAuditsPost');
            }
            // verify required parameter 'campaignAudit' is set
            if (params.campaignAudit == null) {
                throw new Error('Missing required parameter campaignAudit when calling marketingCampaignsIdAuditsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.campaignAudit),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CampaignEmailsOpenedApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Emails Opened Count
         * @param id
         * @param conditions
         */
        public marketingCampaignsIdEmailsOpenedCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/emailsOpened/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdEmailsOpenedCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Email Opened By Id
         * @param id
         * @param emailOpenedId
         */
        public marketingCampaignsIdEmailsOpenedEmailOpenedIdDelete (params: {  id: number; emailOpenedId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/emailsOpened/{emailOpenedId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'emailOpenedId' + '}', String(params.emailOpenedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdEmailsOpenedEmailOpenedIdDelete');
            }
            // verify required parameter 'emailOpenedId' is set
            if (params.emailOpenedId == null) {
                throw new Error('Missing required parameter emailOpenedId when calling marketingCampaignsIdEmailsOpenedEmailOpenedIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Email Opened By Id
         * @param id
         * @param emailOpenedId
         */
        public marketingCampaignsIdEmailsOpenedEmailOpenedIdGet (params: {  id: number; emailOpenedId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<EmailOpened> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/emailsOpened/{emailOpenedId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'emailOpenedId' + '}', String(params.emailOpenedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdEmailsOpenedEmailOpenedIdGet');
            }
            // verify required parameter 'emailOpenedId' is set
            if (params.emailOpenedId == null) {
                throw new Error('Missing required parameter emailOpenedId when calling marketingCampaignsIdEmailsOpenedEmailOpenedIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Email Opened
         * @param id
         * @param emailOpenedId
         * @param operations
         */
        public marketingCampaignsIdEmailsOpenedEmailOpenedIdPatch (params: {  id: number; emailOpenedId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<EmailOpened> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/emailsOpened/{emailOpenedId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'emailOpenedId' + '}', String(params.emailOpenedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdEmailsOpenedEmailOpenedIdPatch');
            }
            // verify required parameter 'emailOpenedId' is set
            if (params.emailOpenedId == null) {
                throw new Error('Missing required parameter emailOpenedId when calling marketingCampaignsIdEmailsOpenedEmailOpenedIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling marketingCampaignsIdEmailsOpenedEmailOpenedIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Email Opened
         * @param id
         * @param emailOpenedId
         * @param emailOpened
         */
        public marketingCampaignsIdEmailsOpenedEmailOpenedIdPut (params: {  id: number; emailOpenedId: number; emailOpened: EmailOpened; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<EmailOpened> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/emailsOpened/{emailOpenedId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'emailOpenedId' + '}', String(params.emailOpenedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdEmailsOpenedEmailOpenedIdPut');
            }
            // verify required parameter 'emailOpenedId' is set
            if (params.emailOpenedId == null) {
                throw new Error('Missing required parameter emailOpenedId when calling marketingCampaignsIdEmailsOpenedEmailOpenedIdPut');
            }
            // verify required parameter 'emailOpened' is set
            if (params.emailOpened == null) {
                throw new Error('Missing required parameter emailOpened when calling marketingCampaignsIdEmailsOpenedEmailOpenedIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.emailOpened),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Emails Opened
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public marketingCampaignsIdEmailsOpenedGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<EmailOpened>> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/emailsOpened'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdEmailsOpenedGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Email Opened
         * @param id
         * @param emailOpened
         */
        public marketingCampaignsIdEmailsOpenedPost (params: {  id: number; emailOpened: EmailOpened; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<EmailOpened> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/emailsOpened'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdEmailsOpenedPost');
            }
            // verify required parameter 'emailOpened' is set
            if (params.emailOpened == null) {
                throw new Error('Missing required parameter emailOpened when calling marketingCampaignsIdEmailsOpenedPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.emailOpened),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CampaignFormsSubmittedApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Forms Submitted Count
         * @param id
         * @param conditions
         */
        public marketingCampaignsIdFormsSubmittedCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/formsSubmitted/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdFormsSubmittedCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Form Submitted By Id
         * @param id
         * @param formSubmittedId
         */
        public marketingCampaignsIdFormsSubmittedFormSubmittedIdDelete (params: {  id: number; formSubmittedId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/formsSubmitted/{formSubmittedId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'formSubmittedId' + '}', String(params.formSubmittedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdFormsSubmittedFormSubmittedIdDelete');
            }
            // verify required parameter 'formSubmittedId' is set
            if (params.formSubmittedId == null) {
                throw new Error('Missing required parameter formSubmittedId when calling marketingCampaignsIdFormsSubmittedFormSubmittedIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Form Submitted By Id
         * @param id
         * @param formSubmittedId
         */
        public marketingCampaignsIdFormsSubmittedFormSubmittedIdGet (params: {  id: number; formSubmittedId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<FormSubmitted> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/formsSubmitted/{formSubmittedId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'formSubmittedId' + '}', String(params.formSubmittedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdFormsSubmittedFormSubmittedIdGet');
            }
            // verify required parameter 'formSubmittedId' is set
            if (params.formSubmittedId == null) {
                throw new Error('Missing required parameter formSubmittedId when calling marketingCampaignsIdFormsSubmittedFormSubmittedIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Form Submitted
         * @param id
         * @param formSubmittedId
         * @param operations
         */
        public marketingCampaignsIdFormsSubmittedFormSubmittedIdPatch (params: {  id: number; formSubmittedId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<FormSubmitted> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/formsSubmitted/{formSubmittedId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'formSubmittedId' + '}', String(params.formSubmittedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdFormsSubmittedFormSubmittedIdPatch');
            }
            // verify required parameter 'formSubmittedId' is set
            if (params.formSubmittedId == null) {
                throw new Error('Missing required parameter formSubmittedId when calling marketingCampaignsIdFormsSubmittedFormSubmittedIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling marketingCampaignsIdFormsSubmittedFormSubmittedIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Form Submitted
         * @param id
         * @param formSubmittedId
         * @param formSubmitted
         */
        public marketingCampaignsIdFormsSubmittedFormSubmittedIdPut (params: {  id: number; formSubmittedId: number; formSubmitted: FormSubmitted; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<FormSubmitted> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/formsSubmitted/{formSubmittedId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'formSubmittedId' + '}', String(params.formSubmittedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdFormsSubmittedFormSubmittedIdPut');
            }
            // verify required parameter 'formSubmittedId' is set
            if (params.formSubmittedId == null) {
                throw new Error('Missing required parameter formSubmittedId when calling marketingCampaignsIdFormsSubmittedFormSubmittedIdPut');
            }
            // verify required parameter 'formSubmitted' is set
            if (params.formSubmitted == null) {
                throw new Error('Missing required parameter formSubmitted when calling marketingCampaignsIdFormsSubmittedFormSubmittedIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.formSubmitted),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Forms Submitted
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public marketingCampaignsIdFormsSubmittedGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<FormSubmitted>> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/formsSubmitted'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdFormsSubmittedGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Form Submitted
         * @param id
         * @param formSubmitted
         */
        public marketingCampaignsIdFormsSubmittedPost (params: {  id: number; formSubmitted: FormSubmitted; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<FormSubmitted> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/formsSubmitted'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdFormsSubmittedPost');
            }
            // verify required parameter 'formSubmitted' is set
            if (params.formSubmitted == null) {
                throw new Error('Missing required parameter formSubmitted when calling marketingCampaignsIdFormsSubmittedPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.formSubmitted),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CampaignLinksClickedApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Links Clicked Count
         * @param id
         * @param conditions
         */
        public marketingCampaignsIdLinksClickedCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/linksClicked/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdLinksClickedCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Links Clicked
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public marketingCampaignsIdLinksClickedGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<LinkClicked>> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/linksClicked'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdLinksClickedGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Link Clicked By Id
         * @param id
         * @param linkClickedId
         */
        public marketingCampaignsIdLinksClickedLinkClickedIdDelete (params: {  id: number; linkClickedId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/linksClicked/{linkClickedId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'linkClickedId' + '}', String(params.linkClickedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdLinksClickedLinkClickedIdDelete');
            }
            // verify required parameter 'linkClickedId' is set
            if (params.linkClickedId == null) {
                throw new Error('Missing required parameter linkClickedId when calling marketingCampaignsIdLinksClickedLinkClickedIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Link Clicked By Id
         * @param id
         * @param linkClickedId
         */
        public marketingCampaignsIdLinksClickedLinkClickedIdGet (params: {  id: number; linkClickedId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<LinkClicked> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/linksClicked/{linkClickedId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'linkClickedId' + '}', String(params.linkClickedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdLinksClickedLinkClickedIdGet');
            }
            // verify required parameter 'linkClickedId' is set
            if (params.linkClickedId == null) {
                throw new Error('Missing required parameter linkClickedId when calling marketingCampaignsIdLinksClickedLinkClickedIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Link Clicked
         * @param id
         * @param linkClickedId
         * @param operations
         */
        public marketingCampaignsIdLinksClickedLinkClickedIdPatch (params: {  id: number; linkClickedId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<LinkClicked> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/linksClicked/{linkClickedId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'linkClickedId' + '}', String(params.linkClickedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdLinksClickedLinkClickedIdPatch');
            }
            // verify required parameter 'linkClickedId' is set
            if (params.linkClickedId == null) {
                throw new Error('Missing required parameter linkClickedId when calling marketingCampaignsIdLinksClickedLinkClickedIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling marketingCampaignsIdLinksClickedLinkClickedIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Link Clicked
         * @param id
         * @param linkClickedId
         * @param linkClicked
         */
        public marketingCampaignsIdLinksClickedLinkClickedIdPut (params: {  id: number; linkClickedId: number; linkClicked: LinkClicked; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<LinkClicked> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/linksClicked/{linkClickedId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'linkClickedId' + '}', String(params.linkClickedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdLinksClickedLinkClickedIdPut');
            }
            // verify required parameter 'linkClickedId' is set
            if (params.linkClickedId == null) {
                throw new Error('Missing required parameter linkClickedId when calling marketingCampaignsIdLinksClickedLinkClickedIdPut');
            }
            // verify required parameter 'linkClicked' is set
            if (params.linkClicked == null) {
                throw new Error('Missing required parameter linkClicked when calling marketingCampaignsIdLinksClickedLinkClickedIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.linkClicked),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Link Clicked
         * @param id
         * @param linkClicked
         */
        public marketingCampaignsIdLinksClickedPost (params: {  id: number; linkClicked: LinkClicked; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<LinkClicked> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/linksClicked'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdLinksClickedPost');
            }
            // verify required parameter 'linkClicked' is set
            if (params.linkClicked == null) {
                throw new Error('Missing required parameter linkClicked when calling marketingCampaignsIdLinksClickedPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.linkClicked),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CampaignStatusesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Campaign Statuses Count
         * @param conditions
         */
        public marketingCampaignsStatusesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/marketing/campaigns/statuses/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Campaign Statuses
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public marketingCampaignsStatusesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CampaignStatus>> {
            const localVarPath = this.basePath + '/marketing/campaigns/statuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Campaign Status By Id
         * @param id
         */
        public marketingCampaignsStatusesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/marketing/campaigns/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsStatusesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Campaign Status By Id
         * @param id
         */
        public marketingCampaignsStatusesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignStatus> {
            const localVarPath = this.basePath + '/marketing/campaigns/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsStatusesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Campaign Status
         * @param id
         * @param operations
         */
        public marketingCampaignsStatusesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignStatus> {
            const localVarPath = this.basePath + '/marketing/campaigns/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsStatusesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling marketingCampaignsStatusesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Campaign Status
         * @param id
         * @param campaignStatus
         */
        public marketingCampaignsStatusesIdPut (params: {  id: number; campaignStatus: CampaignStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignStatus> {
            const localVarPath = this.basePath + '/marketing/campaigns/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsStatusesIdPut');
            }
            // verify required parameter 'campaignStatus' is set
            if (params.campaignStatus == null) {
                throw new Error('Missing required parameter campaignStatus when calling marketingCampaignsStatusesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.campaignStatus),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Campaign Status
         * @param campaignStatus
         */
        public marketingCampaignsStatusesPost (params: {  campaignStatus: CampaignStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignStatus> {
            const localVarPath = this.basePath + '/marketing/campaigns/statuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'campaignStatus' is set
            if (params.campaignStatus == null) {
                throw new Error('Missing required parameter campaignStatus when calling marketingCampaignsStatusesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.campaignStatus),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CampaignSubTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Campaign Sub Types Count
         * @param id
         * @param conditions
         */
        public marketingCampaignsTypesIdSubTypesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/marketing/campaigns/types/{id}/subTypes/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsTypesIdSubTypesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Campaign Sub Types
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public marketingCampaignsTypesIdSubTypesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CampaignSubType>> {
            const localVarPath = this.basePath + '/marketing/campaigns/types/{id}/subTypes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsTypesIdSubTypesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Campaign Sub Type
         * @param id
         * @param campaignSubType
         */
        public marketingCampaignsTypesIdSubTypesPost (params: {  id: number; campaignSubType: CampaignSubType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignSubType> {
            const localVarPath = this.basePath + '/marketing/campaigns/types/{id}/subTypes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsTypesIdSubTypesPost');
            }
            // verify required parameter 'campaignSubType' is set
            if (params.campaignSubType == null) {
                throw new Error('Missing required parameter campaignSubType when calling marketingCampaignsTypesIdSubTypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.campaignSubType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Campaign Sub Type By Id
         * @param id
         * @param subTypeId
         */
        public marketingCampaignsTypesIdSubTypesSubTypeIdDelete (params: {  id: number; subTypeId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/marketing/campaigns/types/{id}/subTypes/{subTypeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'subTypeId' + '}', String(params.subTypeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsTypesIdSubTypesSubTypeIdDelete');
            }
            // verify required parameter 'subTypeId' is set
            if (params.subTypeId == null) {
                throw new Error('Missing required parameter subTypeId when calling marketingCampaignsTypesIdSubTypesSubTypeIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Campaign Sub Type By Id
         * @param id
         * @param subTypeId
         */
        public marketingCampaignsTypesIdSubTypesSubTypeIdGet (params: {  id: number; subTypeId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignSubType> {
            const localVarPath = this.basePath + '/marketing/campaigns/types/{id}/subTypes/{subTypeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'subTypeId' + '}', String(params.subTypeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsTypesIdSubTypesSubTypeIdGet');
            }
            // verify required parameter 'subTypeId' is set
            if (params.subTypeId == null) {
                throw new Error('Missing required parameter subTypeId when calling marketingCampaignsTypesIdSubTypesSubTypeIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Campaign Sub Type
         * @param id
         * @param subTypeId
         * @param operations
         */
        public marketingCampaignsTypesIdSubTypesSubTypeIdPatch (params: {  id: number; subTypeId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignSubType> {
            const localVarPath = this.basePath + '/marketing/campaigns/types/{id}/subTypes/{subTypeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'subTypeId' + '}', String(params.subTypeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsTypesIdSubTypesSubTypeIdPatch');
            }
            // verify required parameter 'subTypeId' is set
            if (params.subTypeId == null) {
                throw new Error('Missing required parameter subTypeId when calling marketingCampaignsTypesIdSubTypesSubTypeIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling marketingCampaignsTypesIdSubTypesSubTypeIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Campaign Sub Type
         * @param id
         * @param subTypeId
         * @param campaignSubType
         */
        public marketingCampaignsTypesIdSubTypesSubTypeIdPut (params: {  id: number; subTypeId: number; campaignSubType: CampaignSubType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignSubType> {
            const localVarPath = this.basePath + '/marketing/campaigns/types/{id}/subTypes/{subTypeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'subTypeId' + '}', String(params.subTypeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsTypesIdSubTypesSubTypeIdPut');
            }
            // verify required parameter 'subTypeId' is set
            if (params.subTypeId == null) {
                throw new Error('Missing required parameter subTypeId when calling marketingCampaignsTypesIdSubTypesSubTypeIdPut');
            }
            // verify required parameter 'campaignSubType' is set
            if (params.campaignSubType == null) {
                throw new Error('Missing required parameter campaignSubType when calling marketingCampaignsTypesIdSubTypesSubTypeIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.campaignSubType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CampaignTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Campaign Types Count
         * @param conditions
         */
        public marketingCampaignsTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/marketing/campaigns/types/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Campaign Types
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public marketingCampaignsTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CampaignType>> {
            const localVarPath = this.basePath + '/marketing/campaigns/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Campaign Type By Id
         * @param id
         */
        public marketingCampaignsTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/marketing/campaigns/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsTypesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Campaign Type By Id
         * @param id
         */
        public marketingCampaignsTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignType> {
            const localVarPath = this.basePath + '/marketing/campaigns/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsTypesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Campaign Type
         * @param id
         * @param operations
         */
        public marketingCampaignsTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignType> {
            const localVarPath = this.basePath + '/marketing/campaigns/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsTypesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling marketingCampaignsTypesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Campaign Type
         * @param id
         * @param campaignType
         */
        public marketingCampaignsTypesIdPut (params: {  id: number; campaignType: CampaignType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignType> {
            const localVarPath = this.basePath + '/marketing/campaigns/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsTypesIdPut');
            }
            // verify required parameter 'campaignType' is set
            if (params.campaignType == null) {
                throw new Error('Missing required parameter campaignType when calling marketingCampaignsTypesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.campaignType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Campaign Type
         * @param campaignType
         */
        public marketingCampaignsTypesPost (params: {  campaignType: CampaignType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignType> {
            const localVarPath = this.basePath + '/marketing/campaigns/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'campaignType' is set
            if (params.campaignType == null) {
                throw new Error('Missing required parameter campaignType when calling marketingCampaignsTypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.campaignType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CampaignsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Campaigns Count
         * @param conditions
         */
        public marketingCampaignsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/marketing/campaigns/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Campaigns
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public marketingCampaignsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Campaign>> {
            const localVarPath = this.basePath + '/marketing/campaigns';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Campaign Activities Count
         * @param id
         */
        public marketingCampaignsIdActivitiesCountGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/activities/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdActivitiesCountGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Campaign Activities
         * @param id
         * @param page
         * @param pageSize
         */
        public marketingCampaignsIdActivitiesGet (params: {  id: number; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ActivityReference>> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/activities'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdActivitiesGet');
            }
            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Campaign By Id
         * @param id
         */
        public marketingCampaignsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Campaign By Id
         * @param id
         */
        public marketingCampaignsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Campaign> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Campaign Opportunities Count
         * @param id
         */
        public marketingCampaignsIdOpportunitiesCountGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/opportunities/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdOpportunitiesCountGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Campaign Opportunities
         * @param id
         * @param page
         * @param pageSize
         */
        public marketingCampaignsIdOpportunitiesGet (params: {  id: number; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<OpportunityReference>> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/opportunities'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdOpportunitiesGet');
            }
            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Campaign
         * @param id
         * @param operations
         */
        public marketingCampaignsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Campaign> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling marketingCampaignsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Campaign
         * @param id
         * @param campaign
         */
        public marketingCampaignsIdPut (params: {  id: number; campaign: Campaign; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Campaign> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdPut');
            }
            // verify required parameter 'campaign' is set
            if (params.campaign == null) {
                throw new Error('Missing required parameter campaign when calling marketingCampaignsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.campaign),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Campaign
         * @param campaign
         */
        public marketingCampaignsPost (params: {  campaign: Campaign; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Campaign> {
            const localVarPath = this.basePath + '/marketing/campaigns';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'campaign' is set
            if (params.campaign == null) {
                throw new Error('Missing required parameter campaign when calling marketingCampaignsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.campaign),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CatalogComponentsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Delete Catalog Component By Id
         * @param id
         * @param componentId
         */
        public procurementCatalogIdComponentsComponentIdDelete (params: {  id: number; componentId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/catalog/{id}/components/{componentId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'componentId' + '}', String(params.componentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCatalogIdComponentsComponentIdDelete');
            }
            // verify required parameter 'componentId' is set
            if (params.componentId == null) {
                throw new Error('Missing required parameter componentId when calling procurementCatalogIdComponentsComponentIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Catalog Component By Id
         * @param id
         * @param componentId
         */
        public procurementCatalogIdComponentsComponentIdGet (params: {  id: number; componentId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CatalogComponent> {
            const localVarPath = this.basePath + '/procurement/catalog/{id}/components/{componentId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'componentId' + '}', String(params.componentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCatalogIdComponentsComponentIdGet');
            }
            // verify required parameter 'componentId' is set
            if (params.componentId == null) {
                throw new Error('Missing required parameter componentId when calling procurementCatalogIdComponentsComponentIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Catalog Component
         * @param id
         * @param componentId
         * @param operations
         */
        public procurementCatalogIdComponentsComponentIdPatch (params: {  id: number; componentId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CatalogComponent> {
            const localVarPath = this.basePath + '/procurement/catalog/{id}/components/{componentId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'componentId' + '}', String(params.componentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCatalogIdComponentsComponentIdPatch');
            }
            // verify required parameter 'componentId' is set
            if (params.componentId == null) {
                throw new Error('Missing required parameter componentId when calling procurementCatalogIdComponentsComponentIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementCatalogIdComponentsComponentIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Catalog Component
         * @param id
         * @param componentId
         * @param catalogComponent
         */
        public procurementCatalogIdComponentsComponentIdPut (params: {  id: number; componentId: number; catalogComponent: CatalogComponent; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CatalogComponent> {
            const localVarPath = this.basePath + '/procurement/catalog/{id}/components/{componentId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'componentId' + '}', String(params.componentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCatalogIdComponentsComponentIdPut');
            }
            // verify required parameter 'componentId' is set
            if (params.componentId == null) {
                throw new Error('Missing required parameter componentId when calling procurementCatalogIdComponentsComponentIdPut');
            }
            // verify required parameter 'catalogComponent' is set
            if (params.catalogComponent == null) {
                throw new Error('Missing required parameter catalogComponent when calling procurementCatalogIdComponentsComponentIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.catalogComponent),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Catalog Components Count
         * @param id
         * @param conditions
         */
        public procurementCatalogIdComponentsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/catalog/{id}/components/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCatalogIdComponentsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Catalog Components
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementCatalogIdComponentsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CatalogComponent>> {
            const localVarPath = this.basePath + '/procurement/catalog/{id}/components'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCatalogIdComponentsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Catalog Component
         * @param id
         * @param catalogComponent
         */
        public procurementCatalogIdComponentsPost (params: {  id: number; catalogComponent: CatalogComponent; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CatalogComponent> {
            const localVarPath = this.basePath + '/procurement/catalog/{id}/components'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCatalogIdComponentsPost');
            }
            // verify required parameter 'catalogComponent' is set
            if (params.catalogComponent == null) {
                throw new Error('Missing required parameter catalogComponent when calling procurementCatalogIdComponentsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.catalogComponent),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CatalogsItemApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Inventory Quantity On Hand
         * @param catalogItemIdentifier
         * @param warehouseBinId
         */
        public procurementCatalogCatalogItemIdentifierQuantityOnHandGet (params: {  catalogItemIdentifier: string; warehouseBinId?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/catalog/{catalogItemIdentifier}/quantityOnHand'
                .replace('{' + 'catalogItemIdentifier' + '}', String(params.catalogItemIdentifier));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'catalogItemIdentifier' is set
            if (params.catalogItemIdentifier == null) {
                throw new Error('Missing required parameter catalogItemIdentifier when calling procurementCatalogCatalogItemIdentifierQuantityOnHandGet');
            }
            if (params.warehouseBinId !== undefined) {
                queryParameters['warehouseBinId'] = params.warehouseBinId;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Catalogs Count
         * @param conditions
         */
        public procurementCatalogCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/catalog/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Catalogs
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementCatalogGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CatalogItem>> {
            const localVarPath = this.basePath + '/procurement/catalog';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Catalog By Id
         * @param id
         */
        public procurementCatalogIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/catalog/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCatalogIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Catalog By Id
         * @param id
         */
        public procurementCatalogIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CatalogItem> {
            const localVarPath = this.basePath + '/procurement/catalog/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCatalogIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Catalog
         * @param id
         * @param operations
         */
        public procurementCatalogIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CatalogItem> {
            const localVarPath = this.basePath + '/procurement/catalog/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCatalogIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementCatalogIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Catalog
         * @param id
         * @param catalogItem
         */
        public procurementCatalogIdPut (params: {  id: number; catalogItem: CatalogItem; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CatalogItem> {
            const localVarPath = this.basePath + '/procurement/catalog/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCatalogIdPut');
            }
            // verify required parameter 'catalogItem' is set
            if (params.catalogItem == null) {
                throw new Error('Missing required parameter catalogItem when calling procurementCatalogIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.catalogItem),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Catalog
         * @param catalogItem
         */
        public procurementCatalogPost (params: {  catalogItem: CatalogItem; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CatalogItem> {
            const localVarPath = this.basePath + '/procurement/catalog';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'catalogItem' is set
            if (params.catalogItem == null) {
                throw new Error('Missing required parameter catalogItem when calling procurementCatalogPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.catalogItem),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CategoriesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Categories Count
         * @param conditions
         */
        public procurementCategoriesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/categories/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Categories
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementCategoriesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Category>> {
            const localVarPath = this.basePath + '/procurement/categories';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Category By Id
         * @param id
         */
        public procurementCategoriesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/categories/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCategoriesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Category By Id
         * @param id
         */
        public procurementCategoriesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Category> {
            const localVarPath = this.basePath + '/procurement/categories/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCategoriesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Category
         * @param id
         * @param operations
         */
        public procurementCategoriesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Category> {
            const localVarPath = this.basePath + '/procurement/categories/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCategoriesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementCategoriesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Category
         * @param id
         * @param category
         */
        public procurementCategoriesIdPut (params: {  id: number; category: Category; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Category> {
            const localVarPath = this.basePath + '/procurement/categories/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCategoriesIdPut');
            }
            // verify required parameter 'category' is set
            if (params.category == null) {
                throw new Error('Missing required parameter category when calling procurementCategoriesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.category),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Category
         * @param category
         */
        public procurementCategoriesPost (params: {  category: Category; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Category> {
            const localVarPath = this.basePath + '/procurement/categories';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'category' is set
            if (params.category == null) {
                throw new Error('Missing required parameter category when calling procurementCategoriesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.category),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CodesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Create Codes Count
         * @param conditions
         */
        public serviceCodesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/codes/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Codes
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceCodesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Code>> {
            const localVarPath = this.basePath + '/service/codes';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Code By Id
         * @param id
         */
        public serviceCodesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/codes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceCodesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Code By Id
         * @param id
         */
        public serviceCodesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Code> {
            const localVarPath = this.basePath + '/service/codes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceCodesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Code
         * @param id
         * @param operations
         */
        public serviceCodesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Code> {
            const localVarPath = this.basePath + '/service/codes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceCodesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceCodesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Code
         * @param id
         * @param code
         */
        public serviceCodesIdPut (params: {  id: number; code: Code; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Code> {
            const localVarPath = this.basePath + '/service/codes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceCodesIdPut');
            }
            // verify required parameter 'code' is set
            if (params.code == null) {
                throw new Error('Missing required parameter code when calling serviceCodesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.code),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Codes
         * @param code
         */
        public serviceCodesPost (params: {  code: Code; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Code> {
            const localVarPath = this.basePath + '/service/codes';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'code' is set
            if (params.code == null) {
                throw new Error('Missing required parameter code when calling serviceCodesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.code),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CompaniesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Companies Count
         * @param conditions
         * @param customFieldConditions
         */
        public companyCompaniesCountGet (params: {  conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/companies/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.customFieldConditions !== undefined) {
                queryParameters['customFieldConditions'] = params.customFieldConditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Companies
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyCompaniesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Company>> {
            const localVarPath = this.basePath + '/company/companies';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Company By Id
         * @param id
         */
        public companyCompaniesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/companies/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Company By Id
         * @param id
         */
        public companyCompaniesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Company> {
            const localVarPath = this.basePath + '/company/companies/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Merge Company
         * @param id
         * @param merge
         */
        public companyCompaniesIdMergePost (params: {  id: number; merge: CompanyMerge; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SuccessResponse> {
            const localVarPath = this.basePath + '/company/companies/{id}/merge'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdMergePost');
            }
            // verify required parameter 'merge' is set
            if (params.merge == null) {
                throw new Error('Missing required parameter merge when calling companyCompaniesIdMergePost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.merge),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Company
         * @param id
         * @param operations
         */
        public companyCompaniesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Company> {
            const localVarPath = this.basePath + '/company/companies/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyCompaniesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Company
         * @param id
         * @param company
         */
        public companyCompaniesIdPut (params: {  id: number; company: Company; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Company> {
            const localVarPath = this.basePath + '/company/companies/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdPut');
            }
            // verify required parameter 'company' is set
            if (params.company == null) {
                throw new Error('Missing required parameter company when calling companyCompaniesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.company),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Company
         * @param company
         */
        public companyCompaniesPost (params: {  company: Company; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Company> {
            const localVarPath = this.basePath + '/company/companies';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'company' is set
            if (params.company == null) {
                throw new Error('Missing required parameter company when calling companyCompaniesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.company),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CompanyCustomNotesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Custom Note Count
         * @param id
         * @param conditions
         */
        public companyCompaniesIdCustomStatusNotesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/companies/{id}/customStatusNotes/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdCustomStatusNotesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Custom Note By Id
         * @param id
         * @param customNoteId
         */
        public companyCompaniesIdCustomStatusNotesCustomNoteIdDelete (params: {  id: number; customNoteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/companies/{id}/customStatusNotes/{customNoteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'customNoteId' + '}', String(params.customNoteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdCustomStatusNotesCustomNoteIdDelete');
            }
            // verify required parameter 'customNoteId' is set
            if (params.customNoteId == null) {
                throw new Error('Missing required parameter customNoteId when calling companyCompaniesIdCustomStatusNotesCustomNoteIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Custom Note By Id
         * @param id
         * @param customNoteId
         */
        public companyCompaniesIdCustomStatusNotesCustomNoteIdGet (params: {  id: number; customNoteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyCustomNote> {
            const localVarPath = this.basePath + '/company/companies/{id}/customStatusNotes/{customNoteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'customNoteId' + '}', String(params.customNoteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdCustomStatusNotesCustomNoteIdGet');
            }
            // verify required parameter 'customNoteId' is set
            if (params.customNoteId == null) {
                throw new Error('Missing required parameter customNoteId when calling companyCompaniesIdCustomStatusNotesCustomNoteIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Custom Note
         * @param id
         * @param customNoteId
         * @param operations
         */
        public companyCompaniesIdCustomStatusNotesCustomNoteIdPatch (params: {  id: number; customNoteId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyCustomNote> {
            const localVarPath = this.basePath + '/company/companies/{id}/customStatusNotes/{customNoteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'customNoteId' + '}', String(params.customNoteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdCustomStatusNotesCustomNoteIdPatch');
            }
            // verify required parameter 'customNoteId' is set
            if (params.customNoteId == null) {
                throw new Error('Missing required parameter customNoteId when calling companyCompaniesIdCustomStatusNotesCustomNoteIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyCompaniesIdCustomStatusNotesCustomNoteIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Custom Note
         * @param id
         * @param customNoteId
         * @param customNote
         */
        public companyCompaniesIdCustomStatusNotesCustomNoteIdPut (params: {  id: number; customNoteId: number; customNote: CompanyCustomNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyCustomNote> {
            const localVarPath = this.basePath + '/company/companies/{id}/customStatusNotes/{customNoteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'customNoteId' + '}', String(params.customNoteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdCustomStatusNotesCustomNoteIdPut');
            }
            // verify required parameter 'customNoteId' is set
            if (params.customNoteId == null) {
                throw new Error('Missing required parameter customNoteId when calling companyCompaniesIdCustomStatusNotesCustomNoteIdPut');
            }
            // verify required parameter 'customNote' is set
            if (params.customNote == null) {
                throw new Error('Missing required parameter customNote when calling companyCompaniesIdCustomStatusNotesCustomNoteIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.customNote),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Custom Note
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyCompaniesIdCustomStatusNotesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CompanyCustomNote>> {
            const localVarPath = this.basePath + '/company/companies/{id}/customStatusNotes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdCustomStatusNotesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Custom Note
         * @param id
         * @param customNote
         */
        public companyCompaniesIdCustomStatusNotesPost (params: {  id: number; customNote: CompanyCustomNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyCustomNote> {
            const localVarPath = this.basePath + '/company/companies/{id}/customStatusNotes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdCustomStatusNotesPost');
            }
            // verify required parameter 'customNote' is set
            if (params.customNote == null) {
                throw new Error('Missing required parameter customNote when calling companyCompaniesIdCustomStatusNotesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.customNote),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CompanyManagementSummaryReportsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Company Types Count
         * @param id
         * @param conditions
         */
        public companyCompaniesIdManagementSummaryReportsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/companies/{id}/managementSummaryReports/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdManagementSummaryReportsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Management Summarys
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyCompaniesIdManagementSummaryReportsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CompanyManagementSummary>> {
            const localVarPath = this.basePath + '/company/companies/{id}/managementSummaryReports'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdManagementSummaryReportsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Management Summary
         * @param id
         * @param managementSummary
         */
        public companyCompaniesIdManagementSummaryReportsPost (params: {  id: number; managementSummary: CompanyManagementSummary; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyManagementSummary> {
            const localVarPath = this.basePath + '/company/companies/{id}/managementSummaryReports'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdManagementSummaryReportsPost');
            }
            // verify required parameter 'managementSummary' is set
            if (params.managementSummary == null) {
                throw new Error('Missing required parameter managementSummary when calling companyCompaniesIdManagementSummaryReportsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.managementSummary),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Management Summary By Id
         * @param id
         * @param reportId
         */
        public companyCompaniesIdManagementSummaryReportsReportIdDelete (params: {  id: number; reportId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/companies/{id}/managementSummaryReports/{reportId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'reportId' + '}', String(params.reportId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdManagementSummaryReportsReportIdDelete');
            }
            // verify required parameter 'reportId' is set
            if (params.reportId == null) {
                throw new Error('Missing required parameter reportId when calling companyCompaniesIdManagementSummaryReportsReportIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Management Summary By Id
         * @param id
         * @param reportId
         */
        public companyCompaniesIdManagementSummaryReportsReportIdGet (params: {  id: number; reportId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyManagementSummary> {
            const localVarPath = this.basePath + '/company/companies/{id}/managementSummaryReports/{reportId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'reportId' + '}', String(params.reportId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdManagementSummaryReportsReportIdGet');
            }
            // verify required parameter 'reportId' is set
            if (params.reportId == null) {
                throw new Error('Missing required parameter reportId when calling companyCompaniesIdManagementSummaryReportsReportIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Management Summary
         * @param id
         * @param reportId
         * @param operations
         */
        public companyCompaniesIdManagementSummaryReportsReportIdPatch (params: {  id: number; reportId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyManagementSummary> {
            const localVarPath = this.basePath + '/company/companies/{id}/managementSummaryReports/{reportId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'reportId' + '}', String(params.reportId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdManagementSummaryReportsReportIdPatch');
            }
            // verify required parameter 'reportId' is set
            if (params.reportId == null) {
                throw new Error('Missing required parameter reportId when calling companyCompaniesIdManagementSummaryReportsReportIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyCompaniesIdManagementSummaryReportsReportIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Management Summary
         * @param id
         * @param reportId
         * @param managementSummary
         */
        public companyCompaniesIdManagementSummaryReportsReportIdPut (params: {  id: number; reportId: number; managementSummary: CompanyManagementSummary; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyManagementSummary> {
            const localVarPath = this.basePath + '/company/companies/{id}/managementSummaryReports/{reportId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'reportId' + '}', String(params.reportId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdManagementSummaryReportsReportIdPut');
            }
            // verify required parameter 'reportId' is set
            if (params.reportId == null) {
                throw new Error('Missing required parameter reportId when calling companyCompaniesIdManagementSummaryReportsReportIdPut');
            }
            // verify required parameter 'managementSummary' is set
            if (params.managementSummary == null) {
                throw new Error('Missing required parameter managementSummary when calling companyCompaniesIdManagementSummaryReportsReportIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.managementSummary),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CompanyNotesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Company Notes Count
         * @param id
         * @param conditions
         */
        public companyCompaniesIdNotesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/companies/{id}/notes/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdNotesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Company Notes
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyCompaniesIdNotesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CompanyNote>> {
            const localVarPath = this.basePath + '/company/companies/{id}/notes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdNotesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Company Note By Id
         * @param id
         * @param noteId
         */
        public companyCompaniesIdNotesNoteIdDelete (params: {  id: number; noteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/companies/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdNotesNoteIdDelete');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling companyCompaniesIdNotesNoteIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Company Note By Id
         * @param id
         * @param noteId
         */
        public companyCompaniesIdNotesNoteIdGet (params: {  id: number; noteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyNote> {
            const localVarPath = this.basePath + '/company/companies/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdNotesNoteIdGet');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling companyCompaniesIdNotesNoteIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Company Note
         * @param id
         * @param noteId
         * @param operations
         */
        public companyCompaniesIdNotesNoteIdPatch (params: {  id: number; noteId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyNote> {
            const localVarPath = this.basePath + '/company/companies/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdNotesNoteIdPatch');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling companyCompaniesIdNotesNoteIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyCompaniesIdNotesNoteIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Company Note
         * @param id
         * @param noteId
         * @param companyNote
         */
        public companyCompaniesIdNotesNoteIdPut (params: {  id: number; noteId: number; companyNote: CompanyNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyNote> {
            const localVarPath = this.basePath + '/company/companies/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdNotesNoteIdPut');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling companyCompaniesIdNotesNoteIdPut');
            }
            // verify required parameter 'companyNote' is set
            if (params.companyNote == null) {
                throw new Error('Missing required parameter companyNote when calling companyCompaniesIdNotesNoteIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.companyNote),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Company Note
         * @param id
         * @param companyNote
         */
        public companyCompaniesIdNotesPost (params: {  id: number; companyNote: CompanyNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyNote> {
            const localVarPath = this.basePath + '/company/companies/{id}/notes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdNotesPost');
            }
            // verify required parameter 'companyNote' is set
            if (params.companyNote == null) {
                throw new Error('Missing required parameter companyNote when calling companyCompaniesIdNotesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.companyNote),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CompanySitesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Sites Count
         * @param id
         * @param conditions
         */
        public companyCompaniesIdSitesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/companies/{id}/sites/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdSitesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Sites
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyCompaniesIdSitesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CompanySite>> {
            const localVarPath = this.basePath + '/company/companies/{id}/sites'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdSitesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Site
         * @param id
         * @param site
         */
        public companyCompaniesIdSitesPost (params: {  id: number; site: CompanySite; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanySite> {
            const localVarPath = this.basePath + '/company/companies/{id}/sites'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdSitesPost');
            }
            // verify required parameter 'site' is set
            if (params.site == null) {
                throw new Error('Missing required parameter site when calling companyCompaniesIdSitesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.site),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Site By Id
         * @param id
         * @param siteId
         */
        public companyCompaniesIdSitesSiteIdDelete (params: {  id: number; siteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/companies/{id}/sites/{siteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'siteId' + '}', String(params.siteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdSitesSiteIdDelete');
            }
            // verify required parameter 'siteId' is set
            if (params.siteId == null) {
                throw new Error('Missing required parameter siteId when calling companyCompaniesIdSitesSiteIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Site By Id
         * @param id
         * @param siteId
         */
        public companyCompaniesIdSitesSiteIdGet (params: {  id: number; siteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanySite> {
            const localVarPath = this.basePath + '/company/companies/{id}/sites/{siteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'siteId' + '}', String(params.siteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdSitesSiteIdGet');
            }
            // verify required parameter 'siteId' is set
            if (params.siteId == null) {
                throw new Error('Missing required parameter siteId when calling companyCompaniesIdSitesSiteIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Site
         * @param id
         * @param siteId
         * @param operations
         */
        public companyCompaniesIdSitesSiteIdPatch (params: {  id: number; siteId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanySite> {
            const localVarPath = this.basePath + '/company/companies/{id}/sites/{siteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'siteId' + '}', String(params.siteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdSitesSiteIdPatch');
            }
            // verify required parameter 'siteId' is set
            if (params.siteId == null) {
                throw new Error('Missing required parameter siteId when calling companyCompaniesIdSitesSiteIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyCompaniesIdSitesSiteIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Site
         * @param id
         * @param siteId
         * @param site
         */
        public companyCompaniesIdSitesSiteIdPut (params: {  id: number; siteId: number; site: CompanySite; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanySite> {
            const localVarPath = this.basePath + '/company/companies/{id}/sites/{siteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'siteId' + '}', String(params.siteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdSitesSiteIdPut');
            }
            // verify required parameter 'siteId' is set
            if (params.siteId == null) {
                throw new Error('Missing required parameter siteId when calling companyCompaniesIdSitesSiteIdPut');
            }
            // verify required parameter 'site' is set
            if (params.site == null) {
                throw new Error('Missing required parameter site when calling companyCompaniesIdSitesSiteIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.site),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CompanyStatusesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Company Statuses Count
         * @param conditions
         */
        public companyCompaniesStatusesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/companies/statuses/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Company Statuses
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyCompaniesStatusesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CompanyStatus>> {
            const localVarPath = this.basePath + '/company/companies/statuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Company Status By Id
         * @param id
         */
        public companyCompaniesStatusesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/companies/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesStatusesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Company Status By Id
         * @param id
         */
        public companyCompaniesStatusesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyStatus> {
            const localVarPath = this.basePath + '/company/companies/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesStatusesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Company Status
         * @param id
         * @param operations
         */
        public companyCompaniesStatusesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyStatus> {
            const localVarPath = this.basePath + '/company/companies/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesStatusesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyCompaniesStatusesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Company Status
         * @param id
         * @param companyStatus
         */
        public companyCompaniesStatusesIdPut (params: {  id: number; companyStatus: CompanyStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyStatus> {
            const localVarPath = this.basePath + '/company/companies/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesStatusesIdPut');
            }
            // verify required parameter 'companyStatus' is set
            if (params.companyStatus == null) {
                throw new Error('Missing required parameter companyStatus when calling companyCompaniesStatusesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.companyStatus),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Company Status
         * @param companyStatus
         */
        public companyCompaniesStatusesPost (params: {  companyStatus: CompanyStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyStatus> {
            const localVarPath = this.basePath + '/company/companies/statuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'companyStatus' is set
            if (params.companyStatus == null) {
                throw new Error('Missing required parameter companyStatus when calling companyCompaniesStatusesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.companyStatus),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CompanyTeamsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Company Teams Count
         * @param id
         * @param conditions
         */
        public companyCompaniesIdTeamsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/companies/{id}/teams/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdTeamsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Company Teams
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyCompaniesIdTeamsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CompanyTeam>> {
            const localVarPath = this.basePath + '/company/companies/{id}/teams'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdTeamsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Company Team
         * @param id
         * @param companyTeam
         */
        public companyCompaniesIdTeamsPost (params: {  id: number; companyTeam: CompanyTeam; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyTeam> {
            const localVarPath = this.basePath + '/company/companies/{id}/teams'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdTeamsPost');
            }
            // verify required parameter 'companyTeam' is set
            if (params.companyTeam == null) {
                throw new Error('Missing required parameter companyTeam when calling companyCompaniesIdTeamsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.companyTeam),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Company Team By Id
         * @param id
         * @param teamId
         */
        public companyCompaniesIdTeamsTeamIdDelete (params: {  id: number; teamId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/companies/{id}/teams/{teamId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'teamId' + '}', String(params.teamId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdTeamsTeamIdDelete');
            }
            // verify required parameter 'teamId' is set
            if (params.teamId == null) {
                throw new Error('Missing required parameter teamId when calling companyCompaniesIdTeamsTeamIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Company Team By Id
         * @param id
         * @param teamId
         */
        public companyCompaniesIdTeamsTeamIdGet (params: {  id: number; teamId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyTeam> {
            const localVarPath = this.basePath + '/company/companies/{id}/teams/{teamId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'teamId' + '}', String(params.teamId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdTeamsTeamIdGet');
            }
            // verify required parameter 'teamId' is set
            if (params.teamId == null) {
                throw new Error('Missing required parameter teamId when calling companyCompaniesIdTeamsTeamIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Company Team
         * @param id
         * @param teamId
         * @param operations
         */
        public companyCompaniesIdTeamsTeamIdPatch (params: {  id: number; teamId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyTeam> {
            const localVarPath = this.basePath + '/company/companies/{id}/teams/{teamId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'teamId' + '}', String(params.teamId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdTeamsTeamIdPatch');
            }
            // verify required parameter 'teamId' is set
            if (params.teamId == null) {
                throw new Error('Missing required parameter teamId when calling companyCompaniesIdTeamsTeamIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyCompaniesIdTeamsTeamIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Company Team
         * @param id
         * @param teamId
         * @param companyTeam
         */
        public companyCompaniesIdTeamsTeamIdPut (params: {  id: number; teamId: number; companyTeam: CompanyTeam; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyTeam> {
            const localVarPath = this.basePath + '/company/companies/{id}/teams/{teamId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'teamId' + '}', String(params.teamId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdTeamsTeamIdPut');
            }
            // verify required parameter 'teamId' is set
            if (params.teamId == null) {
                throw new Error('Missing required parameter teamId when calling companyCompaniesIdTeamsTeamIdPut');
            }
            // verify required parameter 'companyTeam' is set
            if (params.companyTeam == null) {
                throw new Error('Missing required parameter companyTeam when calling companyCompaniesIdTeamsTeamIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.companyTeam),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CompanyTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Company Types Count
         * @param conditions
         */
        public companyCompaniesTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/companies/types/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Company Types
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyCompaniesTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CompanyType>> {
            const localVarPath = this.basePath + '/company/companies/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Company Type By Id
         * @param id
         */
        public companyCompaniesTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/companies/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesTypesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Company Type By Id
         * @param id
         */
        public companyCompaniesTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyType> {
            const localVarPath = this.basePath + '/company/companies/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesTypesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Company Type
         * @param id
         * @param operations
         */
        public companyCompaniesTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyType> {
            const localVarPath = this.basePath + '/company/companies/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesTypesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyCompaniesTypesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Company Type
         * @param id
         * @param companyType
         */
        public companyCompaniesTypesIdPut (params: {  id: number; companyType: CompanyType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyType> {
            const localVarPath = this.basePath + '/company/companies/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesTypesIdPut');
            }
            // verify required parameter 'companyType' is set
            if (params.companyType == null) {
                throw new Error('Missing required parameter companyType when calling companyCompaniesTypesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.companyType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Company Type
         * @param companyType
         */
        public companyCompaniesTypesPost (params: {  companyType: CompanyType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyType> {
            const localVarPath = this.basePath + '/company/companies/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'companyType' is set
            if (params.companyType == null) {
                throw new Error('Missing required parameter companyType when calling companyCompaniesTypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.companyType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ConfigurationStatusesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Configuration Statuses Count
         * @param conditions
         */
        public companyConfigurationsStatusesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/configurations/statuses/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Configuration Statuses
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyConfigurationsStatusesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ConfigurationStatus>> {
            const localVarPath = this.basePath + '/company/configurations/statuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Configuration Status By Id
         * @param id
         */
        public companyConfigurationsStatusesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/configurations/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsStatusesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Configuration Status By Id
         * @param id
         */
        public companyConfigurationsStatusesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationStatus> {
            const localVarPath = this.basePath + '/company/configurations/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsStatusesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Configuration Status
         * @param id
         * @param operations
         */
        public companyConfigurationsStatusesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationStatus> {
            const localVarPath = this.basePath + '/company/configurations/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsStatusesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyConfigurationsStatusesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Configuration Status
         * @param id
         * @param configurationStatus
         */
        public companyConfigurationsStatusesIdPut (params: {  id: number; configurationStatus: ConfigurationStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationStatus> {
            const localVarPath = this.basePath + '/company/configurations/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsStatusesIdPut');
            }
            // verify required parameter 'configurationStatus' is set
            if (params.configurationStatus == null) {
                throw new Error('Missing required parameter configurationStatus when calling companyConfigurationsStatusesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.configurationStatus),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Configuration Status
         * @param configurationStatus
         */
        public companyConfigurationsStatusesPost (params: {  configurationStatus: ConfigurationStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationStatus> {
            const localVarPath = this.basePath + '/company/configurations/statuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'configurationStatus' is set
            if (params.configurationStatus == null) {
                throw new Error('Missing required parameter configurationStatus when calling companyConfigurationsStatusesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.configurationStatus),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ConfigurationTypeQuestionsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Configuration Type Questions Count
         * @param id
         * @param conditions
         */
        public companyConfigurationsTypesIdQuestionsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/configurations/types/{id}/questions/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsTypesIdQuestionsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Configuration Type Questions
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyConfigurationsTypesIdQuestionsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ConfigurationTypeQuestion>> {
            const localVarPath = this.basePath + '/company/configurations/types/{id}/questions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsTypesIdQuestionsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Configuration Type Question
         * @param id
         * @param configurationTypeQuestion
         */
        public companyConfigurationsTypesIdQuestionsPost (params: {  id: number; configurationTypeQuestion: ConfigurationTypeQuestion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationTypeQuestion> {
            const localVarPath = this.basePath + '/company/configurations/types/{id}/questions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsTypesIdQuestionsPost');
            }
            // verify required parameter 'configurationTypeQuestion' is set
            if (params.configurationTypeQuestion == null) {
                throw new Error('Missing required parameter configurationTypeQuestion when calling companyConfigurationsTypesIdQuestionsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.configurationTypeQuestion),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Configuration Type Question By Id
         * @param id
         * @param questionId
         */
        public companyConfigurationsTypesIdQuestionsQuestionIdDelete (params: {  id: number; questionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/configurations/types/{id}/questions/{questionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'questionId' + '}', String(params.questionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsTypesIdQuestionsQuestionIdDelete');
            }
            // verify required parameter 'questionId' is set
            if (params.questionId == null) {
                throw new Error('Missing required parameter questionId when calling companyConfigurationsTypesIdQuestionsQuestionIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Configuration Type Question By Id
         * @param id
         * @param questionId
         */
        public companyConfigurationsTypesIdQuestionsQuestionIdGet (params: {  id: number; questionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationTypeQuestion> {
            const localVarPath = this.basePath + '/company/configurations/types/{id}/questions/{questionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'questionId' + '}', String(params.questionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsTypesIdQuestionsQuestionIdGet');
            }
            // verify required parameter 'questionId' is set
            if (params.questionId == null) {
                throw new Error('Missing required parameter questionId when calling companyConfigurationsTypesIdQuestionsQuestionIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Configuration Type Question
         * @param id
         * @param questionId
         * @param operations
         */
        public companyConfigurationsTypesIdQuestionsQuestionIdPatch (params: {  id: number; questionId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationTypeQuestion> {
            const localVarPath = this.basePath + '/company/configurations/types/{id}/questions/{questionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'questionId' + '}', String(params.questionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsTypesIdQuestionsQuestionIdPatch');
            }
            // verify required parameter 'questionId' is set
            if (params.questionId == null) {
                throw new Error('Missing required parameter questionId when calling companyConfigurationsTypesIdQuestionsQuestionIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyConfigurationsTypesIdQuestionsQuestionIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Configuration Type Question
         * @param id
         * @param questionId
         * @param configurationTypeQuestion
         */
        public companyConfigurationsTypesIdQuestionsQuestionIdPut (params: {  id: number; questionId: number; configurationTypeQuestion: ConfigurationTypeQuestion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationTypeQuestion> {
            const localVarPath = this.basePath + '/company/configurations/types/{id}/questions/{questionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'questionId' + '}', String(params.questionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsTypesIdQuestionsQuestionIdPut');
            }
            // verify required parameter 'questionId' is set
            if (params.questionId == null) {
                throw new Error('Missing required parameter questionId when calling companyConfigurationsTypesIdQuestionsQuestionIdPut');
            }
            // verify required parameter 'configurationTypeQuestion' is set
            if (params.configurationTypeQuestion == null) {
                throw new Error('Missing required parameter configurationTypeQuestion when calling companyConfigurationsTypesIdQuestionsQuestionIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.configurationTypeQuestion),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ConfigurationTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Configuration Types Count
         * @param conditions
         */
        public companyConfigurationsTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/configurations/types/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Configuration Types
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyConfigurationsTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ConfigurationType>> {
            const localVarPath = this.basePath + '/company/configurations/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Configuration Type By Id
         * @param id
         */
        public companyConfigurationsTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/configurations/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsTypesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Configuration Type By Id
         * @param id
         */
        public companyConfigurationsTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationType> {
            const localVarPath = this.basePath + '/company/configurations/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsTypesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Configuration Type
         * @param id
         * @param operations
         */
        public companyConfigurationsTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationType> {
            const localVarPath = this.basePath + '/company/configurations/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsTypesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyConfigurationsTypesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Configuration Type
         * @param id
         * @param configurationType
         */
        public companyConfigurationsTypesIdPut (params: {  id: number; configurationType: ConfigurationType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationType> {
            const localVarPath = this.basePath + '/company/configurations/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsTypesIdPut');
            }
            // verify required parameter 'configurationType' is set
            if (params.configurationType == null) {
                throw new Error('Missing required parameter configurationType when calling companyConfigurationsTypesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.configurationType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Configuration Type
         * @param configurationType
         */
        public companyConfigurationsTypesPost (params: {  configurationType: ConfigurationType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationType> {
            const localVarPath = this.basePath + '/company/configurations/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'configurationType' is set
            if (params.configurationType == null) {
                throw new Error('Missing required parameter configurationType when calling companyConfigurationsTypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.configurationType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ConfigurationsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Configurations Count
         * @param conditions
         * @param managedIdentifier
         */
        public companyConfigurationsCountGet (params: {  conditions?: string; managedIdentifier?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/configurations/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.managedIdentifier !== undefined) {
                queryParameters['managedIdentifier'] = params.managedIdentifier;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Configurations
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         * @param managedIdentifier
         */
        public companyConfigurationsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; managedIdentifier?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Configuration>> {
            const localVarPath = this.basePath + '/company/configurations';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            if (params.managedIdentifier !== undefined) {
                queryParameters['managedIdentifier'] = params.managedIdentifier;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Configuration By Id
         * @param id
         */
        public companyConfigurationsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/configurations/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Configuration By Id
         * @param id
         */
        public companyConfigurationsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Configuration> {
            const localVarPath = this.basePath + '/company/configurations/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Configuration
         * @param id
         * @param operations
         * @param managementSolutionName
         * @param managedIdentifier
         * @param type
         * @param level
         * @param childConfigurationsMatchingOn
         * @param inactivateConfigurationsMatchingOn
         * @param inactiveConfigurationStatusId
         */
        public companyConfigurationsIdPatch (params: {  id: number; operations: Array<PatchOperation>; managementSolutionName?: string; managedIdentifier?: string; type?: string; level?: string; childConfigurationsMatchingOn?: string; inactivateConfigurationsMatchingOn?: string; inactiveConfigurationStatusId?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Configuration> {
            const localVarPath = this.basePath + '/company/configurations/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyConfigurationsIdPatch');
            }
            if (params.managementSolutionName !== undefined) {
                queryParameters['managementSolutionName'] = params.managementSolutionName;
            }

            if (params.managedIdentifier !== undefined) {
                queryParameters['managedIdentifier'] = params.managedIdentifier;
            }

            if (params.type !== undefined) {
                queryParameters['type'] = params.type;
            }

            if (params.level !== undefined) {
                queryParameters['level'] = params.level;
            }

            if (params.childConfigurationsMatchingOn !== undefined) {
                queryParameters['childConfigurationsMatchingOn'] = params.childConfigurationsMatchingOn;
            }

            if (params.inactivateConfigurationsMatchingOn !== undefined) {
                queryParameters['inactivateConfigurationsMatchingOn'] = params.inactivateConfigurationsMatchingOn;
            }

            if (params.inactiveConfigurationStatusId !== undefined) {
                queryParameters['inactiveConfigurationStatusId'] = params.inactiveConfigurationStatusId;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Configuration
         * @param id
         * @param configuration
         * @param managementSolutionName
         * @param managedIdentifier
         * @param type
         * @param level
         * @param childConfigurationsMatchingOn
         * @param inactivateConfigurationsMatchingOn
         * @param inactiveConfigurationStatusId
         */
        public companyConfigurationsIdPut (params: {  id: number; configuration: Configuration; managementSolutionName?: string; managedIdentifier?: string; type?: string; level?: string; childConfigurationsMatchingOn?: string; inactivateConfigurationsMatchingOn?: string; inactiveConfigurationStatusId?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Configuration> {
            const localVarPath = this.basePath + '/company/configurations/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsIdPut');
            }
            // verify required parameter 'configuration' is set
            if (params.configuration == null) {
                throw new Error('Missing required parameter configuration when calling companyConfigurationsIdPut');
            }
            if (params.managementSolutionName !== undefined) {
                queryParameters['managementSolutionName'] = params.managementSolutionName;
            }

            if (params.managedIdentifier !== undefined) {
                queryParameters['managedIdentifier'] = params.managedIdentifier;
            }

            if (params.type !== undefined) {
                queryParameters['type'] = params.type;
            }

            if (params.level !== undefined) {
                queryParameters['level'] = params.level;
            }

            if (params.childConfigurationsMatchingOn !== undefined) {
                queryParameters['childConfigurationsMatchingOn'] = params.childConfigurationsMatchingOn;
            }

            if (params.inactivateConfigurationsMatchingOn !== undefined) {
                queryParameters['inactivateConfigurationsMatchingOn'] = params.inactivateConfigurationsMatchingOn;
            }

            if (params.inactiveConfigurationStatusId !== undefined) {
                queryParameters['inactiveConfigurationStatusId'] = params.inactiveConfigurationStatusId;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.configuration),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Configuration
         * @param configuration
         * @param managementSolutionName
         * @param managedIdentifier
         * @param type
         * @param level
         * @param childConfigurationsMatchingOn
         * @param inactivateConfigurationsMatchingOn
         * @param inactiveConfigurationStatusId
         */
        public companyConfigurationsPost (params: {  configuration: Configuration; managementSolutionName?: string; managedIdentifier?: string; type?: string; level?: string; childConfigurationsMatchingOn?: string; inactivateConfigurationsMatchingOn?: string; inactiveConfigurationStatusId?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Configuration> {
            const localVarPath = this.basePath + '/company/configurations';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'configuration' is set
            if (params.configuration == null) {
                throw new Error('Missing required parameter configuration when calling companyConfigurationsPost');
            }
            if (params.managementSolutionName !== undefined) {
                queryParameters['managementSolutionName'] = params.managementSolutionName;
            }

            if (params.managedIdentifier !== undefined) {
                queryParameters['managedIdentifier'] = params.managedIdentifier;
            }

            if (params.type !== undefined) {
                queryParameters['type'] = params.type;
            }

            if (params.level !== undefined) {
                queryParameters['level'] = params.level;
            }

            if (params.childConfigurationsMatchingOn !== undefined) {
                queryParameters['childConfigurationsMatchingOn'] = params.childConfigurationsMatchingOn;
            }

            if (params.inactivateConfigurationsMatchingOn !== undefined) {
                queryParameters['inactivateConfigurationsMatchingOn'] = params.inactivateConfigurationsMatchingOn;
            }

            if (params.inactiveConfigurationStatusId !== undefined) {
                queryParameters['inactiveConfigurationStatusId'] = params.inactiveConfigurationStatusId;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.configuration),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ConnectWiseHostedSetupsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Connect Wise Hosted Setups Count
         * @param conditions
         */
        public systemConnectwisehostedsetupsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/connectwisehostedsetups/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Connect Wise Hosted Setups
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemConnectwisehostedsetupsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ConnectWiseHostedSetup>> {
            const localVarPath = this.basePath + '/system/connectwisehostedsetups';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Connect Wise Hosted Setup By Id
         * @param id
         */
        public systemConnectwisehostedsetupsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/connectwisehostedsetups/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemConnectwisehostedsetupsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Connect Wise Hosted Setup By Id
         * @param id
         */
        public systemConnectwisehostedsetupsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConnectWiseHostedSetup> {
            const localVarPath = this.basePath + '/system/connectwisehostedsetups/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemConnectwisehostedsetupsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Connect Wise Hosted Setup
         * @param id
         * @param operations
         */
        public systemConnectwisehostedsetupsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConnectWiseHostedSetup> {
            const localVarPath = this.basePath + '/system/connectwisehostedsetups/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemConnectwisehostedsetupsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemConnectwisehostedsetupsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Connect Wise Hosted Setup
         * @param id
         * @param connectWiseHostedSetup
         */
        public systemConnectwisehostedsetupsIdPut (params: {  id: number; connectWiseHostedSetup: ConnectWiseHostedSetup; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConnectWiseHostedSetup> {
            const localVarPath = this.basePath + '/system/connectwisehostedsetups/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemConnectwisehostedsetupsIdPut');
            }
            // verify required parameter 'connectWiseHostedSetup' is set
            if (params.connectWiseHostedSetup == null) {
                throw new Error('Missing required parameter connectWiseHostedSetup when calling systemConnectwisehostedsetupsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.connectWiseHostedSetup),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Connect Wise Hosted Setup
         * @param connectWiseHostedSetup
         */
        public systemConnectwisehostedsetupsPost (params: {  connectWiseHostedSetup: ConnectWiseHostedSetup; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConnectWiseHostedSetup> {
            const localVarPath = this.basePath + '/system/connectwisehostedsetups';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'connectWiseHostedSetup' is set
            if (params.connectWiseHostedSetup == null) {
                throw new Error('Missing required parameter connectWiseHostedSetup when calling systemConnectwisehostedsetupsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.connectWiseHostedSetup),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ContactCommunicationsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Delete Contact Communication By Id
         * @param id
         * @param communicationId
         */
        public companyContactsIdCommunicationsCommunicationIdDelete (params: {  id: number; communicationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/contacts/{id}/communications/{communicationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'communicationId' + '}', String(params.communicationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdCommunicationsCommunicationIdDelete');
            }
            // verify required parameter 'communicationId' is set
            if (params.communicationId == null) {
                throw new Error('Missing required parameter communicationId when calling companyContactsIdCommunicationsCommunicationIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Contact Communication By Id
         * @param id
         * @param communicationId
         */
        public companyContactsIdCommunicationsCommunicationIdGet (params: {  id: number; communicationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactCommunication> {
            const localVarPath = this.basePath + '/company/contacts/{id}/communications/{communicationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'communicationId' + '}', String(params.communicationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdCommunicationsCommunicationIdGet');
            }
            // verify required parameter 'communicationId' is set
            if (params.communicationId == null) {
                throw new Error('Missing required parameter communicationId when calling companyContactsIdCommunicationsCommunicationIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Contact Communication
         * @param id
         * @param communicationId
         * @param operations
         */
        public companyContactsIdCommunicationsCommunicationIdPatch (params: {  id: number; communicationId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactCommunication> {
            const localVarPath = this.basePath + '/company/contacts/{id}/communications/{communicationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'communicationId' + '}', String(params.communicationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdCommunicationsCommunicationIdPatch');
            }
            // verify required parameter 'communicationId' is set
            if (params.communicationId == null) {
                throw new Error('Missing required parameter communicationId when calling companyContactsIdCommunicationsCommunicationIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyContactsIdCommunicationsCommunicationIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Contact Communication
         * @param id
         * @param communicationId
         * @param contactCommunication
         */
        public companyContactsIdCommunicationsCommunicationIdPut (params: {  id: number; communicationId: number; contactCommunication: ContactCommunication; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactCommunication> {
            const localVarPath = this.basePath + '/company/contacts/{id}/communications/{communicationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'communicationId' + '}', String(params.communicationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdCommunicationsCommunicationIdPut');
            }
            // verify required parameter 'communicationId' is set
            if (params.communicationId == null) {
                throw new Error('Missing required parameter communicationId when calling companyContactsIdCommunicationsCommunicationIdPut');
            }
            // verify required parameter 'contactCommunication' is set
            if (params.contactCommunication == null) {
                throw new Error('Missing required parameter contactCommunication when calling companyContactsIdCommunicationsCommunicationIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.contactCommunication),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Contact Communications Count
         * @param id
         * @param conditions
         */
        public companyContactsIdCommunicationsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/contacts/{id}/communications/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdCommunicationsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Contact Communications
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyContactsIdCommunicationsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ContactCommunication>> {
            const localVarPath = this.basePath + '/company/contacts/{id}/communications'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdCommunicationsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Contact Communication
         * @param id
         * @param contactCommunication
         */
        public companyContactsIdCommunicationsPost (params: {  id: number; contactCommunication: ContactCommunication; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactCommunication> {
            const localVarPath = this.basePath + '/company/contacts/{id}/communications'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdCommunicationsPost');
            }
            // verify required parameter 'contactCommunication' is set
            if (params.contactCommunication == null) {
                throw new Error('Missing required parameter contactCommunication when calling companyContactsIdCommunicationsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.contactCommunication),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ContactDepartmentsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Contact Departments Count
         * @param conditions
         */
        public companyContactsDepartmentsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/contacts/departments/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Contact Departments
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyContactsDepartmentsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ContactDepartment>> {
            const localVarPath = this.basePath + '/company/contacts/departments';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Contact Department By Id
         * @param id
         */
        public companyContactsDepartmentsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/contacts/departments/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsDepartmentsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Contact Department By Id
         * @param id
         */
        public companyContactsDepartmentsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactDepartment> {
            const localVarPath = this.basePath + '/company/contacts/departments/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsDepartmentsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Contact Department
         * @param id
         * @param operations
         */
        public companyContactsDepartmentsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactDepartment> {
            const localVarPath = this.basePath + '/company/contacts/departments/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsDepartmentsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyContactsDepartmentsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Contact Department
         * @param id
         * @param contactDepartment
         */
        public companyContactsDepartmentsIdPut (params: {  id: number; contactDepartment: ContactDepartment; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactDepartment> {
            const localVarPath = this.basePath + '/company/contacts/departments/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsDepartmentsIdPut');
            }
            // verify required parameter 'contactDepartment' is set
            if (params.contactDepartment == null) {
                throw new Error('Missing required parameter contactDepartment when calling companyContactsDepartmentsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.contactDepartment),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Contact Department
         * @param contactDepartment
         */
        public companyContactsDepartmentsPost (params: {  contactDepartment: ContactDepartment; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactDepartment> {
            const localVarPath = this.basePath + '/company/contacts/departments';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'contactDepartment' is set
            if (params.contactDepartment == null) {
                throw new Error('Missing required parameter contactDepartment when calling companyContactsDepartmentsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.contactDepartment),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ContactNotesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Contact Notes Count
         * @param id
         * @param conditions
         */
        public companyContactsIdNotesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/contacts/{id}/notes/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdNotesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Contact Notes
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyContactsIdNotesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ContactNote>> {
            const localVarPath = this.basePath + '/company/contacts/{id}/notes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdNotesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Contact Note By Id
         * @param id
         * @param noteId
         */
        public companyContactsIdNotesNoteIdDelete (params: {  id: number; noteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/contacts/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdNotesNoteIdDelete');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling companyContactsIdNotesNoteIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Contact Note By Id
         * @param id
         * @param noteId
         */
        public companyContactsIdNotesNoteIdGet (params: {  id: number; noteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactNote> {
            const localVarPath = this.basePath + '/company/contacts/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdNotesNoteIdGet');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling companyContactsIdNotesNoteIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Contact Note
         * @param id
         * @param noteId
         * @param operations
         */
        public companyContactsIdNotesNoteIdPatch (params: {  id: number; noteId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactNote> {
            const localVarPath = this.basePath + '/company/contacts/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdNotesNoteIdPatch');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling companyContactsIdNotesNoteIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyContactsIdNotesNoteIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Contact Note
         * @param id
         * @param noteId
         * @param contactNote
         */
        public companyContactsIdNotesNoteIdPut (params: {  id: number; noteId: number; contactNote: ContactNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactNote> {
            const localVarPath = this.basePath + '/company/contacts/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdNotesNoteIdPut');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling companyContactsIdNotesNoteIdPut');
            }
            // verify required parameter 'contactNote' is set
            if (params.contactNote == null) {
                throw new Error('Missing required parameter contactNote when calling companyContactsIdNotesNoteIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.contactNote),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Contact Note
         * @param id
         * @param contactNote
         */
        public companyContactsIdNotesPost (params: {  id: number; contactNote: ContactNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactNote> {
            const localVarPath = this.basePath + '/company/contacts/{id}/notes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdNotesPost');
            }
            // verify required parameter 'contactNote' is set
            if (params.contactNote == null) {
                throw new Error('Missing required parameter contactNote when calling companyContactsIdNotesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.contactNote),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ContactRelationshipsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Contact Relationships Count
         * @param conditions
         */
        public companyContactsRelationshipsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/contacts/relationships/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Contact Relationships
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyContactsRelationshipsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ContactRelationship>> {
            const localVarPath = this.basePath + '/company/contacts/relationships';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Contact Relationship By Id
         * @param id
         */
        public companyContactsRelationshipsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/contacts/relationships/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsRelationshipsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Contact Relationship By Id
         * @param id
         */
        public companyContactsRelationshipsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactRelationship> {
            const localVarPath = this.basePath + '/company/contacts/relationships/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsRelationshipsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Contact Relationship
         * @param id
         * @param operations
         */
        public companyContactsRelationshipsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactRelationship> {
            const localVarPath = this.basePath + '/company/contacts/relationships/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsRelationshipsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyContactsRelationshipsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Contact Relationship
         * @param id
         * @param contactRelationship
         */
        public companyContactsRelationshipsIdPut (params: {  id: number; contactRelationship: ContactRelationship; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactRelationship> {
            const localVarPath = this.basePath + '/company/contacts/relationships/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsRelationshipsIdPut');
            }
            // verify required parameter 'contactRelationship' is set
            if (params.contactRelationship == null) {
                throw new Error('Missing required parameter contactRelationship when calling companyContactsRelationshipsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.contactRelationship),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Contact Relationship
         * @param contactRelationship
         */
        public companyContactsRelationshipsPost (params: {  contactRelationship: ContactRelationship; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactRelationship> {
            const localVarPath = this.basePath + '/company/contacts/relationships';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'contactRelationship' is set
            if (params.contactRelationship == null) {
                throw new Error('Missing required parameter contactRelationship when calling companyContactsRelationshipsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.contactRelationship),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ContactTracksApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Tracks Count
         * @param id
         * @param conditions
         */
        public companyContactsIdTracksCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/contacts/{id}/tracks/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdTracksCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Tracks
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyContactsIdTracksGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Track>> {
            const localVarPath = this.basePath + '/company/contacts/{id}/tracks'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdTracksGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Track
         * @param id
         * @param track
         */
        public companyContactsIdTracksPost (params: {  id: number; track: Track; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Track> {
            const localVarPath = this.basePath + '/company/contacts/{id}/tracks'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdTracksPost');
            }
            // verify required parameter 'track' is set
            if (params.track == null) {
                throw new Error('Missing required parameter track when calling companyContactsIdTracksPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.track),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Track By Id
         * @param id
         * @param trackId
         */
        public companyContactsIdTracksTrackIdDelete (params: {  id: number; trackId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/contacts/{id}/tracks/{trackId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'trackId' + '}', String(params.trackId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdTracksTrackIdDelete');
            }
            // verify required parameter 'trackId' is set
            if (params.trackId == null) {
                throw new Error('Missing required parameter trackId when calling companyContactsIdTracksTrackIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Track By Id
         * @param id
         * @param trackId
         */
        public companyContactsIdTracksTrackIdGet (params: {  id: number; trackId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Track> {
            const localVarPath = this.basePath + '/company/contacts/{id}/tracks/{trackId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'trackId' + '}', String(params.trackId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdTracksTrackIdGet');
            }
            // verify required parameter 'trackId' is set
            if (params.trackId == null) {
                throw new Error('Missing required parameter trackId when calling companyContactsIdTracksTrackIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ContactTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Contact Types Count
         * @param conditions
         */
        public companyContactsTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/contacts/types/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Contact Types
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyContactsTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ContactType>> {
            const localVarPath = this.basePath + '/company/contacts/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Contact Type By Id
         * @param id
         */
        public companyContactsTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/contacts/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsTypesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Contact Type By Id
         * @param id
         */
        public companyContactsTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactType> {
            const localVarPath = this.basePath + '/company/contacts/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsTypesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Contact Type
         * @param id
         * @param operations
         */
        public companyContactsTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactType> {
            const localVarPath = this.basePath + '/company/contacts/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsTypesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyContactsTypesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Contact Type
         * @param id
         * @param contactType
         */
        public companyContactsTypesIdPut (params: {  id: number; contactType: ContactType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactType> {
            const localVarPath = this.basePath + '/company/contacts/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsTypesIdPut');
            }
            // verify required parameter 'contactType' is set
            if (params.contactType == null) {
                throw new Error('Missing required parameter contactType when calling companyContactsTypesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.contactType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Contact Type
         * @param contactType
         */
        public companyContactsTypesPost (params: {  contactType: ContactType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactType> {
            const localVarPath = this.basePath + '/company/contacts/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'contactType' is set
            if (params.contactType == null) {
                throw new Error('Missing required parameter contactType when calling companyContactsTypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.contactType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ContactsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Contacts Count
         * @param conditions
         * @param customFieldConditions
         * @param childConditions
         */
        public companyContactsCountGet (params: {  conditions?: string; customFieldConditions?: string; childConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/contacts/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.customFieldConditions !== undefined) {
                queryParameters['customFieldConditions'] = params.customFieldConditions;
            }

            if (params.childConditions !== undefined) {
                queryParameters['childConditions'] = params.childConditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Contacts
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyContactsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Contact>> {
            const localVarPath = this.basePath + '/company/contacts';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Contact By Id
         * @param id
         * @param transferContactId
         */
        public companyContactsIdDelete (params: {  id: number; transferContactId?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/contacts/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdDelete');
            }
            if (params.transferContactId !== undefined) {
                queryParameters['transferContactId'] = params.transferContactId;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Contact By Id
         * @param id
         */
        public companyContactsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Contact> {
            const localVarPath = this.basePath + '/company/contacts/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Contact Image
         * @param id
         * @param useDefaultFlag
         * @param lastModified
         */
        public companyContactsIdImageGet (params: {  id: number; useDefaultFlag?: boolean; lastModified?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/contacts/{id}/image'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdImageGet');
            }
            if (params.useDefaultFlag !== undefined) {
                queryParameters['useDefaultFlag'] = params.useDefaultFlag;
            }

            if (params.lastModified !== undefined) {
                queryParameters['lastModified'] = params.lastModified;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Contact
         * @param id
         * @param operations
         */
        public companyContactsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Contact> {
            const localVarPath = this.basePath + '/company/contacts/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyContactsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Portal Security
         * @param id
         */
        public companyContactsIdPortalSecurityGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<PortalSecurity>> {
            const localVarPath = this.basePath + '/company/contacts/{id}/portalSecurity'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdPortalSecurityGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Contact
         * @param id
         * @param contact
         */
        public companyContactsIdPut (params: {  id: number; contact: Contact; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Contact> {
            const localVarPath = this.basePath + '/company/contacts/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdPut');
            }
            // verify required parameter 'contact' is set
            if (params.contact == null) {
                throw new Error('Missing required parameter contact when calling companyContactsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.contact),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Contact
         * @param contact
         */
        public companyContactsPost (params: {  contact: Contact; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Contact> {
            const localVarPath = this.basePath + '/company/contacts';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'contact' is set
            if (params.contact == null) {
                throw new Error('Missing required parameter contact when calling companyContactsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.contact),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Request Password
         * @param request
         */
        public companyContactsRequestPasswordPost (params: {  request: RequestPasswordRequest; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/contacts/requestPassword';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'request' is set
            if (params.request == null) {
                throw new Error('Missing required parameter request when calling companyContactsRequestPasswordPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.request),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Validate Portal Credentials
         * @param request
         */
        public companyContactsValidatePortalCredentialsPost (params: {  request: ValidatePortalRequest; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ValidatePortalResponse> {
            const localVarPath = this.basePath + '/company/contacts/validatePortalCredentials';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'request' is set
            if (params.request == null) {
                throw new Error('Missing required parameter request when calling companyContactsValidatePortalCredentialsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.request),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CurrenciesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Currencies Count
         * @param conditions
         */
        public financeCurrenciesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/currencies/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Currencies
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeCurrenciesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Currency>> {
            const localVarPath = this.basePath + '/finance/currencies';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Currency By Id
         * @param id
         */
        public financeCurrenciesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/currencies/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeCurrenciesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Currency By Id
         * @param id
         */
        public financeCurrenciesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Currency> {
            const localVarPath = this.basePath + '/finance/currencies/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeCurrenciesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Currency
         * @param id
         * @param operations
         */
        public financeCurrenciesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Currency> {
            const localVarPath = this.basePath + '/finance/currencies/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeCurrenciesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeCurrenciesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Currency
         * @param id
         * @param currency
         */
        public financeCurrenciesIdPut (params: {  id: number; currency: Currency; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Currency> {
            const localVarPath = this.basePath + '/finance/currencies/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeCurrenciesIdPut');
            }
            // verify required parameter 'currency' is set
            if (params.currency == null) {
                throw new Error('Missing required parameter currency when calling financeCurrenciesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.currency),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Currency
         * @param currency
         */
        public financeCurrenciesPost (params: {  currency: Currency; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Currency> {
            const localVarPath = this.basePath + '/finance/currencies';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'currency' is set
            if (params.currency == null) {
                throw new Error('Missing required parameter currency when calling financeCurrenciesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.currency),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class DocumentsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Documents Info Count
         * @param recordType
         * @param recordId
         */
        public systemDocumentsCountGet (params: {  recordType?: string; recordId?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/documents/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.recordType !== undefined) {
                queryParameters['recordType'] = params.recordType;
            }

            if (params.recordId !== undefined) {
                queryParameters['recordId'] = params.recordId;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Documents Info
         * @param recordType
         * @param recordId
         * @param page
         * @param pageSize
         */
        public systemDocumentsGet (params: {  recordType?: string; recordId?: number; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<DocumentInfo>> {
            const localVarPath = this.basePath + '/system/documents';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.recordType !== undefined) {
                queryParameters['recordType'] = params.recordType;
            }

            if (params.recordId !== undefined) {
                queryParameters['recordId'] = params.recordId;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Document Info By Id
         * @param id
         */
        public systemDocumentsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/documents/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemDocumentsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Download Document
         * @param id
         * @param lastModified
         */
        public systemDocumentsIdDownloadGet (params: {  id: number; lastModified?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/documents/{id}/download'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemDocumentsIdDownloadGet');
            }
            if (params.lastModified !== undefined) {
                queryParameters['lastModified'] = params.lastModified;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Document Info By Id
         * @param id
         */
        public systemDocumentsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<DocumentInfo> {
            const localVarPath = this.basePath + '/system/documents/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemDocumentsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Document By Id
         * @param id
         * @param recordId Entity id
         * @param recordType Entity type
         * @param title Document title
         * @param url Document url
         * @param file File to upload
         * @param privateFlag Indicates if document is private
         * @param readOnlyFlag Indicates if document is readonly
         */
        public systemDocumentsIdPost (params: {  id: number; recordId: number; recordType: string; title: string; url: string; file?: any; privateFlag?: boolean; readOnlyFlag?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<DocumentInfo> {
            const localVarPath = this.basePath + '/system/documents/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            let formParams: any = {};
            headerParams['Content-Type'] = 'application/x-www-form-urlencoded';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemDocumentsIdPost');
            }
            // verify required parameter 'recordId' is set
            if (params.recordId == null) {
                throw new Error('Missing required parameter recordId when calling systemDocumentsIdPost');
            }
            // verify required parameter 'recordType' is set
            if (params.recordType == null) {
                throw new Error('Missing required parameter recordType when calling systemDocumentsIdPost');
            }
            // verify required parameter 'title' is set
            if (params.title == null) {
                throw new Error('Missing required parameter title when calling systemDocumentsIdPost');
            }
            // verify required parameter 'url' is set
            if (params.url == null) {
                throw new Error('Missing required parameter url when calling systemDocumentsIdPost');
            }
            formParams['file'] = params.file;

            formParams['recordId'] = params.recordId;

            formParams['recordType'] = params.recordType;

            formParams['title'] = params.title;

            formParams['url'] = params.url;

            formParams['privateFlag'] = params.privateFlag;

            formParams['readOnlyFlag'] = params.readOnlyFlag;

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                                body: querystring.stringify(formParams),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Insert Document
         * @param recordId Entity id
         * @param recordType Entity type
         * @param title Document title
         * @param url Document url
         * @param file File to upload
         * @param privateFlag Indicates if document is private
         * @param readOnlyFlag Indicates if document is readonly
         */
        public systemDocumentsPost (params: {  recordId: number; recordType: string; title: string; url: string; file?: any; privateFlag?: boolean; readOnlyFlag?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<DocumentInfo> {
            const localVarPath = this.basePath + '/system/documents';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            let formParams: any = {};
            headerParams['Content-Type'] = 'application/x-www-form-urlencoded';

            // verify required parameter 'recordId' is set
            if (params.recordId == null) {
                throw new Error('Missing required parameter recordId when calling systemDocumentsPost');
            }
            // verify required parameter 'recordType' is set
            if (params.recordType == null) {
                throw new Error('Missing required parameter recordType when calling systemDocumentsPost');
            }
            // verify required parameter 'title' is set
            if (params.title == null) {
                throw new Error('Missing required parameter title when calling systemDocumentsPost');
            }
            // verify required parameter 'url' is set
            if (params.url == null) {
                throw new Error('Missing required parameter url when calling systemDocumentsPost');
            }
            formParams['file'] = params.file;

            formParams['recordId'] = params.recordId;

            formParams['recordType'] = params.recordType;

            formParams['title'] = params.title;

            formParams['url'] = params.url;

            formParams['privateFlag'] = params.privateFlag;

            formParams['readOnlyFlag'] = params.readOnlyFlag;

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                                body: querystring.stringify(formParams),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Upload Sample Page
         */
        public systemDocumentsUploadsampleGet (params: {  }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/documents/uploadsample';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ExpenseEntriesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Expense Entries Count
         * @param conditions
         * @param customFieldConditions
         * @param childConditions
         */
        public expenseEntriesCountGet (params: {  conditions?: string; customFieldConditions?: string; childConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/expense/entries/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.customFieldConditions !== undefined) {
                queryParameters['customFieldConditions'] = params.customFieldConditions;
            }

            if (params.childConditions !== undefined) {
                queryParameters['childConditions'] = params.childConditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Expense Entries
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public expenseEntriesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ExpenseEntry>> {
            const localVarPath = this.basePath + '/expense/entries';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Expense Entry By Id
         * @param id
         */
        public expenseEntriesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/expense/entries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling expenseEntriesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Expense Entry By Id
         * @param id
         */
        public expenseEntriesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ExpenseEntry> {
            const localVarPath = this.basePath + '/expense/entries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling expenseEntriesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Expense Entry
         * @param id
         * @param operations
         */
        public expenseEntriesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ExpenseEntry> {
            const localVarPath = this.basePath + '/expense/entries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling expenseEntriesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling expenseEntriesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Expense Entry
         * @param id
         * @param expenseEntry
         */
        public expenseEntriesIdPut (params: {  id: number; expenseEntry: ExpenseEntry; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ExpenseEntry> {
            const localVarPath = this.basePath + '/expense/entries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling expenseEntriesIdPut');
            }
            // verify required parameter 'expenseEntry' is set
            if (params.expenseEntry == null) {
                throw new Error('Missing required parameter expenseEntry when calling expenseEntriesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.expenseEntry),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Expense Entry
         * @param expenseEntry
         */
        public expenseEntriesPost (params: {  expenseEntry: ExpenseEntry; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ExpenseEntry> {
            const localVarPath = this.basePath + '/expense/entries';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'expenseEntry' is set
            if (params.expenseEntry == null) {
                throw new Error('Missing required parameter expenseEntry when calling expenseEntriesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.expenseEntry),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ExpenseTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Expense Types Count
         * @param conditions
         */
        public expenseTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/expense/types/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Expense Types
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public expenseTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ExpenseType>> {
            const localVarPath = this.basePath + '/expense/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Expense Type By Id
         * @param id
         */
        public expenseTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/expense/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling expenseTypesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Expense Type By Id
         * @param id
         */
        public expenseTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ExpenseType> {
            const localVarPath = this.basePath + '/expense/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling expenseTypesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Expense Type
         * @param id
         * @param operations
         */
        public expenseTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ExpenseType> {
            const localVarPath = this.basePath + '/expense/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling expenseTypesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling expenseTypesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Expense Type
         * @param id
         * @param expenseType
         */
        public expenseTypesIdPut (params: {  id: number; expenseType: ExpenseType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ExpenseType> {
            const localVarPath = this.basePath + '/expense/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling expenseTypesIdPut');
            }
            // verify required parameter 'expenseType' is set
            if (params.expenseType == null) {
                throw new Error('Missing required parameter expenseType when calling expenseTypesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.expenseType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Expense Type
         * @param expenseType
         */
        public expenseTypesPost (params: {  expenseType: ExpenseType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ExpenseType> {
            const localVarPath = this.basePath + '/expense/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'expenseType' is set
            if (params.expenseType == null) {
                throw new Error('Missing required parameter expenseType when calling expenseTypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.expenseType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class GroupCompaniesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Delete Marketing Company By Id
         * @param id
         * @param companyId
         */
        public marketingGroupsIdCompaniesCompanyIdDelete (params: {  id: number; companyId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/marketing/groups/{id}/companies/{companyId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'companyId' + '}', String(params.companyId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdCompaniesCompanyIdDelete');
            }
            // verify required parameter 'companyId' is set
            if (params.companyId == null) {
                throw new Error('Missing required parameter companyId when calling marketingGroupsIdCompaniesCompanyIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Marketing Company By Id
         * @param id
         * @param companyId
         */
        public marketingGroupsIdCompaniesCompanyIdGet (params: {  id: number; companyId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MarketingCompany> {
            const localVarPath = this.basePath + '/marketing/groups/{id}/companies/{companyId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'companyId' + '}', String(params.companyId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdCompaniesCompanyIdGet');
            }
            // verify required parameter 'companyId' is set
            if (params.companyId == null) {
                throw new Error('Missing required parameter companyId when calling marketingGroupsIdCompaniesCompanyIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Marketing Company
         * @param id
         * @param companyId
         * @param operations
         */
        public marketingGroupsIdCompaniesCompanyIdPatch (params: {  id: number; companyId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MarketingCompany> {
            const localVarPath = this.basePath + '/marketing/groups/{id}/companies/{companyId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'companyId' + '}', String(params.companyId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdCompaniesCompanyIdPatch');
            }
            // verify required parameter 'companyId' is set
            if (params.companyId == null) {
                throw new Error('Missing required parameter companyId when calling marketingGroupsIdCompaniesCompanyIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling marketingGroupsIdCompaniesCompanyIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Marketing Company
         * @param id
         * @param companyId
         * @param marketingCompany
         */
        public marketingGroupsIdCompaniesCompanyIdPut (params: {  id: number; companyId: number; marketingCompany: MarketingCompany; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MarketingCompany> {
            const localVarPath = this.basePath + '/marketing/groups/{id}/companies/{companyId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'companyId' + '}', String(params.companyId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdCompaniesCompanyIdPut');
            }
            // verify required parameter 'companyId' is set
            if (params.companyId == null) {
                throw new Error('Missing required parameter companyId when calling marketingGroupsIdCompaniesCompanyIdPut');
            }
            // verify required parameter 'marketingCompany' is set
            if (params.marketingCompany == null) {
                throw new Error('Missing required parameter marketingCompany when calling marketingGroupsIdCompaniesCompanyIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.marketingCompany),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Marketing Companys Count
         * @param id
         * @param conditions
         */
        public marketingGroupsIdCompaniesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/marketing/groups/{id}/companies/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdCompaniesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Marketing Companys
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public marketingGroupsIdCompaniesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<MarketingCompany>> {
            const localVarPath = this.basePath + '/marketing/groups/{id}/companies'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdCompaniesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Marketing Company
         * @param id
         * @param marketingCompany
         */
        public marketingGroupsIdCompaniesPost (params: {  id: number; marketingCompany: MarketingCompany; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MarketingCompany> {
            const localVarPath = this.basePath + '/marketing/groups/{id}/companies'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdCompaniesPost');
            }
            // verify required parameter 'marketingCompany' is set
            if (params.marketingCompany == null) {
                throw new Error('Missing required parameter marketingCompany when calling marketingGroupsIdCompaniesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.marketingCompany),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class GroupContactsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Delete Marketing Contact By Id
         * @param id
         * @param contactId
         */
        public marketingGroupsIdContactsContactIdDelete (params: {  id: number; contactId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/marketing/groups/{id}/contacts/{contactId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'contactId' + '}', String(params.contactId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdContactsContactIdDelete');
            }
            // verify required parameter 'contactId' is set
            if (params.contactId == null) {
                throw new Error('Missing required parameter contactId when calling marketingGroupsIdContactsContactIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Marketing Contact By Id
         * @param id
         * @param contactId
         */
        public marketingGroupsIdContactsContactIdGet (params: {  id: number; contactId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MarketingContact> {
            const localVarPath = this.basePath + '/marketing/groups/{id}/contacts/{contactId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'contactId' + '}', String(params.contactId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdContactsContactIdGet');
            }
            // verify required parameter 'contactId' is set
            if (params.contactId == null) {
                throw new Error('Missing required parameter contactId when calling marketingGroupsIdContactsContactIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Marketing Contact
         * @param id
         * @param contactId
         * @param operations
         */
        public marketingGroupsIdContactsContactIdPatch (params: {  id: number; contactId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MarketingContact> {
            const localVarPath = this.basePath + '/marketing/groups/{id}/contacts/{contactId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'contactId' + '}', String(params.contactId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdContactsContactIdPatch');
            }
            // verify required parameter 'contactId' is set
            if (params.contactId == null) {
                throw new Error('Missing required parameter contactId when calling marketingGroupsIdContactsContactIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling marketingGroupsIdContactsContactIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Marketing Contact
         * @param id
         * @param contactId
         * @param marketingContact
         */
        public marketingGroupsIdContactsContactIdPut (params: {  id: number; contactId: number; marketingContact: MarketingContact; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MarketingContact> {
            const localVarPath = this.basePath + '/marketing/groups/{id}/contacts/{contactId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'contactId' + '}', String(params.contactId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdContactsContactIdPut');
            }
            // verify required parameter 'contactId' is set
            if (params.contactId == null) {
                throw new Error('Missing required parameter contactId when calling marketingGroupsIdContactsContactIdPut');
            }
            // verify required parameter 'marketingContact' is set
            if (params.marketingContact == null) {
                throw new Error('Missing required parameter marketingContact when calling marketingGroupsIdContactsContactIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.marketingContact),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Marketing Contacts Count
         * @param id
         * @param conditions
         */
        public marketingGroupsIdContactsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/marketing/groups/{id}/contacts/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdContactsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Marketing Contacts
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public marketingGroupsIdContactsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<MarketingContact>> {
            const localVarPath = this.basePath + '/marketing/groups/{id}/contacts'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdContactsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Marketing Contact
         * @param id
         * @param marketingContact
         */
        public marketingGroupsIdContactsPost (params: {  id: number; marketingContact: MarketingContact; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MarketingContact> {
            const localVarPath = this.basePath + '/marketing/groups/{id}/contacts'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdContactsPost');
            }
            // verify required parameter 'marketingContact' is set
            if (params.marketingContact == null) {
                throw new Error('Missing required parameter marketingContact when calling marketingGroupsIdContactsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.marketingContact),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class GroupsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Groups Count
         * @param conditions
         */
        public marketingGroupsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/marketing/groups/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Groups
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public marketingGroupsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Group>> {
            const localVarPath = this.basePath + '/marketing/groups';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Group By Id
         * @param id
         */
        public marketingGroupsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/marketing/groups/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Group By Id
         * @param id
         */
        public marketingGroupsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Group> {
            const localVarPath = this.basePath + '/marketing/groups/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Group
         * @param id
         * @param operations
         */
        public marketingGroupsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Group> {
            const localVarPath = this.basePath + '/marketing/groups/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling marketingGroupsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Group
         * @param id
         * @param group
         */
        public marketingGroupsIdPut (params: {  id: number; group: Group; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Group> {
            const localVarPath = this.basePath + '/marketing/groups/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdPut');
            }
            // verify required parameter 'group' is set
            if (params.group == null) {
                throw new Error('Missing required parameter group when calling marketingGroupsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.group),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Group
         * @param group
         */
        public marketingGroupsPost (params: {  group: Group; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Group> {
            const localVarPath = this.basePath + '/marketing/groups';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'group' is set
            if (params.group == null) {
                throw new Error('Missing required parameter group when calling marketingGroupsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.group),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class InfoApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Infos
         */
        public systemInfoGet (params: {  }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Info> {
            const localVarPath = this.basePath + '/system/info';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class InvoicePaymentsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Payments
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeInvoicesIdPaymentsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Payment>> {
            const localVarPath = this.basePath + '/finance/invoices/{id}/payments'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeInvoicesIdPaymentsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Payment By Id
         * @param id
         * @param paymentId
         */
        public financeInvoicesIdPaymentsPaymentIdDelete (params: {  id: number; paymentId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/invoices/{id}/payments/{paymentId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'paymentId' + '}', String(params.paymentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeInvoicesIdPaymentsPaymentIdDelete');
            }
            // verify required parameter 'paymentId' is set
            if (params.paymentId == null) {
                throw new Error('Missing required parameter paymentId when calling financeInvoicesIdPaymentsPaymentIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Payment By Id
         * @param id
         * @param paymentId
         */
        public financeInvoicesIdPaymentsPaymentIdGet (params: {  id: number; paymentId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Payment> {
            const localVarPath = this.basePath + '/finance/invoices/{id}/payments/{paymentId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'paymentId' + '}', String(params.paymentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeInvoicesIdPaymentsPaymentIdGet');
            }
            // verify required parameter 'paymentId' is set
            if (params.paymentId == null) {
                throw new Error('Missing required parameter paymentId when calling financeInvoicesIdPaymentsPaymentIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Payment
         * @param id
         * @param paymentId
         * @param operations
         */
        public financeInvoicesIdPaymentsPaymentIdPatch (params: {  id: number; paymentId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Payment> {
            const localVarPath = this.basePath + '/finance/invoices/{id}/payments/{paymentId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'paymentId' + '}', String(params.paymentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeInvoicesIdPaymentsPaymentIdPatch');
            }
            // verify required parameter 'paymentId' is set
            if (params.paymentId == null) {
                throw new Error('Missing required parameter paymentId when calling financeInvoicesIdPaymentsPaymentIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeInvoicesIdPaymentsPaymentIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Payment
         * @param id
         * @param paymentId
         * @param payment
         */
        public financeInvoicesIdPaymentsPaymentIdPut (params: {  id: number; paymentId: number; payment: Payment; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Payment> {
            const localVarPath = this.basePath + '/finance/invoices/{id}/payments/{paymentId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'paymentId' + '}', String(params.paymentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeInvoicesIdPaymentsPaymentIdPut');
            }
            // verify required parameter 'paymentId' is set
            if (params.paymentId == null) {
                throw new Error('Missing required parameter paymentId when calling financeInvoicesIdPaymentsPaymentIdPut');
            }
            // verify required parameter 'payment' is set
            if (params.payment == null) {
                throw new Error('Missing required parameter payment when calling financeInvoicesIdPaymentsPaymentIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.payment),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Payment
         * @param id
         * @param payment
         */
        public financeInvoicesIdPaymentsPost (params: {  id: number; payment: Payment; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Payment> {
            const localVarPath = this.basePath + '/finance/invoices/{id}/payments'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeInvoicesIdPaymentsPost');
            }
            // verify required parameter 'payment' is set
            if (params.payment == null) {
                throw new Error('Missing required parameter payment when calling financeInvoicesIdPaymentsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.payment),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class InvoicesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Invoices Count
         * @param conditions
         * @param customFieldConditions
         */
        public financeInvoicesCountGet (params: {  conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/invoices/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.customFieldConditions !== undefined) {
                queryParameters['customFieldConditions'] = params.customFieldConditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Invoices
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeInvoicesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Invoice>> {
            const localVarPath = this.basePath + '/finance/invoices';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Invoice By Id
         * @param id
         */
        public financeInvoicesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/invoices/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeInvoicesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Invoice By Id
         * @param id
         */
        public financeInvoicesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Invoice> {
            const localVarPath = this.basePath + '/finance/invoices/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeInvoicesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Invoice
         * @param id
         * @param operations
         */
        public financeInvoicesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Invoice> {
            const localVarPath = this.basePath + '/finance/invoices/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeInvoicesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeInvoicesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Invoice Pdf
         * @param id
         */
        public financeInvoicesIdPdfGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/invoices/{id}/pdf'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeInvoicesIdPdfGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Invoice
         * @param id
         * @param invoice
         */
        public financeInvoicesIdPut (params: {  id: number; invoice: Invoice; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Invoice> {
            const localVarPath = this.basePath + '/finance/invoices/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeInvoicesIdPut');
            }
            // verify required parameter 'invoice' is set
            if (params.invoice == null) {
                throw new Error('Missing required parameter invoice when calling financeInvoicesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.invoice),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Invoice
         * @param invoice
         */
        public financeInvoicesPost (params: {  invoice: Invoice; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Invoice> {
            const localVarPath = this.basePath + '/finance/invoices';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'invoice' is set
            if (params.invoice == null) {
                throw new Error('Missing required parameter invoice when calling financeInvoicesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.invoice),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class KnowledgeBaseArticlesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Knowledge Base Articles Count
         * @param conditions
         * @param customFieldConditions
         */
        public serviceKnowledgeBaseArticlesCountGet (params: {  conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/knowledgeBaseArticles/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.customFieldConditions !== undefined) {
                queryParameters['customFieldConditions'] = params.customFieldConditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Knowledge Base Articles
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceKnowledgeBaseArticlesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<KnowledgeBaseArticle>> {
            const localVarPath = this.basePath + '/service/knowledgeBaseArticles';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Knowledge Base Article By Id
         * @param id
         */
        public serviceKnowledgeBaseArticlesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/knowledgeBaseArticles/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceKnowledgeBaseArticlesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Knowledge Base Article By Id
         * @param id
         */
        public serviceKnowledgeBaseArticlesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<KnowledgeBaseArticle> {
            const localVarPath = this.basePath + '/service/knowledgeBaseArticles/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceKnowledgeBaseArticlesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Knowledge Base Article
         * @param id
         * @param operations
         */
        public serviceKnowledgeBaseArticlesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<KnowledgeBaseArticle> {
            const localVarPath = this.basePath + '/service/knowledgeBaseArticles/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceKnowledgeBaseArticlesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceKnowledgeBaseArticlesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Knowledge Base Article
         * @param id
         * @param knowledgeBaseArticle
         */
        public serviceKnowledgeBaseArticlesIdPut (params: {  id: number; knowledgeBaseArticle: KnowledgeBaseArticle; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<KnowledgeBaseArticle> {
            const localVarPath = this.basePath + '/service/knowledgeBaseArticles/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceKnowledgeBaseArticlesIdPut');
            }
            // verify required parameter 'knowledgeBaseArticle' is set
            if (params.knowledgeBaseArticle == null) {
                throw new Error('Missing required parameter knowledgeBaseArticle when calling serviceKnowledgeBaseArticlesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.knowledgeBaseArticle),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Knowledge Base Article
         * @param knowledgeBaseArticle
         */
        public serviceKnowledgeBaseArticlesPost (params: {  knowledgeBaseArticle: KnowledgeBaseArticle; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<KnowledgeBaseArticle> {
            const localVarPath = this.basePath + '/service/knowledgeBaseArticles';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'knowledgeBaseArticle' is set
            if (params.knowledgeBaseArticle == null) {
                throw new Error('Missing required parameter knowledgeBaseArticle when calling serviceKnowledgeBaseArticlesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.knowledgeBaseArticle),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class LinksApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Links Count
         * @param conditions
         */
        public systemLinksCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/links/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Links
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemLinksGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Link>> {
            const localVarPath = this.basePath + '/system/links';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Link By Id
         * @param id
         */
        public systemLinksIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/links/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemLinksIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Link By Id
         * @param id
         */
        public systemLinksIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Link> {
            const localVarPath = this.basePath + '/system/links/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemLinksIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Link
         * @param id
         * @param operations
         */
        public systemLinksIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Link> {
            const localVarPath = this.basePath + '/system/links/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemLinksIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemLinksIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Link
         * @param id
         * @param link
         */
        public systemLinksIdPut (params: {  id: number; link: Link; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Link> {
            const localVarPath = this.basePath + '/system/links/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemLinksIdPut');
            }
            // verify required parameter 'link' is set
            if (params.link == null) {
                throw new Error('Missing required parameter link when calling systemLinksIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.link),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Link
         * @param link
         */
        public systemLinksPost (params: {  link: Link; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Link> {
            const localVarPath = this.basePath + '/system/links';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'link' is set
            if (params.link == null) {
                throw new Error('Missing required parameter link when calling systemLinksPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.link),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class LocationsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Create Locations Count
         * @param conditions
         */
        public serviceLocationsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/locations/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Locations
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceLocationsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Location>> {
            const localVarPath = this.basePath + '/service/locations';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Location By Id
         * @param id
         */
        public serviceLocationsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/locations/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceLocationsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Location By Id
         * @param id
         */
        public serviceLocationsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Location> {
            const localVarPath = this.basePath + '/service/locations/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceLocationsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Location
         * @param id
         * @param operations
         */
        public serviceLocationsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Location> {
            const localVarPath = this.basePath + '/service/locations/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceLocationsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceLocationsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Location
         * @param id
         * @param location
         */
        public serviceLocationsIdPut (params: {  id: number; location: Location; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Location> {
            const localVarPath = this.basePath + '/service/locations/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceLocationsIdPut');
            }
            // verify required parameter 'location' is set
            if (params.location == null) {
                throw new Error('Missing required parameter location when calling serviceLocationsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.location),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Location
         * @param location
         */
        public serviceLocationsPost (params: {  location: Location; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Location> {
            const localVarPath = this.basePath + '/service/locations';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'location' is set
            if (params.location == null) {
                throw new Error('Missing required parameter location when calling serviceLocationsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.location),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ManufacturersApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Manufacturers Count
         * @param conditions
         */
        public procurementManufacturersCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/manufacturers/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Manufacturers
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementManufacturersGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Manufacturer>> {
            const localVarPath = this.basePath + '/procurement/manufacturers';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Manufacturer By Id
         * @param id
         */
        public procurementManufacturersIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/manufacturers/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementManufacturersIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Manufacturer By Id
         * @param id
         */
        public procurementManufacturersIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Manufacturer> {
            const localVarPath = this.basePath + '/procurement/manufacturers/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementManufacturersIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Manufacturer
         * @param id
         * @param operations
         */
        public procurementManufacturersIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Manufacturer> {
            const localVarPath = this.basePath + '/procurement/manufacturers/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementManufacturersIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementManufacturersIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Manufacturer
         * @param id
         * @param manufacturer
         */
        public procurementManufacturersIdPut (params: {  id: number; manufacturer: Manufacturer; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Manufacturer> {
            const localVarPath = this.basePath + '/procurement/manufacturers/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementManufacturersIdPut');
            }
            // verify required parameter 'manufacturer' is set
            if (params.manufacturer == null) {
                throw new Error('Missing required parameter manufacturer when calling procurementManufacturersIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.manufacturer),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Manufacturer
         * @param manufacturer
         */
        public procurementManufacturersPost (params: {  manufacturer: Manufacturer; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Manufacturer> {
            const localVarPath = this.basePath + '/procurement/manufacturers';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'manufacturer' is set
            if (params.manufacturer == null) {
                throw new Error('Missing required parameter manufacturer when calling procurementManufacturersPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.manufacturer),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class MembersApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Members Count
         * @param conditions
         */
        public systemMembersCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/members/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Members
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemMembersGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Member>> {
            const localVarPath = this.basePath + '/system/members';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Member By Id
         * @param memberIdentifier
         */
        public systemMembersMemberIdentifierGet (params: {  memberIdentifier: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Member> {
            const localVarPath = this.basePath + '/system/members/{memberIdentifier}'
                .replace('{' + 'memberIdentifier' + '}', String(params.memberIdentifier));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'memberIdentifier' is set
            if (params.memberIdentifier == null) {
                throw new Error('Missing required parameter memberIdentifier when calling systemMembersMemberIdentifierGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Member Image
         * @param memberIdentifier
         * @param useDefaultFlag
         * @param lastmodified
         */
        public systemMembersMemberIdentifierImageGet (params: {  memberIdentifier: string; useDefaultFlag?: boolean; lastmodified?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/members/{memberIdentifier}/image'
                .replace('{' + 'memberIdentifier' + '}', String(params.memberIdentifier));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'memberIdentifier' is set
            if (params.memberIdentifier == null) {
                throw new Error('Missing required parameter memberIdentifier when calling systemMembersMemberIdentifierImageGet');
            }
            if (params.useDefaultFlag !== undefined) {
                queryParameters['useDefaultFlag'] = params.useDefaultFlag;
            }

            if (params.lastmodified !== undefined) {
                queryParameters['lastmodified'] = params.lastmodified;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Token By Member Identifier
         * @param memberIdentifier
         */
        public systemMembersMemberIdentifierTokensPost (params: {  memberIdentifier: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Token> {
            const localVarPath = this.basePath + '/system/members/{memberIdentifier}/tokens'
                .replace('{' + 'memberIdentifier' + '}', String(params.memberIdentifier));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'memberIdentifier' is set
            if (params.memberIdentifier == null) {
                throw new Error('Missing required parameter memberIdentifier when calling systemMembersMemberIdentifierTokensPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class MenuEntriesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Menu Entries Count
         * @param conditions
         */
        public systemMenuentriesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/menuentries/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Menu Entries
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemMenuentriesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<MenuEntry>> {
            const localVarPath = this.basePath + '/system/menuentries';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Menu Entry By Id
         * @param id
         */
        public systemMenuentriesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/menuentries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMenuentriesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Menu Entry By Id
         * @param id
         */
        public systemMenuentriesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MenuEntry> {
            const localVarPath = this.basePath + '/system/menuentries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMenuentriesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Menu Entry Image
         * @param id
         * @param lastmodified
         * @param largeFlag
         */
        public systemMenuentriesIdImageGet (params: {  id: number; lastmodified?: string; largeFlag?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/menuentries/{id}/image'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMenuentriesIdImageGet');
            }
            if (params.lastmodified !== undefined) {
                queryParameters['lastmodified'] = params.lastmodified;
            }

            if (params.largeFlag !== undefined) {
                queryParameters['largeFlag'] = params.largeFlag;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Upload Menu Entry Image
         * @param id
         * @param file File to upload
         */
        public systemMenuentriesIdImagePost (params: {  id: number; file?: any; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/menuentries/{id}/image'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            let formParams: any = {};
            headerParams['Content-Type'] = 'application/x-www-form-urlencoded';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMenuentriesIdImagePost');
            }
            formParams['file'] = params.file;

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                                body: querystring.stringify(formParams),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Menu Entry
         * @param id
         * @param operations
         */
        public systemMenuentriesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MenuEntry> {
            const localVarPath = this.basePath + '/system/menuentries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMenuentriesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemMenuentriesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Menu Entry
         * @param id
         * @param menuEntry
         */
        public systemMenuentriesIdPut (params: {  id: number; menuEntry: MenuEntry; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MenuEntry> {
            const localVarPath = this.basePath + '/system/menuentries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMenuentriesIdPut');
            }
            // verify required parameter 'menuEntry' is set
            if (params.menuEntry == null) {
                throw new Error('Missing required parameter menuEntry when calling systemMenuentriesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.menuEntry),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Menu Entry
         * @param menuEntry
         */
        public systemMenuentriesPost (params: {  menuEntry: MenuEntry; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MenuEntry> {
            const localVarPath = this.basePath + '/system/menuentries';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'menuEntry' is set
            if (params.menuEntry == null) {
                throw new Error('Missing required parameter menuEntry when calling systemMenuentriesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.menuEntry),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class OpportunitiesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Opportunities Count
         * @param conditions
         * @param customFieldConditions
         */
        public salesOpportunitiesCountGet (params: {  conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/sales/opportunities/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.customFieldConditions !== undefined) {
                queryParameters['customFieldConditions'] = params.customFieldConditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Opportunities
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public salesOpportunitiesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Opportunity>> {
            const localVarPath = this.basePath + '/sales/opportunities';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Convert Opportunity To Agreement
         * @param id
         * @param conversion
         */
        public salesOpportunitiesIdConvertToAgreementPost (params: {  id: number; conversion: OpportunityToAgreementConversion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Agreement> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/convertToAgreement'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdConvertToAgreementPost');
            }
            // verify required parameter 'conversion' is set
            if (params.conversion == null) {
                throw new Error('Missing required parameter conversion when calling salesOpportunitiesIdConvertToAgreementPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.conversion),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Convert Opportunity To Project
         * @param id
         * @param conversion
         */
        public salesOpportunitiesIdConvertToProjectPost (params: {  id: number; conversion: OpportunityToProjectConversion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Project> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/convertToProject'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdConvertToProjectPost');
            }
            // verify required parameter 'conversion' is set
            if (params.conversion == null) {
                throw new Error('Missing required parameter conversion when calling salesOpportunitiesIdConvertToProjectPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.conversion),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Convert Opportunity To Sales Order
         * @param id
         * @param conversion
         */
        public salesOpportunitiesIdConvertToSalesOrderPost (params: {  id: number; conversion: OpportunityToSalesOrderConversion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Order> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/convertToSalesOrder'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdConvertToSalesOrderPost');
            }
            // verify required parameter 'conversion' is set
            if (params.conversion == null) {
                throw new Error('Missing required parameter conversion when calling salesOpportunitiesIdConvertToSalesOrderPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.conversion),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Convert Opportunity To Service Ticket
         * @param id
         * @param conversion
         */
        public salesOpportunitiesIdConvertToServiceTicketPost (params: {  id: number; conversion: OpportunityToServiceTicketConversion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Ticket> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/convertToServiceTicket'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdConvertToServiceTicketPost');
            }
            // verify required parameter 'conversion' is set
            if (params.conversion == null) {
                throw new Error('Missing required parameter conversion when calling salesOpportunitiesIdConvertToServiceTicketPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.conversion),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Opportunity By Id
         * @param id
         */
        public salesOpportunitiesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Opportunity By Id
         * @param id
         */
        public salesOpportunitiesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Opportunity> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Opportunity
         * @param id
         * @param operations
         */
        public salesOpportunitiesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Opportunity> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling salesOpportunitiesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Opportunity
         * @param id
         * @param opportunity
         */
        public salesOpportunitiesIdPut (params: {  id: number; opportunity: Opportunity; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Opportunity> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdPut');
            }
            // verify required parameter 'opportunity' is set
            if (params.opportunity == null) {
                throw new Error('Missing required parameter opportunity when calling salesOpportunitiesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.opportunity),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Opportunity
         * @param opportunity
         */
        public salesOpportunitiesPost (params: {  opportunity: Opportunity; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Opportunity> {
            const localVarPath = this.basePath + '/sales/opportunities';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'opportunity' is set
            if (params.opportunity == null) {
                throw new Error('Missing required parameter opportunity when calling salesOpportunitiesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.opportunity),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class OpportunityContactsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Delete Opportunity Contact By Id
         * @param id
         * @param contactId
         */
        public salesOpportunitiesIdContactsContactIdDelete (params: {  id: number; contactId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/contacts/{contactId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'contactId' + '}', String(params.contactId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdContactsContactIdDelete');
            }
            // verify required parameter 'contactId' is set
            if (params.contactId == null) {
                throw new Error('Missing required parameter contactId when calling salesOpportunitiesIdContactsContactIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Opportunity Contact By Id
         * @param id
         * @param contactId
         */
        public salesOpportunitiesIdContactsContactIdGet (params: {  id: number; contactId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityContact> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/contacts/{contactId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'contactId' + '}', String(params.contactId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdContactsContactIdGet');
            }
            // verify required parameter 'contactId' is set
            if (params.contactId == null) {
                throw new Error('Missing required parameter contactId when calling salesOpportunitiesIdContactsContactIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Opportunity Contact
         * @param id
         * @param contactId
         * @param operations
         */
        public salesOpportunitiesIdContactsContactIdPatch (params: {  id: number; contactId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityContact> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/contacts/{contactId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'contactId' + '}', String(params.contactId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdContactsContactIdPatch');
            }
            // verify required parameter 'contactId' is set
            if (params.contactId == null) {
                throw new Error('Missing required parameter contactId when calling salesOpportunitiesIdContactsContactIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling salesOpportunitiesIdContactsContactIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Opportunity Contact
         * @param id
         * @param contactId
         * @param opportunityContact
         */
        public salesOpportunitiesIdContactsContactIdPut (params: {  id: number; contactId: number; opportunityContact: OpportunityContact; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityContact> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/contacts/{contactId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'contactId' + '}', String(params.contactId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdContactsContactIdPut');
            }
            // verify required parameter 'contactId' is set
            if (params.contactId == null) {
                throw new Error('Missing required parameter contactId when calling salesOpportunitiesIdContactsContactIdPut');
            }
            // verify required parameter 'opportunityContact' is set
            if (params.opportunityContact == null) {
                throw new Error('Missing required parameter opportunityContact when calling salesOpportunitiesIdContactsContactIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.opportunityContact),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Opportunity Contacts Count
         * @param id
         * @param conditions
         */
        public salesOpportunitiesIdContactsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/contacts/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdContactsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Opportunity Contacts
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public salesOpportunitiesIdContactsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<OpportunityContact>> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/contacts'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdContactsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Opportunity Contact
         * @param id
         * @param opportunityContact
         */
        public salesOpportunitiesIdContactsPost (params: {  id: number; opportunityContact: OpportunityContact; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityContact> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/contacts'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdContactsPost');
            }
            // verify required parameter 'opportunityContact' is set
            if (params.opportunityContact == null) {
                throw new Error('Missing required parameter opportunityContact when calling salesOpportunitiesIdContactsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.opportunityContact),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class OpportunityForecastsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Forecasts Count
         * @param id
         * @param conditions
         */
        public salesOpportunitiesIdForecastCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/forecast/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdForecastCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Forecast By Id
         * @param id
         * @param forecastId
         */
        public salesOpportunitiesIdForecastForecastIdDelete (params: {  id: number; forecastId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/forecast/{forecastId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'forecastId' + '}', String(params.forecastId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdForecastForecastIdDelete');
            }
            // verify required parameter 'forecastId' is set
            if (params.forecastId == null) {
                throw new Error('Missing required parameter forecastId when calling salesOpportunitiesIdForecastForecastIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Forecast By Id
         * @param id
         * @param forecastId
         */
        public salesOpportunitiesIdForecastForecastIdGet (params: {  id: number; forecastId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Forecast> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/forecast/{forecastId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'forecastId' + '}', String(params.forecastId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdForecastForecastIdGet');
            }
            // verify required parameter 'forecastId' is set
            if (params.forecastId == null) {
                throw new Error('Missing required parameter forecastId when calling salesOpportunitiesIdForecastForecastIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Forecast
         * @param id
         * @param forecastId
         * @param operations
         */
        public salesOpportunitiesIdForecastForecastIdPatch (params: {  id: number; forecastId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Forecast> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/forecast/{forecastId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'forecastId' + '}', String(params.forecastId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdForecastForecastIdPatch');
            }
            // verify required parameter 'forecastId' is set
            if (params.forecastId == null) {
                throw new Error('Missing required parameter forecastId when calling salesOpportunitiesIdForecastForecastIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling salesOpportunitiesIdForecastForecastIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Forecast
         * @param id
         * @param forecastId
         * @param forecast
         */
        public salesOpportunitiesIdForecastForecastIdPut (params: {  id: number; forecastId: number; forecast: Forecast; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Forecast> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/forecast/{forecastId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'forecastId' + '}', String(params.forecastId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdForecastForecastIdPut');
            }
            // verify required parameter 'forecastId' is set
            if (params.forecastId == null) {
                throw new Error('Missing required parameter forecastId when calling salesOpportunitiesIdForecastForecastIdPut');
            }
            // verify required parameter 'forecast' is set
            if (params.forecast == null) {
                throw new Error('Missing required parameter forecast when calling salesOpportunitiesIdForecastForecastIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.forecast),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Forecasts
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public salesOpportunitiesIdForecastGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Forecast>> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/forecast'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdForecastGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Forecast
         * @param id
         * @param forecast
         */
        public salesOpportunitiesIdForecastPost (params: {  id: number; forecast: Forecast; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Forecast> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/forecast'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdForecastPost');
            }
            // verify required parameter 'forecast' is set
            if (params.forecast == null) {
                throw new Error('Missing required parameter forecast when calling salesOpportunitiesIdForecastPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.forecast),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class OpportunityNotesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Opportunity Notes Count
         * @param id
         * @param conditions
         */
        public salesOpportunitiesIdNotesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<OpportunityNote>> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/notes/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdNotesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Opportunity Notes
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public salesOpportunitiesIdNotesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<OpportunityNote>> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/notes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdNotesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Opportunity Note By Id
         * @param id
         * @param noteId
         */
        public salesOpportunitiesIdNotesNoteIdDelete (params: {  id: number; noteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdNotesNoteIdDelete');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling salesOpportunitiesIdNotesNoteIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Opportunity Note By Id
         * @param id
         * @param noteId
         */
        public salesOpportunitiesIdNotesNoteIdGet (params: {  id: number; noteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityNote> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdNotesNoteIdGet');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling salesOpportunitiesIdNotesNoteIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Opportunity Note
         * @param id
         * @param noteId
         * @param operations
         */
        public salesOpportunitiesIdNotesNoteIdPatch (params: {  id: number; noteId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityNote> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdNotesNoteIdPatch');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling salesOpportunitiesIdNotesNoteIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling salesOpportunitiesIdNotesNoteIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Opportunity Note
         * @param id
         * @param noteId
         * @param note
         */
        public salesOpportunitiesIdNotesNoteIdPut (params: {  id: number; noteId: number; note: OpportunityNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityNote> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdNotesNoteIdPut');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling salesOpportunitiesIdNotesNoteIdPut');
            }
            // verify required parameter 'note' is set
            if (params.note == null) {
                throw new Error('Missing required parameter note when calling salesOpportunitiesIdNotesNoteIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.note),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Opportunity Note
         * @param id
         * @param note
         */
        public salesOpportunitiesIdNotesPost (params: {  id: number; note: OpportunityNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityNote> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/notes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdNotesPost');
            }
            // verify required parameter 'note' is set
            if (params.note == null) {
                throw new Error('Missing required parameter note when calling salesOpportunitiesIdNotesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.note),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class OpportunityRatingsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Opportunity Ratings Count
         * @param conditions
         */
        public salesOpportunitiesRatingsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/sales/opportunities/ratings/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Opportunity Ratings
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public salesOpportunitiesRatingsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<OpportunityRating>> {
            const localVarPath = this.basePath + '/sales/opportunities/ratings';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Opportunity Rating By Id
         * @param id
         */
        public salesOpportunitiesRatingsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/sales/opportunities/ratings/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesRatingsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Opportunity Rating By Id
         * @param id
         */
        public salesOpportunitiesRatingsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityRating> {
            const localVarPath = this.basePath + '/sales/opportunities/ratings/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesRatingsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Opportunity Rating
         * @param id
         * @param operations
         */
        public salesOpportunitiesRatingsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityRating> {
            const localVarPath = this.basePath + '/sales/opportunities/ratings/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesRatingsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling salesOpportunitiesRatingsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Opportunity Rating
         * @param id
         * @param opportunityRating
         */
        public salesOpportunitiesRatingsIdPut (params: {  id: number; opportunityRating: OpportunityRating; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityRating> {
            const localVarPath = this.basePath + '/sales/opportunities/ratings/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesRatingsIdPut');
            }
            // verify required parameter 'opportunityRating' is set
            if (params.opportunityRating == null) {
                throw new Error('Missing required parameter opportunityRating when calling salesOpportunitiesRatingsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.opportunityRating),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Opportunity Rating
         * @param opportunityRating
         */
        public salesOpportunitiesRatingsPost (params: {  opportunityRating: OpportunityRating; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityRating> {
            const localVarPath = this.basePath + '/sales/opportunities/ratings';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'opportunityRating' is set
            if (params.opportunityRating == null) {
                throw new Error('Missing required parameter opportunityRating when calling salesOpportunitiesRatingsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.opportunityRating),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class OpportunityStatusesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Statuses Count
         * @param conditions
         */
        public salesOpportunitiesStatusesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/sales/opportunities/statuses/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Statuses
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public salesOpportunitiesStatusesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<OpportunityStatus>> {
            const localVarPath = this.basePath + '/sales/opportunities/statuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Status By Id
         * @param id
         */
        public salesOpportunitiesStatusesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/sales/opportunities/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesStatusesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Status By Id
         * @param id
         */
        public salesOpportunitiesStatusesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityStatus> {
            const localVarPath = this.basePath + '/sales/opportunities/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesStatusesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Status
         * @param id
         * @param operations
         */
        public salesOpportunitiesStatusesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityStatus> {
            const localVarPath = this.basePath + '/sales/opportunities/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesStatusesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling salesOpportunitiesStatusesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Status
         * @param id
         * @param status
         */
        public salesOpportunitiesStatusesIdPut (params: {  id: number; status: OpportunityStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityStatus> {
            const localVarPath = this.basePath + '/sales/opportunities/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesStatusesIdPut');
            }
            // verify required parameter 'status' is set
            if (params.status == null) {
                throw new Error('Missing required parameter status when calling salesOpportunitiesStatusesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.status),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Status
         * @param status
         */
        public salesOpportunitiesStatusesPost (params: {  status: OpportunityStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityStatus> {
            const localVarPath = this.basePath + '/sales/opportunities/statuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'status' is set
            if (params.status == null) {
                throw new Error('Missing required parameter status when calling salesOpportunitiesStatusesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.status),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class OpportunityTeamsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Teams Count
         * @param id
         * @param conditions
         */
        public salesOpportunitiesIdTeamCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/team/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdTeamCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Teams
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public salesOpportunitiesIdTeamGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Team>> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/team'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdTeamGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Team
         * @param id
         * @param team
         */
        public salesOpportunitiesIdTeamPost (params: {  id: number; team: Team; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Team> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/team'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdTeamPost');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling salesOpportunitiesIdTeamPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.team),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Team By Id
         * @param id
         * @param teamId
         */
        public salesOpportunitiesIdTeamTeamIdDelete (params: {  id: number; teamId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/team/{teamId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'teamId' + '}', String(params.teamId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdTeamTeamIdDelete');
            }
            // verify required parameter 'teamId' is set
            if (params.teamId == null) {
                throw new Error('Missing required parameter teamId when calling salesOpportunitiesIdTeamTeamIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Team By Id
         * @param id
         * @param teamId
         */
        public salesOpportunitiesIdTeamTeamIdGet (params: {  id: number; teamId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Team> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/team/{teamId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'teamId' + '}', String(params.teamId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdTeamTeamIdGet');
            }
            // verify required parameter 'teamId' is set
            if (params.teamId == null) {
                throw new Error('Missing required parameter teamId when calling salesOpportunitiesIdTeamTeamIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Team
         * @param id
         * @param teamId
         * @param operations
         */
        public salesOpportunitiesIdTeamTeamIdPatch (params: {  id: number; teamId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Team> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/team/{teamId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'teamId' + '}', String(params.teamId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdTeamTeamIdPatch');
            }
            // verify required parameter 'teamId' is set
            if (params.teamId == null) {
                throw new Error('Missing required parameter teamId when calling salesOpportunitiesIdTeamTeamIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling salesOpportunitiesIdTeamTeamIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Team
         * @param id
         * @param teamId
         * @param team
         */
        public salesOpportunitiesIdTeamTeamIdPut (params: {  id: number; teamId: number; team: Team; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Team> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/team/{teamId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'teamId' + '}', String(params.teamId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdTeamTeamIdPut');
            }
            // verify required parameter 'teamId' is set
            if (params.teamId == null) {
                throw new Error('Missing required parameter teamId when calling salesOpportunitiesIdTeamTeamIdPut');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling salesOpportunitiesIdTeamTeamIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.team),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class OpportunityTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Opportunity Types Count
         * @param conditions
         */
        public salesOpportunitiesTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/sales/opportunities/types/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Opportunity Types
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public salesOpportunitiesTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<OpportunityType>> {
            const localVarPath = this.basePath + '/sales/opportunities/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Opportunity Type By Id
         * @param id
         */
        public salesOpportunitiesTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/sales/opportunities/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesTypesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Opportunity Type By Id
         * @param id
         */
        public salesOpportunitiesTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityType> {
            const localVarPath = this.basePath + '/sales/opportunities/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesTypesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Opportunity Type
         * @param id
         * @param operations
         */
        public salesOpportunitiesTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityType> {
            const localVarPath = this.basePath + '/sales/opportunities/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesTypesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling salesOpportunitiesTypesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Opportunity Type
         * @param id
         * @param opportunityType
         */
        public salesOpportunitiesTypesIdPut (params: {  id: number; opportunityType: OpportunityType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityType> {
            const localVarPath = this.basePath + '/sales/opportunities/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesTypesIdPut');
            }
            // verify required parameter 'opportunityType' is set
            if (params.opportunityType == null) {
                throw new Error('Missing required parameter opportunityType when calling salesOpportunitiesTypesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.opportunityType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Opportunity Type
         * @param opportunityType
         */
        public salesOpportunitiesTypesPost (params: {  opportunityType: OpportunityType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityType> {
            const localVarPath = this.basePath + '/sales/opportunities/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'opportunityType' is set
            if (params.opportunityType == null) {
                throw new Error('Missing required parameter opportunityType when calling salesOpportunitiesTypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.opportunityType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class OrderStatusesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Order Statuses Count
         * @param conditions
         */
        public salesOrdersStatusesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/sales/orders/statuses/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Order Statuses
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public salesOrdersStatusesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<OrderStatus>> {
            const localVarPath = this.basePath + '/sales/orders/statuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Order Status By Id
         * @param id
         */
        public salesOrdersStatusesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/sales/orders/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOrdersStatusesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Order Status By Id
         * @param id
         */
        public salesOrdersStatusesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OrderStatus> {
            const localVarPath = this.basePath + '/sales/orders/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOrdersStatusesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Order Status
         * @param id
         * @param operations
         */
        public salesOrdersStatusesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OrderStatus> {
            const localVarPath = this.basePath + '/sales/orders/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOrdersStatusesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling salesOrdersStatusesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Order Status
         * @param id
         * @param status
         */
        public salesOrdersStatusesIdPut (params: {  id: number; status: OrderStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OrderStatus> {
            const localVarPath = this.basePath + '/sales/orders/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOrdersStatusesIdPut');
            }
            // verify required parameter 'status' is set
            if (params.status == null) {
                throw new Error('Missing required parameter status when calling salesOrdersStatusesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.status),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Order Status
         * @param status
         */
        public salesOrdersStatusesPost (params: {  status: OrderStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<OrderStatus>> {
            const localVarPath = this.basePath + '/sales/orders/statuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'status' is set
            if (params.status == null) {
                throw new Error('Missing required parameter status when calling salesOrdersStatusesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.status),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class OrdersApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Sales Orders Count
         * @param conditions
         * @param customFieldConditions
         */
        public salesOrdersCountGet (params: {  conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/sales/orders/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.customFieldConditions !== undefined) {
                queryParameters['customFieldConditions'] = params.customFieldConditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Sales Orders
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public salesOrdersGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Order>> {
            const localVarPath = this.basePath + '/sales/orders';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Sales Order By Id
         * @param id
         */
        public salesOrdersIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/sales/orders/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOrdersIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Sales Order By Id
         * @param id
         */
        public salesOrdersIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Order> {
            const localVarPath = this.basePath + '/sales/orders/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOrdersIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Sales Order
         * @param id
         * @param operations
         */
        public salesOrdersIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Order> {
            const localVarPath = this.basePath + '/sales/orders/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOrdersIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling salesOrdersIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Sales Order
         * @param id
         * @param order
         */
        public salesOrdersIdPut (params: {  id: number; order: Order; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Order> {
            const localVarPath = this.basePath + '/sales/orders/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOrdersIdPut');
            }
            // verify required parameter 'order' is set
            if (params.order == null) {
                throw new Error('Missing required parameter order when calling salesOrdersIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.order),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Sales Order
         * @param order
         */
        public salesOrdersPost (params: {  order: Order; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Order>> {
            const localVarPath = this.basePath + '/sales/orders';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'order' is set
            if (params.order == null) {
                throw new Error('Missing required parameter order when calling salesOrdersPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.order),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PricingBreaksApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Delete Pricing Break By Id
         * @param schedId
         * @param detailId
         * @param breakId
         */
        public procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdDelete (params: {  schedId: number; detailId: number; breakId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{schedId}/details/{detailId}/breaks/{breakId}'
                .replace('{' + 'schedId' + '}', String(params.schedId))
                .replace('{' + 'detailId' + '}', String(params.detailId))
                .replace('{' + 'breakId' + '}', String(params.breakId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'schedId' is set
            if (params.schedId == null) {
                throw new Error('Missing required parameter schedId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdDelete');
            }
            // verify required parameter 'detailId' is set
            if (params.detailId == null) {
                throw new Error('Missing required parameter detailId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdDelete');
            }
            // verify required parameter 'breakId' is set
            if (params.breakId == null) {
                throw new Error('Missing required parameter breakId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Pricing Break By Id
         * @param schedId
         * @param detailId
         * @param breakId
         */
        public procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdGet (params: {  schedId: number; detailId: number; breakId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingBreak> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{schedId}/details/{detailId}/breaks/{breakId}'
                .replace('{' + 'schedId' + '}', String(params.schedId))
                .replace('{' + 'detailId' + '}', String(params.detailId))
                .replace('{' + 'breakId' + '}', String(params.breakId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'schedId' is set
            if (params.schedId == null) {
                throw new Error('Missing required parameter schedId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdGet');
            }
            // verify required parameter 'detailId' is set
            if (params.detailId == null) {
                throw new Error('Missing required parameter detailId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdGet');
            }
            // verify required parameter 'breakId' is set
            if (params.breakId == null) {
                throw new Error('Missing required parameter breakId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Pricing Break
         * @param schedId
         * @param detailId
         * @param breakId
         * @param operations
         */
        public procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdPatch (params: {  schedId: number; detailId: number; breakId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingBreak> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{schedId}/details/{detailId}/breaks/{breakId}'
                .replace('{' + 'schedId' + '}', String(params.schedId))
                .replace('{' + 'detailId' + '}', String(params.detailId))
                .replace('{' + 'breakId' + '}', String(params.breakId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'schedId' is set
            if (params.schedId == null) {
                throw new Error('Missing required parameter schedId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdPatch');
            }
            // verify required parameter 'detailId' is set
            if (params.detailId == null) {
                throw new Error('Missing required parameter detailId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdPatch');
            }
            // verify required parameter 'breakId' is set
            if (params.breakId == null) {
                throw new Error('Missing required parameter breakId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Pricing Break
         * @param schedId
         * @param detailId
         * @param breakId
         * @param pricingBreak
         */
        public procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdPut (params: {  schedId: number; detailId: number; breakId: number; pricingBreak: PricingBreak; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingBreak> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{schedId}/details/{detailId}/breaks/{breakId}'
                .replace('{' + 'schedId' + '}', String(params.schedId))
                .replace('{' + 'detailId' + '}', String(params.detailId))
                .replace('{' + 'breakId' + '}', String(params.breakId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'schedId' is set
            if (params.schedId == null) {
                throw new Error('Missing required parameter schedId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdPut');
            }
            // verify required parameter 'detailId' is set
            if (params.detailId == null) {
                throw new Error('Missing required parameter detailId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdPut');
            }
            // verify required parameter 'breakId' is set
            if (params.breakId == null) {
                throw new Error('Missing required parameter breakId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdPut');
            }
            // verify required parameter 'pricingBreak' is set
            if (params.pricingBreak == null) {
                throw new Error('Missing required parameter pricingBreak when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.pricingBreak),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Pricing Break Count
         * @param schedId
         * @param detailId
         * @param conditions
         */
        public procurementPricingschedulesSchedIdDetailsDetailIdBreaksCountGet (params: {  schedId: number; detailId: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{schedId}/details/{detailId}/breaks/count'
                .replace('{' + 'schedId' + '}', String(params.schedId))
                .replace('{' + 'detailId' + '}', String(params.detailId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'schedId' is set
            if (params.schedId == null) {
                throw new Error('Missing required parameter schedId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksCountGet');
            }
            // verify required parameter 'detailId' is set
            if (params.detailId == null) {
                throw new Error('Missing required parameter detailId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Pricing Break
         * @param schedId
         * @param detailId
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementPricingschedulesSchedIdDetailsDetailIdBreaksGet (params: {  schedId: number; detailId: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<PricingBreak>> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{schedId}/details/{detailId}/breaks'
                .replace('{' + 'schedId' + '}', String(params.schedId))
                .replace('{' + 'detailId' + '}', String(params.detailId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'schedId' is set
            if (params.schedId == null) {
                throw new Error('Missing required parameter schedId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksGet');
            }
            // verify required parameter 'detailId' is set
            if (params.detailId == null) {
                throw new Error('Missing required parameter detailId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Pricing Break
         * @param schedId
         * @param detailId
         * @param pricingBreak
         */
        public procurementPricingschedulesSchedIdDetailsDetailIdBreaksPost (params: {  schedId: number; detailId: number; pricingBreak: PricingBreak; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingBreak> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{schedId}/details/{detailId}/breaks'
                .replace('{' + 'schedId' + '}', String(params.schedId))
                .replace('{' + 'detailId' + '}', String(params.detailId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'schedId' is set
            if (params.schedId == null) {
                throw new Error('Missing required parameter schedId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksPost');
            }
            // verify required parameter 'detailId' is set
            if (params.detailId == null) {
                throw new Error('Missing required parameter detailId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksPost');
            }
            // verify required parameter 'pricingBreak' is set
            if (params.pricingBreak == null) {
                throw new Error('Missing required parameter pricingBreak when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.pricingBreak),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PricingDetailsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Pricing Detail Count
         * @param id
         * @param conditions
         */
        public procurementPricingschedulesIdDetailsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{id}/details/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPricingschedulesIdDetailsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Pricing Detail By Id
         * @param id
         * @param detailID
         */
        public procurementPricingschedulesIdDetailsDetailIDDelete (params: {  id: number; detailID: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{id}/details/{detailID}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'detailID' + '}', String(params.detailID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPricingschedulesIdDetailsDetailIDDelete');
            }
            // verify required parameter 'detailID' is set
            if (params.detailID == null) {
                throw new Error('Missing required parameter detailID when calling procurementPricingschedulesIdDetailsDetailIDDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Pricing Detail By Id
         * @param id
         * @param detailID
         */
        public procurementPricingschedulesIdDetailsDetailIDGet (params: {  id: number; detailID: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingDetail> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{id}/details/{detailID}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'detailID' + '}', String(params.detailID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPricingschedulesIdDetailsDetailIDGet');
            }
            // verify required parameter 'detailID' is set
            if (params.detailID == null) {
                throw new Error('Missing required parameter detailID when calling procurementPricingschedulesIdDetailsDetailIDGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Pricing Detail
         * @param id
         * @param detailID
         * @param operations
         */
        public procurementPricingschedulesIdDetailsDetailIDPatch (params: {  id: number; detailID: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingDetail> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{id}/details/{detailID}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'detailID' + '}', String(params.detailID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPricingschedulesIdDetailsDetailIDPatch');
            }
            // verify required parameter 'detailID' is set
            if (params.detailID == null) {
                throw new Error('Missing required parameter detailID when calling procurementPricingschedulesIdDetailsDetailIDPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementPricingschedulesIdDetailsDetailIDPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Pricing Detail
         * @param id
         * @param detailID
         * @param pricingDetail
         */
        public procurementPricingschedulesIdDetailsDetailIDPut (params: {  id: number; detailID: number; pricingDetail: PricingDetail; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingDetail> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{id}/details/{detailID}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'detailID' + '}', String(params.detailID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPricingschedulesIdDetailsDetailIDPut');
            }
            // verify required parameter 'detailID' is set
            if (params.detailID == null) {
                throw new Error('Missing required parameter detailID when calling procurementPricingschedulesIdDetailsDetailIDPut');
            }
            // verify required parameter 'pricingDetail' is set
            if (params.pricingDetail == null) {
                throw new Error('Missing required parameter pricingDetail when calling procurementPricingschedulesIdDetailsDetailIDPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.pricingDetail),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Pricing Detail
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementPricingschedulesIdDetailsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<PricingDetail>> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{id}/details'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPricingschedulesIdDetailsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Pricing Detail
         * @param id
         * @param pricingDetail
         */
        public procurementPricingschedulesIdDetailsPost (params: {  id: number; pricingDetail: PricingDetail; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingDetail> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{id}/details'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPricingschedulesIdDetailsPost');
            }
            // verify required parameter 'pricingDetail' is set
            if (params.pricingDetail == null) {
                throw new Error('Missing required parameter pricingDetail when calling procurementPricingschedulesIdDetailsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.pricingDetail),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PricingSchedulesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Pricing Schedules Count
         * @param conditions
         */
        public procurementPricingschedulesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Pricing Schedules
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementPricingschedulesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<PricingSchedule>> {
            const localVarPath = this.basePath + '/procurement/pricingschedules';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Pricing Schedule By Id
         * @param id
         */
        public procurementPricingschedulesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPricingschedulesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Pricing Schedule By Id
         * @param id
         */
        public procurementPricingschedulesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingSchedule> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPricingschedulesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Pricing Schedule
         * @param id
         * @param operations
         */
        public procurementPricingschedulesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingSchedule> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPricingschedulesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementPricingschedulesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Pricing Schedule
         * @param id
         * @param pricingSchedule
         */
        public procurementPricingschedulesIdPut (params: {  id: number; pricingSchedule: PricingSchedule; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingSchedule> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPricingschedulesIdPut');
            }
            // verify required parameter 'pricingSchedule' is set
            if (params.pricingSchedule == null) {
                throw new Error('Missing required parameter pricingSchedule when calling procurementPricingschedulesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.pricingSchedule),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Pricing Schedule
         * @param pricingSchedule
         */
        public procurementPricingschedulesPost (params: {  pricingSchedule: PricingSchedule; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingSchedule> {
            const localVarPath = this.basePath + '/procurement/pricingschedules';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'pricingSchedule' is set
            if (params.pricingSchedule == null) {
                throw new Error('Missing required parameter pricingSchedule when calling procurementPricingschedulesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.pricingSchedule),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PrioritiesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Create Priorities Count
         * @param conditions
         */
        public servicePrioritiesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/priorities/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Priorities
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public servicePrioritiesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Priority>> {
            const localVarPath = this.basePath + '/service/priorities';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Priority By Id
         * @param id
         */
        public servicePrioritiesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/priorities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling servicePrioritiesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Priority By Id
         * @param id
         */
        public servicePrioritiesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Priority> {
            const localVarPath = this.basePath + '/service/priorities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling servicePrioritiesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Priority Image
         * @param id
         * @param useDefaultFlag
         * @param lastModified
         */
        public servicePrioritiesIdImageGet (params: {  id: number; useDefaultFlag?: boolean; lastModified?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/priorities/{id}/image'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling servicePrioritiesIdImageGet');
            }
            if (params.useDefaultFlag !== undefined) {
                queryParameters['useDefaultFlag'] = params.useDefaultFlag;
            }

            if (params.lastModified !== undefined) {
                queryParameters['lastModified'] = params.lastModified;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Priority
         * @param id
         * @param operations
         */
        public servicePrioritiesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Priority> {
            const localVarPath = this.basePath + '/service/priorities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling servicePrioritiesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling servicePrioritiesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Priority
         * @param id
         * @param priority
         */
        public servicePrioritiesIdPut (params: {  id: number; priority: Priority; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Priority> {
            const localVarPath = this.basePath + '/service/priorities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling servicePrioritiesIdPut');
            }
            // verify required parameter 'priority' is set
            if (params.priority == null) {
                throw new Error('Missing required parameter priority when calling servicePrioritiesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.priority),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Priority
         * @param priority
         */
        public servicePrioritiesPost (params: {  priority: Priority; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Priority> {
            const localVarPath = this.basePath + '/service/priorities';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'priority' is set
            if (params.priority == null) {
                throw new Error('Missing required parameter priority when calling servicePrioritiesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.priority),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ProductComponentsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Delete Product Component By Id
         * @param id
         * @param componentId
         */
        public procurementProductsIdComponentsComponentIdDelete (params: {  id: number; componentId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/products/{id}/components/{componentId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'componentId' + '}', String(params.componentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdComponentsComponentIdDelete');
            }
            // verify required parameter 'componentId' is set
            if (params.componentId == null) {
                throw new Error('Missing required parameter componentId when calling procurementProductsIdComponentsComponentIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Product Component By Id
         * @param id
         * @param componentId
         */
        public procurementProductsIdComponentsComponentIdGet (params: {  id: number; componentId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductComponent>> {
            const localVarPath = this.basePath + '/procurement/products/{id}/components/{componentId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'componentId' + '}', String(params.componentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdComponentsComponentIdGet');
            }
            // verify required parameter 'componentId' is set
            if (params.componentId == null) {
                throw new Error('Missing required parameter componentId when calling procurementProductsIdComponentsComponentIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Product Component
         * @param id
         * @param componentId
         * @param operations
         */
        public procurementProductsIdComponentsComponentIdPatch (params: {  id: number; componentId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductComponent>> {
            const localVarPath = this.basePath + '/procurement/products/{id}/components/{componentId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'componentId' + '}', String(params.componentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdComponentsComponentIdPatch');
            }
            // verify required parameter 'componentId' is set
            if (params.componentId == null) {
                throw new Error('Missing required parameter componentId when calling procurementProductsIdComponentsComponentIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementProductsIdComponentsComponentIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Product Component
         * @param id
         * @param componentId
         * @param productComponent
         */
        public procurementProductsIdComponentsComponentIdPut (params: {  id: number; componentId: number; productComponent: ProductComponent; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductComponent>> {
            const localVarPath = this.basePath + '/procurement/products/{id}/components/{componentId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'componentId' + '}', String(params.componentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdComponentsComponentIdPut');
            }
            // verify required parameter 'componentId' is set
            if (params.componentId == null) {
                throw new Error('Missing required parameter componentId when calling procurementProductsIdComponentsComponentIdPut');
            }
            // verify required parameter 'productComponent' is set
            if (params.productComponent == null) {
                throw new Error('Missing required parameter productComponent when calling procurementProductsIdComponentsComponentIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.productComponent),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Product Components Count
         * @param id
         * @param conditions
         */
        public procurementProductsIdComponentsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/products/{id}/components/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdComponentsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Product Components
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementProductsIdComponentsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductComponent>> {
            const localVarPath = this.basePath + '/procurement/products/{id}/components'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdComponentsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Product Component
         * @param id
         * @param productComponent
         */
        public procurementProductsIdComponentsPost (params: {  id: number; productComponent: ProductComponent; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductComponent>> {
            const localVarPath = this.basePath + '/procurement/products/{id}/components'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdComponentsPost');
            }
            // verify required parameter 'productComponent' is set
            if (params.productComponent == null) {
                throw new Error('Missing required parameter productComponent when calling procurementProductsIdComponentsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.productComponent),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ProductPickingShippingDetailsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Product Picking Shipping Details Count
         * @param id
         * @param conditions
         */
        public procurementProductsIdPickingShippingDetailsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/products/{id}/pickingShippingDetails/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdPickingShippingDetailsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Product Picking Shipping Details
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementProductsIdPickingShippingDetailsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductPickingShippingDetail>> {
            const localVarPath = this.basePath + '/procurement/products/{id}/pickingShippingDetails'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdPickingShippingDetailsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Products By Id
         * @param id
         * @param pickingShippingDetailId
         */
        public procurementProductsIdPickingShippingDetailsPickingShippingDetailIdDelete (params: {  id: number; pickingShippingDetailId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/products/{id}/pickingShippingDetails/{pickingShippingDetailId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'pickingShippingDetailId' + '}', String(params.pickingShippingDetailId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdPickingShippingDetailsPickingShippingDetailIdDelete');
            }
            // verify required parameter 'pickingShippingDetailId' is set
            if (params.pickingShippingDetailId == null) {
                throw new Error('Missing required parameter pickingShippingDetailId when calling procurementProductsIdPickingShippingDetailsPickingShippingDetailIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Products By Id
         * @param id
         * @param pickingShippingDetailId
         */
        public procurementProductsIdPickingShippingDetailsPickingShippingDetailIdGet (params: {  id: number; pickingShippingDetailId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductPickingShippingDetail>> {
            const localVarPath = this.basePath + '/procurement/products/{id}/pickingShippingDetails/{pickingShippingDetailId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'pickingShippingDetailId' + '}', String(params.pickingShippingDetailId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdPickingShippingDetailsPickingShippingDetailIdGet');
            }
            // verify required parameter 'pickingShippingDetailId' is set
            if (params.pickingShippingDetailId == null) {
                throw new Error('Missing required parameter pickingShippingDetailId when calling procurementProductsIdPickingShippingDetailsPickingShippingDetailIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Products
         * @param id
         * @param pickingShippingDetailId
         * @param operations
         */
        public procurementProductsIdPickingShippingDetailsPickingShippingDetailIdPatch (params: {  id: number; pickingShippingDetailId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductPickingShippingDetail>> {
            const localVarPath = this.basePath + '/procurement/products/{id}/pickingShippingDetails/{pickingShippingDetailId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'pickingShippingDetailId' + '}', String(params.pickingShippingDetailId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdPickingShippingDetailsPickingShippingDetailIdPatch');
            }
            // verify required parameter 'pickingShippingDetailId' is set
            if (params.pickingShippingDetailId == null) {
                throw new Error('Missing required parameter pickingShippingDetailId when calling procurementProductsIdPickingShippingDetailsPickingShippingDetailIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementProductsIdPickingShippingDetailsPickingShippingDetailIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Products
         * @param id
         * @param pickingShippingDetailId
         * @param productPickingShippingDetails
         */
        public procurementProductsIdPickingShippingDetailsPickingShippingDetailIdPut (params: {  id: number; pickingShippingDetailId: number; productPickingShippingDetails: ProductPickingShippingDetail; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductPickingShippingDetail>> {
            const localVarPath = this.basePath + '/procurement/products/{id}/pickingShippingDetails/{pickingShippingDetailId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'pickingShippingDetailId' + '}', String(params.pickingShippingDetailId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdPickingShippingDetailsPickingShippingDetailIdPut');
            }
            // verify required parameter 'pickingShippingDetailId' is set
            if (params.pickingShippingDetailId == null) {
                throw new Error('Missing required parameter pickingShippingDetailId when calling procurementProductsIdPickingShippingDetailsPickingShippingDetailIdPut');
            }
            // verify required parameter 'productPickingShippingDetails' is set
            if (params.productPickingShippingDetails == null) {
                throw new Error('Missing required parameter productPickingShippingDetails when calling procurementProductsIdPickingShippingDetailsPickingShippingDetailIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.productPickingShippingDetails),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Product Picking Shipping Detail
         * @param id
         * @param productPickingShippingDetails
         */
        public procurementProductsIdPickingShippingDetailsPost (params: {  id: number; productPickingShippingDetails: ProductPickingShippingDetail; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductPickingShippingDetail>> {
            const localVarPath = this.basePath + '/procurement/products/{id}/pickingShippingDetails'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdPickingShippingDetailsPost');
            }
            // verify required parameter 'productPickingShippingDetails' is set
            if (params.productPickingShippingDetails == null) {
                throw new Error('Missing required parameter productPickingShippingDetails when calling procurementProductsIdPickingShippingDetailsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.productPickingShippingDetails),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ProductTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Product Typess Count
         * @param conditions
         */
        public procurementTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/types/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Product Typess
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductType>> {
            const localVarPath = this.basePath + '/procurement/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Product Types By Id
         * @param id
         */
        public procurementTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementTypesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Product Types By Id
         * @param id
         */
        public procurementTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProductType> {
            const localVarPath = this.basePath + '/procurement/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementTypesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Product Types
         * @param id
         * @param operations
         */
        public procurementTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProductType> {
            const localVarPath = this.basePath + '/procurement/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementTypesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementTypesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Product Types
         * @param id
         * @param productTypes
         */
        public procurementTypesIdPut (params: {  id: number; productTypes: ProductType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProductType> {
            const localVarPath = this.basePath + '/procurement/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementTypesIdPut');
            }
            // verify required parameter 'productTypes' is set
            if (params.productTypes == null) {
                throw new Error('Missing required parameter productTypes when calling procurementTypesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.productTypes),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Product Types
         * @param productTypes
         */
        public procurementTypesPost (params: {  productTypes: ProductType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProductType> {
            const localVarPath = this.basePath + '/procurement/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'productTypes' is set
            if (params.productTypes == null) {
                throw new Error('Missing required parameter productTypes when calling procurementTypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.productTypes),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ProductsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Products Count
         * @param conditions
         */
        public systemProductsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/products/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Products
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemProductsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Product>> {
            const localVarPath = this.basePath + '/system/products';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Product By Id
         * @param productIdentifier
         */
        public systemProductsProductIdentifierGet (params: {  productIdentifier: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Product> {
            const localVarPath = this.basePath + '/system/products/{productIdentifier}'
                .replace('{' + 'productIdentifier' + '}', String(params.productIdentifier));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'productIdentifier' is set
            if (params.productIdentifier == null) {
                throw new Error('Missing required parameter productIdentifier when calling systemProductsProductIdentifierGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Install Product
         * @param productIdentifier
         */
        public systemProductsProductIdentifierPost (params: {  productIdentifier?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Product> {
            const localVarPath = this.basePath + '/system/products/{productIdentifier}';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.productIdentifier !== undefined) {
                queryParameters['productIdentifier'] = params.productIdentifier;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ProductsItemApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Products Count
         * @param conditions
         */
        public procurementProductsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/products/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Products
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementProductsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductItem>> {
            const localVarPath = this.basePath + '/procurement/products';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Product By Id
         * @param id
         */
        public procurementProductsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/products/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Product By Id
         * @param id
         */
        public procurementProductsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProductItem> {
            const localVarPath = this.basePath + '/procurement/products/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Product
         * @param id
         * @param operations
         */
        public procurementProductsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProductItem> {
            const localVarPath = this.basePath + '/procurement/products/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementProductsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Product
         * @param id
         * @param productItem
         */
        public procurementProductsIdPut (params: {  id: number; productItem: ProductItem; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProductItem> {
            const localVarPath = this.basePath + '/procurement/products/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdPut');
            }
            // verify required parameter 'productItem' is set
            if (params.productItem == null) {
                throw new Error('Missing required parameter productItem when calling procurementProductsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.productItem),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Product
         * @param productItem
         */
        public procurementProductsPost (params: {  productItem: ProductItem; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProductItem> {
            const localVarPath = this.basePath + '/procurement/products';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'productItem' is set
            if (params.productItem == null) {
                throw new Error('Missing required parameter productItem when calling procurementProductsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.productItem),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ProjectContactsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Delete Project Contact By Id
         * @param id
         * @param contactId
         */
        public projectProjectsIdContactsContactIdDelete (params: {  id: number; contactId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/project/projects/{id}/contacts/{contactId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'contactId' + '}', String(params.contactId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdContactsContactIdDelete');
            }
            // verify required parameter 'contactId' is set
            if (params.contactId == null) {
                throw new Error('Missing required parameter contactId when calling projectProjectsIdContactsContactIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Project Contact By Id
         * @param id
         * @param contactId
         */
        public projectProjectsIdContactsContactIdGet (params: {  id: number; contactId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectContact> {
            const localVarPath = this.basePath + '/project/projects/{id}/contacts/{contactId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'contactId' + '}', String(params.contactId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdContactsContactIdGet');
            }
            // verify required parameter 'contactId' is set
            if (params.contactId == null) {
                throw new Error('Missing required parameter contactId when calling projectProjectsIdContactsContactIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Project Contacts
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public projectProjectsIdContactsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProjectContact>> {
            const localVarPath = this.basePath + '/project/projects/{id}/contacts'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdContactsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Project Contact
         * @param id
         * @param contact
         */
        public projectProjectsIdContactsPost (params: {  id: number; contact: ProjectContact; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectContact> {
            const localVarPath = this.basePath + '/project/projects/{id}/contacts'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdContactsPost');
            }
            // verify required parameter 'contact' is set
            if (params.contact == null) {
                throw new Error('Missing required parameter contact when calling projectProjectsIdContactsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.contact),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ProjectNotesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Project Notes Count
         * @param id
         * @param conditions
         */
        public projectProjectsIdNotesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/project/projects/{id}/notes/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdNotesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Project Notes
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public projectProjectsIdNotesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProjectNote>> {
            const localVarPath = this.basePath + '/project/projects/{id}/notes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdNotesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Project Note By Id
         * @param id
         * @param noteId
         */
        public projectProjectsIdNotesNoteIdDelete (params: {  id: number; noteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/project/projects/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdNotesNoteIdDelete');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling projectProjectsIdNotesNoteIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Project Note By Id
         * @param id
         * @param noteId
         */
        public projectProjectsIdNotesNoteIdGet (params: {  id: number; noteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectNote> {
            const localVarPath = this.basePath + '/project/projects/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdNotesNoteIdGet');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling projectProjectsIdNotesNoteIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Project Note
         * @param id
         * @param noteId
         * @param operations
         */
        public projectProjectsIdNotesNoteIdPatch (params: {  id: number; noteId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectNote> {
            const localVarPath = this.basePath + '/project/projects/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdNotesNoteIdPatch');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling projectProjectsIdNotesNoteIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling projectProjectsIdNotesNoteIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Project Note
         * @param id
         * @param noteId
         * @param note
         */
        public projectProjectsIdNotesNoteIdPut (params: {  id: number; noteId: number; note: ProjectNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectNote> {
            const localVarPath = this.basePath + '/project/projects/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdNotesNoteIdPut');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling projectProjectsIdNotesNoteIdPut');
            }
            // verify required parameter 'note' is set
            if (params.note == null) {
                throw new Error('Missing required parameter note when calling projectProjectsIdNotesNoteIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.note),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Project Note
         * @param id
         * @param note
         */
        public projectProjectsIdNotesPost (params: {  id: number; note: ProjectNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectNote> {
            const localVarPath = this.basePath + '/project/projects/{id}/notes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdNotesPost');
            }
            // verify required parameter 'note' is set
            if (params.note == null) {
                throw new Error('Missing required parameter note when calling projectProjectsIdNotesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.note),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ProjectPhasesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Project Phases Count
         * @param id
         * @param conditions
         */
        public projectProjectsIdPhasesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/project/projects/{id}/phases/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdPhasesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Project Phases
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public projectProjectsIdPhasesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProjectPhase>> {
            const localVarPath = this.basePath + '/project/projects/{id}/phases'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdPhasesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Project Phase By Id
         * @param id
         * @param phaseId
         */
        public projectProjectsIdPhasesPhaseIdDelete (params: {  id: number; phaseId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/project/projects/{id}/phases/{phaseId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'phaseId' + '}', String(params.phaseId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdPhasesPhaseIdDelete');
            }
            // verify required parameter 'phaseId' is set
            if (params.phaseId == null) {
                throw new Error('Missing required parameter phaseId when calling projectProjectsIdPhasesPhaseIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Project Phase By Id
         * @param id
         * @param phaseId
         */
        public projectProjectsIdPhasesPhaseIdGet (params: {  id: number; phaseId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectPhase> {
            const localVarPath = this.basePath + '/project/projects/{id}/phases/{phaseId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'phaseId' + '}', String(params.phaseId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdPhasesPhaseIdGet');
            }
            // verify required parameter 'phaseId' is set
            if (params.phaseId == null) {
                throw new Error('Missing required parameter phaseId when calling projectProjectsIdPhasesPhaseIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Project Phase
         * @param id
         * @param phaseId
         * @param operations
         */
        public projectProjectsIdPhasesPhaseIdPatch (params: {  id: number; phaseId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectPhase> {
            const localVarPath = this.basePath + '/project/projects/{id}/phases/{phaseId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'phaseId' + '}', String(params.phaseId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdPhasesPhaseIdPatch');
            }
            // verify required parameter 'phaseId' is set
            if (params.phaseId == null) {
                throw new Error('Missing required parameter phaseId when calling projectProjectsIdPhasesPhaseIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling projectProjectsIdPhasesPhaseIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Project Phase
         * @param id
         * @param phaseId
         * @param projectPhase
         */
        public projectProjectsIdPhasesPhaseIdPut (params: {  id: number; phaseId: number; projectPhase: ProjectPhase; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectPhase> {
            const localVarPath = this.basePath + '/project/projects/{id}/phases/{phaseId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'phaseId' + '}', String(params.phaseId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdPhasesPhaseIdPut');
            }
            // verify required parameter 'phaseId' is set
            if (params.phaseId == null) {
                throw new Error('Missing required parameter phaseId when calling projectProjectsIdPhasesPhaseIdPut');
            }
            // verify required parameter 'projectPhase' is set
            if (params.projectPhase == null) {
                throw new Error('Missing required parameter projectPhase when calling projectProjectsIdPhasesPhaseIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.projectPhase),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Project Phase
         * @param id
         * @param projectPhase
         */
        public projectProjectsIdPhasesPost (params: {  id: number; projectPhase: ProjectPhase; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectPhase> {
            const localVarPath = this.basePath + '/project/projects/{id}/phases'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdPhasesPost');
            }
            // verify required parameter 'projectPhase' is set
            if (params.projectPhase == null) {
                throw new Error('Missing required parameter projectPhase when calling projectProjectsIdPhasesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.projectPhase),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ProjectsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Projects Count
         * @param conditions
         * @param customFieldConditions
         */
        public projectProjectsCountGet (params: {  conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/project/projects/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.customFieldConditions !== undefined) {
                queryParameters['customFieldConditions'] = params.customFieldConditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Projects
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public projectProjectsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Project>> {
            const localVarPath = this.basePath + '/project/projects';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Project By Id
         * @param id
         */
        public projectProjectsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/project/projects/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Project By Id
         * @param id
         */
        public projectProjectsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Project> {
            const localVarPath = this.basePath + '/project/projects/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Project
         * @param id
         * @param operations
         */
        public projectProjectsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Project> {
            const localVarPath = this.basePath + '/project/projects/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling projectProjectsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Project
         * @param id
         * @param project
         */
        public projectProjectsIdPut (params: {  id: number; project: Project; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Project> {
            const localVarPath = this.basePath + '/project/projects/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdPut');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling projectProjectsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.project),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Project
         * @param project
         */
        public projectProjectsPost (params: {  project: Project; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Project> {
            const localVarPath = this.basePath + '/project/projects';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling projectProjectsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.project),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ProjectsTeammembersApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Team Members Count
         * @param id
         * @param conditions
         */
        public projectProjectsIdTeamMembersCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/project/projects/{id}/teamMembers/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdTeamMembersCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Team Members
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public projectProjectsIdTeamMembersGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProjectTeammember>> {
            const localVarPath = this.basePath + '/project/projects/{id}/teamMembers'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdTeamMembersGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Team Member
         * @param id
         * @param teamMember
         */
        public projectProjectsIdTeamMembersPost (params: {  id: number; teamMember: ProjectTeammember; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectTeammember> {
            const localVarPath = this.basePath + '/project/projects/{id}/teamMembers'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdTeamMembersPost');
            }
            // verify required parameter 'teamMember' is set
            if (params.teamMember == null) {
                throw new Error('Missing required parameter teamMember when calling projectProjectsIdTeamMembersPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.teamMember),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Team Member By Id
         * @param id
         * @param teamMemberId
         */
        public projectProjectsIdTeamMembersTeamMemberIdDelete (params: {  id: number; teamMemberId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/project/projects/{id}/teamMembers/{teamMemberId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'teamMemberId' + '}', String(params.teamMemberId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdTeamMembersTeamMemberIdDelete');
            }
            // verify required parameter 'teamMemberId' is set
            if (params.teamMemberId == null) {
                throw new Error('Missing required parameter teamMemberId when calling projectProjectsIdTeamMembersTeamMemberIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Team Member By Id
         * @param id
         * @param teamMemberId
         */
        public projectProjectsIdTeamMembersTeamMemberIdGet (params: {  id: number; teamMemberId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectTeammember> {
            const localVarPath = this.basePath + '/project/projects/{id}/teamMembers/{teamMemberId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'teamMemberId' + '}', String(params.teamMemberId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdTeamMembersTeamMemberIdGet');
            }
            // verify required parameter 'teamMemberId' is set
            if (params.teamMemberId == null) {
                throw new Error('Missing required parameter teamMemberId when calling projectProjectsIdTeamMembersTeamMemberIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Team Member
         * @param id
         * @param teamMemberId
         * @param operations
         */
        public projectProjectsIdTeamMembersTeamMemberIdPatch (params: {  id: number; teamMemberId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectTeammember> {
            const localVarPath = this.basePath + '/project/projects/{id}/teamMembers/{teamMemberId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'teamMemberId' + '}', String(params.teamMemberId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdTeamMembersTeamMemberIdPatch');
            }
            // verify required parameter 'teamMemberId' is set
            if (params.teamMemberId == null) {
                throw new Error('Missing required parameter teamMemberId when calling projectProjectsIdTeamMembersTeamMemberIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling projectProjectsIdTeamMembersTeamMemberIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Team Member
         * @param id
         * @param teamMemberId
         * @param teamMember
         */
        public projectProjectsIdTeamMembersTeamMemberIdPut (params: {  id: number; teamMemberId: number; teamMember: ProjectTeammember; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectTeammember> {
            const localVarPath = this.basePath + '/project/projects/{id}/teamMembers/{teamMemberId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'teamMemberId' + '}', String(params.teamMemberId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdTeamMembersTeamMemberIdPut');
            }
            // verify required parameter 'teamMemberId' is set
            if (params.teamMemberId == null) {
                throw new Error('Missing required parameter teamMemberId when calling projectProjectsIdTeamMembersTeamMemberIdPut');
            }
            // verify required parameter 'teamMember' is set
            if (params.teamMember == null) {
                throw new Error('Missing required parameter teamMember when calling projectProjectsIdTeamMembersTeamMemberIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.teamMember),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PurchaseOrderLineItemsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Purchase Order Line Items Count
         * @param id
         * @param conditions
         */
        public procurementPurchaseordersIdLineitemsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/purchaseorders/{id}/lineitems/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseordersIdLineitemsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Purchase Order Line Items
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementPurchaseordersIdLineitemsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<PurchaseOrderLineItem>> {
            const localVarPath = this.basePath + '/procurement/purchaseorders/{id}/lineitems'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseordersIdLineitemsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Purchase Order Line Item By Id
         * @param id
         * @param lineItemId
         */
        public procurementPurchaseordersIdLineitemsLineItemIdDelete (params: {  id: number; lineItemId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/purchaseorders/{id}/lineitems/{lineItemId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'lineItemId' + '}', String(params.lineItemId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseordersIdLineitemsLineItemIdDelete');
            }
            // verify required parameter 'lineItemId' is set
            if (params.lineItemId == null) {
                throw new Error('Missing required parameter lineItemId when calling procurementPurchaseordersIdLineitemsLineItemIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Purchase Order Line Item By Id
         * @param id
         * @param lineItemId
         */
        public procurementPurchaseordersIdLineitemsLineItemIdGet (params: {  id: number; lineItemId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrderLineItem> {
            const localVarPath = this.basePath + '/procurement/purchaseorders/{id}/lineitems/{lineItemId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'lineItemId' + '}', String(params.lineItemId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseordersIdLineitemsLineItemIdGet');
            }
            // verify required parameter 'lineItemId' is set
            if (params.lineItemId == null) {
                throw new Error('Missing required parameter lineItemId when calling procurementPurchaseordersIdLineitemsLineItemIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Purchase Order Line Item
         * @param id
         * @param lineItemId
         * @param operations
         */
        public procurementPurchaseordersIdLineitemsLineItemIdPatch (params: {  id: number; lineItemId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrderLineItem> {
            const localVarPath = this.basePath + '/procurement/purchaseorders/{id}/lineitems/{lineItemId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'lineItemId' + '}', String(params.lineItemId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseordersIdLineitemsLineItemIdPatch');
            }
            // verify required parameter 'lineItemId' is set
            if (params.lineItemId == null) {
                throw new Error('Missing required parameter lineItemId when calling procurementPurchaseordersIdLineitemsLineItemIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementPurchaseordersIdLineitemsLineItemIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Purchase Order Line Item
         * @param id
         * @param lineItemId
         * @param purchaseOrderLineItem
         */
        public procurementPurchaseordersIdLineitemsLineItemIdPut (params: {  id: number; lineItemId: number; purchaseOrderLineItem: PurchaseOrderLineItem; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrderLineItem> {
            const localVarPath = this.basePath + '/procurement/purchaseorders/{id}/lineitems/{lineItemId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'lineItemId' + '}', String(params.lineItemId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseordersIdLineitemsLineItemIdPut');
            }
            // verify required parameter 'lineItemId' is set
            if (params.lineItemId == null) {
                throw new Error('Missing required parameter lineItemId when calling procurementPurchaseordersIdLineitemsLineItemIdPut');
            }
            // verify required parameter 'purchaseOrderLineItem' is set
            if (params.purchaseOrderLineItem == null) {
                throw new Error('Missing required parameter purchaseOrderLineItem when calling procurementPurchaseordersIdLineitemsLineItemIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.purchaseOrderLineItem),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Purchase Order Line Item
         * @param id
         * @param purchaseOrderLineItem
         */
        public procurementPurchaseordersIdLineitemsPost (params: {  id: number; purchaseOrderLineItem: PurchaseOrderLineItem; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrderLineItem> {
            const localVarPath = this.basePath + '/procurement/purchaseorders/{id}/lineitems'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseordersIdLineitemsPost');
            }
            // verify required parameter 'purchaseOrderLineItem' is set
            if (params.purchaseOrderLineItem == null) {
                throw new Error('Missing required parameter purchaseOrderLineItem when calling procurementPurchaseordersIdLineitemsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.purchaseOrderLineItem),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PurchaseOrdersApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Purchase Orders Count
         * @param conditions
         */
        public procurementPurchaseordersCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/purchaseorders/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Purchase Orders
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementPurchaseordersGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<PurchaseOrder>> {
            const localVarPath = this.basePath + '/procurement/purchaseorders';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Purchase Order By Id
         * @param id
         */
        public procurementPurchaseordersIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/purchaseorders/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseordersIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Purchase Order By Id
         * @param id
         */
        public procurementPurchaseordersIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrder> {
            const localVarPath = this.basePath + '/procurement/purchaseorders/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseordersIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Purchase Order
         * @param id
         * @param operations
         */
        public procurementPurchaseordersIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrder> {
            const localVarPath = this.basePath + '/procurement/purchaseorders/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseordersIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementPurchaseordersIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Purchase Order
         * @param id
         * @param purchaseOrder
         */
        public procurementPurchaseordersIdPut (params: {  id: number; purchaseOrder: PurchaseOrder; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrder> {
            const localVarPath = this.basePath + '/procurement/purchaseorders/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseordersIdPut');
            }
            // verify required parameter 'purchaseOrder' is set
            if (params.purchaseOrder == null) {
                throw new Error('Missing required parameter purchaseOrder when calling procurementPurchaseordersIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.purchaseOrder),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Purchase Order
         * @param purchaseOrder
         */
        public procurementPurchaseordersPost (params: {  purchaseOrder: PurchaseOrder; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrder> {
            const localVarPath = this.basePath + '/procurement/purchaseorders';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'purchaseOrder' is set
            if (params.purchaseOrder == null) {
                throw new Error('Missing required parameter purchaseOrder when calling procurementPurchaseordersPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.purchaseOrder),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ReportsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Reports
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         */
        public systemReportsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Report>> {
            const localVarPath = this.basePath + '/system/reports';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Column Definitions
         * @param reportName
         */
        public systemReportsReportNameColumnsGet (params: {  reportName: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<JObject>> {
            const localVarPath = this.basePath + '/system/reports/{reportName}/columns'
                .replace('{' + 'reportName' + '}', String(params.reportName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'reportName' is set
            if (params.reportName == null) {
                throw new Error('Missing required parameter reportName when calling systemReportsReportNameColumnsGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Report Results Count
         * @param reportName
         * @param conditions
         */
        public systemReportsReportNameCountGet (params: {  reportName: string; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/reports/{reportName}/count'
                .replace('{' + 'reportName' + '}', String(params.reportName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'reportName' is set
            if (params.reportName == null) {
                throw new Error('Missing required parameter reportName when calling systemReportsReportNameCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Report Results
         * @param reportName
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         * @param columns
         */
        public systemReportsReportNameGet (params: {  reportName: string; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; columns?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ReportDataResponse> {
            const localVarPath = this.basePath + '/system/reports/{reportName}'
                .replace('{' + 'reportName' + '}', String(params.reportName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'reportName' is set
            if (params.reportName == null) {
                throw new Error('Missing required parameter reportName when calling systemReportsReportNameGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            if (params.columns !== undefined) {
                queryParameters['columns'] = params.columns;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ScheduleEntriesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Schedules Count
         * @param conditions
         */
        public scheduleEntriesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/schedule/entries/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Schedules
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public scheduleEntriesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ScheduleEntry>> {
            const localVarPath = this.basePath + '/schedule/entries';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Schedule By Id
         * @param id
         */
        public scheduleEntriesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/schedule/entries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleEntriesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Schedule By Id
         * @param id
         */
        public scheduleEntriesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleEntry> {
            const localVarPath = this.basePath + '/schedule/entries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleEntriesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Schedule
         * @param id
         * @param operations
         */
        public scheduleEntriesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleEntry> {
            const localVarPath = this.basePath + '/schedule/entries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleEntriesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling scheduleEntriesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Schedule
         * @param id
         * @param scheduleEntry
         */
        public scheduleEntriesIdPut (params: {  id: number; scheduleEntry: ScheduleEntry; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleEntry> {
            const localVarPath = this.basePath + '/schedule/entries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleEntriesIdPut');
            }
            // verify required parameter 'scheduleEntry' is set
            if (params.scheduleEntry == null) {
                throw new Error('Missing required parameter scheduleEntry when calling scheduleEntriesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.scheduleEntry),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Schedule
         * @param scheduleEntry
         */
        public scheduleEntriesPost (params: {  scheduleEntry: ScheduleEntry; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleEntry> {
            const localVarPath = this.basePath + '/schedule/entries';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'scheduleEntry' is set
            if (params.scheduleEntry == null) {
                throw new Error('Missing required parameter scheduleEntry when calling scheduleEntriesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.scheduleEntry),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ScheduleReminderTimesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Reminder Time Count
         * @param conditions
         */
        public scheduleReminderTimesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/schedule/reminderTimes/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Reminder Time
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public scheduleReminderTimesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ScheduleReminderTime>> {
            const localVarPath = this.basePath + '/schedule/reminderTimes';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Reminder Time By Id
         * @param id
         */
        public scheduleReminderTimesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleReminderTime> {
            const localVarPath = this.basePath + '/schedule/reminderTimes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleReminderTimesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Reminder Time
         * @param id
         * @param operations
         */
        public scheduleReminderTimesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleReminderTime> {
            const localVarPath = this.basePath + '/schedule/reminderTimes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleReminderTimesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling scheduleReminderTimesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Reminder Time
         * @param id
         * @param reminderTime
         */
        public scheduleReminderTimesIdPut (params: {  id: number; reminderTime: ScheduleReminderTime; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleReminderTime> {
            const localVarPath = this.basePath + '/schedule/reminderTimes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleReminderTimesIdPut');
            }
            // verify required parameter 'reminderTime' is set
            if (params.reminderTime == null) {
                throw new Error('Missing required parameter reminderTime when calling scheduleReminderTimesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.reminderTime),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ScheduleStatusesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Schedule Statuses Count
         * @param conditions
         */
        public scheduleStatusesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/schedule/statuses/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Schedule Statuses
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public scheduleStatusesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ScheduleStatus>> {
            const localVarPath = this.basePath + '/schedule/statuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Schedule Status By Id
         * @param id
         */
        public scheduleStatusesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/schedule/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleStatusesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Schedule Status By Id
         * @param id
         */
        public scheduleStatusesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleStatus> {
            const localVarPath = this.basePath + '/schedule/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleStatusesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Schedule Status
         * @param id
         * @param operations
         */
        public scheduleStatusesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleStatus> {
            const localVarPath = this.basePath + '/schedule/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleStatusesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling scheduleStatusesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Schedule Status
         * @param id
         * @param scheduleStatus
         */
        public scheduleStatusesIdPut (params: {  id: number; scheduleStatus: ScheduleStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleStatus> {
            const localVarPath = this.basePath + '/schedule/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleStatusesIdPut');
            }
            // verify required parameter 'scheduleStatus' is set
            if (params.scheduleStatus == null) {
                throw new Error('Missing required parameter scheduleStatus when calling scheduleStatusesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.scheduleStatus),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Schedule Status
         * @param scheduleStatus
         */
        public scheduleStatusesPost (params: {  scheduleStatus: ScheduleStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleStatus> {
            const localVarPath = this.basePath + '/schedule/statuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'scheduleStatus' is set
            if (params.scheduleStatus == null) {
                throw new Error('Missing required parameter scheduleStatus when calling scheduleStatusesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.scheduleStatus),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ScheduleStopwatchesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Schedule Stopwatches Count
         * @param conditions
         */
        public timeSchedulestopwatchesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/time/schedulestopwatches/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Schedule Stopwatches
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public timeSchedulestopwatchesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ScheduleStopwatch>> {
            const localVarPath = this.basePath + '/time/schedulestopwatches';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Schedule Stopwatch By Id
         * @param id
         */
        public timeSchedulestopwatchesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/time/schedulestopwatches/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeSchedulestopwatchesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Schedule Stopwatch By Id
         * @param id
         */
        public timeSchedulestopwatchesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleStopwatch> {
            const localVarPath = this.basePath + '/time/schedulestopwatches/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeSchedulestopwatchesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Schedule Stopwatch
         * @param id
         * @param operations
         */
        public timeSchedulestopwatchesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleStopwatch> {
            const localVarPath = this.basePath + '/time/schedulestopwatches/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeSchedulestopwatchesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling timeSchedulestopwatchesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Schedule Stopwatch
         * @param id
         * @param scheduleStopwatch
         */
        public timeSchedulestopwatchesIdPut (params: {  id: number; scheduleStopwatch: ScheduleStopwatch; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleStopwatch> {
            const localVarPath = this.basePath + '/time/schedulestopwatches/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeSchedulestopwatchesIdPut');
            }
            // verify required parameter 'scheduleStopwatch' is set
            if (params.scheduleStopwatch == null) {
                throw new Error('Missing required parameter scheduleStopwatch when calling timeSchedulestopwatchesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.scheduleStopwatch),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Schedule Stopwatch
         * @param scheduleStopwatch
         */
        public timeSchedulestopwatchesPost (params: {  scheduleStopwatch: ScheduleStopwatch; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleStopwatch> {
            const localVarPath = this.basePath + '/time/schedulestopwatches';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'scheduleStopwatch' is set
            if (params.scheduleStopwatch == null) {
                throw new Error('Missing required parameter scheduleStopwatch when calling timeSchedulestopwatchesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.scheduleStopwatch),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ScheduleTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Schedule Types Count
         * @param conditions
         */
        public scheduleTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/schedule/types/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Schedule Types
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public scheduleTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ScheduleType>> {
            const localVarPath = this.basePath + '/schedule/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Schedule Type By Id
         * @param id
         */
        public scheduleTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/schedule/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleTypesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Schedule Type By Id
         * @param id
         */
        public scheduleTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleType> {
            const localVarPath = this.basePath + '/schedule/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleTypesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Schedule Type
         * @param id
         * @param operations
         */
        public scheduleTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleType> {
            const localVarPath = this.basePath + '/schedule/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleTypesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling scheduleTypesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Schedule Type
         * @param id
         * @param scheduleType
         */
        public scheduleTypesIdPut (params: {  id: number; scheduleType: ScheduleType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleType> {
            const localVarPath = this.basePath + '/schedule/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleTypesIdPut');
            }
            // verify required parameter 'scheduleType' is set
            if (params.scheduleType == null) {
                throw new Error('Missing required parameter scheduleType when calling scheduleTypesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.scheduleType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Schedule Type
         * @param scheduleType
         */
        public scheduleTypesPost (params: {  scheduleType: ScheduleType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleType> {
            const localVarPath = this.basePath + '/schedule/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'scheduleType' is set
            if (params.scheduleType == null) {
                throw new Error('Missing required parameter scheduleType when calling scheduleTypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.scheduleType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ShipmentMethodsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Shipment Methods Count
         * @param conditions
         */
        public procurementShipmentmethodsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/shipmentmethods/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Shipment Methods
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementShipmentmethodsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ShipmentMethod>> {
            const localVarPath = this.basePath + '/procurement/shipmentmethods';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Shipment Method By Id
         * @param id
         */
        public procurementShipmentmethodsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/shipmentmethods/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementShipmentmethodsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Shipment Method By Id
         * @param id
         */
        public procurementShipmentmethodsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ShipmentMethod> {
            const localVarPath = this.basePath + '/procurement/shipmentmethods/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementShipmentmethodsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Shipment Method
         * @param id
         * @param operations
         */
        public procurementShipmentmethodsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ShipmentMethod> {
            const localVarPath = this.basePath + '/procurement/shipmentmethods/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementShipmentmethodsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementShipmentmethodsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Shipment Method
         * @param id
         * @param shipmentMethod
         */
        public procurementShipmentmethodsIdPut (params: {  id: number; shipmentMethod: ShipmentMethod; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ShipmentMethod> {
            const localVarPath = this.basePath + '/procurement/shipmentmethods/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementShipmentmethodsIdPut');
            }
            // verify required parameter 'shipmentMethod' is set
            if (params.shipmentMethod == null) {
                throw new Error('Missing required parameter shipmentMethod when calling procurementShipmentmethodsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.shipmentMethod),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Shipment Method
         * @param shipmentMethod
         */
        public procurementShipmentmethodsPost (params: {  shipmentMethod: ShipmentMethod; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ShipmentMethod> {
            const localVarPath = this.basePath + '/procurement/shipmentmethods';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'shipmentMethod' is set
            if (params.shipmentMethod == null) {
                throw new Error('Missing required parameter shipmentMethod when calling procurementShipmentmethodsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.shipmentMethod),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SourcesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Create Sources Count
         * @param conditions
         */
        public serviceSourcesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/sources/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Sources
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceSourcesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Source>> {
            const localVarPath = this.basePath + '/service/sources';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Source By Id
         * @param id
         */
        public serviceSourcesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/sources/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSourcesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Source By Id
         * @param id
         */
        public serviceSourcesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Source> {
            const localVarPath = this.basePath + '/service/sources/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSourcesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Source
         * @param id
         * @param operations
         */
        public serviceSourcesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Source> {
            const localVarPath = this.basePath + '/service/sources/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSourcesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceSourcesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Source
         * @param id
         * @param source
         */
        public serviceSourcesIdPut (params: {  id: number; source: Source; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Source> {
            const localVarPath = this.basePath + '/service/sources/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSourcesIdPut');
            }
            // verify required parameter 'source' is set
            if (params.source == null) {
                throw new Error('Missing required parameter source when calling serviceSourcesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.source),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Source
         * @param source
         */
        public serviceSourcesPost (params: {  source: Source; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Source> {
            const localVarPath = this.basePath + '/service/sources';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'source' is set
            if (params.source == null) {
                throw new Error('Missing required parameter source when calling serviceSourcesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.source),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SubCategoriesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Sub Categories Count
         * @param id
         * @param conditions
         */
        public procurementCategoriesIdSubcategoriesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/categories/{id}/subcategories/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCategoriesIdSubcategoriesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Sub Categories
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementCategoriesIdSubcategoriesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<SubCategory>> {
            const localVarPath = this.basePath + '/procurement/categories/{id}/subcategories'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCategoriesIdSubcategoriesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Sub Category
         * @param id
         * @param subCategory
         */
        public procurementCategoriesIdSubcategoriesPost (params: {  id: number; subCategory: SubCategory; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SubCategory> {
            const localVarPath = this.basePath + '/procurement/categories/{id}/subcategories'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCategoriesIdSubcategoriesPost');
            }
            // verify required parameter 'subCategory' is set
            if (params.subCategory == null) {
                throw new Error('Missing required parameter subCategory when calling procurementCategoriesIdSubcategoriesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.subCategory),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Sub Category By Id
         * @param id
         * @param subcategoryID
         */
        public procurementCategoriesIdSubcategoriesSubcategoryIDDelete (params: {  id: number; subcategoryID: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/categories/{id}/subcategories/{subcategoryID}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'subcategoryID' + '}', String(params.subcategoryID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCategoriesIdSubcategoriesSubcategoryIDDelete');
            }
            // verify required parameter 'subcategoryID' is set
            if (params.subcategoryID == null) {
                throw new Error('Missing required parameter subcategoryID when calling procurementCategoriesIdSubcategoriesSubcategoryIDDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Sub Category By Id
         * @param id
         * @param subcategoryID
         */
        public procurementCategoriesIdSubcategoriesSubcategoryIDGet (params: {  id: number; subcategoryID: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SubCategory> {
            const localVarPath = this.basePath + '/procurement/categories/{id}/subcategories/{subcategoryID}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'subcategoryID' + '}', String(params.subcategoryID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCategoriesIdSubcategoriesSubcategoryIDGet');
            }
            // verify required parameter 'subcategoryID' is set
            if (params.subcategoryID == null) {
                throw new Error('Missing required parameter subcategoryID when calling procurementCategoriesIdSubcategoriesSubcategoryIDGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Sub Category
         * @param id
         * @param subcategoryID
         * @param operations
         */
        public procurementCategoriesIdSubcategoriesSubcategoryIDPatch (params: {  id: number; subcategoryID: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SubCategory> {
            const localVarPath = this.basePath + '/procurement/categories/{id}/subcategories/{subcategoryID}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'subcategoryID' + '}', String(params.subcategoryID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCategoriesIdSubcategoriesSubcategoryIDPatch');
            }
            // verify required parameter 'subcategoryID' is set
            if (params.subcategoryID == null) {
                throw new Error('Missing required parameter subcategoryID when calling procurementCategoriesIdSubcategoriesSubcategoryIDPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementCategoriesIdSubcategoriesSubcategoryIDPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Sub Category
         * @param id
         * @param subcategoryID
         * @param subCategory
         */
        public procurementCategoriesIdSubcategoriesSubcategoryIDPut (params: {  id: number; subcategoryID: number; subCategory: SubCategory; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SubCategory> {
            const localVarPath = this.basePath + '/procurement/categories/{id}/subcategories/{subcategoryID}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'subcategoryID' + '}', String(params.subcategoryID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCategoriesIdSubcategoriesSubcategoryIDPut');
            }
            // verify required parameter 'subcategoryID' is set
            if (params.subcategoryID == null) {
                throw new Error('Missing required parameter subcategoryID when calling procurementCategoriesIdSubcategoriesSubcategoryIDPut');
            }
            // verify required parameter 'subCategory' is set
            if (params.subCategory == null) {
                throw new Error('Missing required parameter subCategory when calling procurementCategoriesIdSubcategoriesSubcategoryIDPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.subCategory),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SurveyQuestionsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Survey Questions Count
         * @param id
         * @param conditions
         */
        public serviceSurveysIdQuestionsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/surveys/{id}/questions/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdQuestionsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Survey Questions
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceSurveysIdQuestionsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<SurveyQuestion>> {
            const localVarPath = this.basePath + '/service/surveys/{id}/questions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdQuestionsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Survey Question
         * @param id
         * @param surveyQuestion
         */
        public serviceSurveysIdQuestionsPost (params: {  id: number; surveyQuestion: SurveyQuestion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SurveyQuestion> {
            const localVarPath = this.basePath + '/service/surveys/{id}/questions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdQuestionsPost');
            }
            // verify required parameter 'surveyQuestion' is set
            if (params.surveyQuestion == null) {
                throw new Error('Missing required parameter surveyQuestion when calling serviceSurveysIdQuestionsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.surveyQuestion),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Survey Question By Id
         * @param id
         * @param questionId
         */
        public serviceSurveysIdQuestionsQuestionIdDelete (params: {  id: number; questionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/surveys/{id}/questions/{questionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'questionId' + '}', String(params.questionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdQuestionsQuestionIdDelete');
            }
            // verify required parameter 'questionId' is set
            if (params.questionId == null) {
                throw new Error('Missing required parameter questionId when calling serviceSurveysIdQuestionsQuestionIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Survey Question By Id
         * @param id
         * @param questionId
         */
        public serviceSurveysIdQuestionsQuestionIdGet (params: {  id: number; questionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SurveyQuestion> {
            const localVarPath = this.basePath + '/service/surveys/{id}/questions/{questionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'questionId' + '}', String(params.questionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdQuestionsQuestionIdGet');
            }
            // verify required parameter 'questionId' is set
            if (params.questionId == null) {
                throw new Error('Missing required parameter questionId when calling serviceSurveysIdQuestionsQuestionIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Survey Question
         * @param id
         * @param questionId
         * @param operations
         */
        public serviceSurveysIdQuestionsQuestionIdPatch (params: {  id: number; questionId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SurveyQuestion> {
            const localVarPath = this.basePath + '/service/surveys/{id}/questions/{questionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'questionId' + '}', String(params.questionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdQuestionsQuestionIdPatch');
            }
            // verify required parameter 'questionId' is set
            if (params.questionId == null) {
                throw new Error('Missing required parameter questionId when calling serviceSurveysIdQuestionsQuestionIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceSurveysIdQuestionsQuestionIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Survey Question
         * @param id
         * @param questionId
         * @param surveyQuestion
         */
        public serviceSurveysIdQuestionsQuestionIdPut (params: {  id: number; questionId: number; surveyQuestion: SurveyQuestion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SurveyQuestion> {
            const localVarPath = this.basePath + '/service/surveys/{id}/questions/{questionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'questionId' + '}', String(params.questionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdQuestionsQuestionIdPut');
            }
            // verify required parameter 'questionId' is set
            if (params.questionId == null) {
                throw new Error('Missing required parameter questionId when calling serviceSurveysIdQuestionsQuestionIdPut');
            }
            // verify required parameter 'surveyQuestion' is set
            if (params.surveyQuestion == null) {
                throw new Error('Missing required parameter surveyQuestion when calling serviceSurveysIdQuestionsQuestionIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.surveyQuestion),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SurveyResultsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Survey Results Count
         * @param id
         * @param conditions
         */
        public serviceSurveysIdResultsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/surveys/{id}/results/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdResultsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Survey Results
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceSurveysIdResultsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<SurveyResult>> {
            const localVarPath = this.basePath + '/service/surveys/{id}/results'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdResultsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Survey Result
         * @param id
         * @param surveyResult
         */
        public serviceSurveysIdResultsPost (params: {  id: number; surveyResult: SurveyResult; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SurveyResult> {
            const localVarPath = this.basePath + '/service/surveys/{id}/results'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdResultsPost');
            }
            // verify required parameter 'surveyResult' is set
            if (params.surveyResult == null) {
                throw new Error('Missing required parameter surveyResult when calling serviceSurveysIdResultsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.surveyResult),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Survey Result By Id
         * @param id
         * @param resultId
         */
        public serviceSurveysIdResultsResultIdDelete (params: {  id: number; resultId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/surveys/{id}/results/{resultId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'resultId' + '}', String(params.resultId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdResultsResultIdDelete');
            }
            // verify required parameter 'resultId' is set
            if (params.resultId == null) {
                throw new Error('Missing required parameter resultId when calling serviceSurveysIdResultsResultIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Survey Result By Id
         * @param id
         * @param resultId
         */
        public serviceSurveysIdResultsResultIdGet (params: {  id: number; resultId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SurveyResult> {
            const localVarPath = this.basePath + '/service/surveys/{id}/results/{resultId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'resultId' + '}', String(params.resultId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdResultsResultIdGet');
            }
            // verify required parameter 'resultId' is set
            if (params.resultId == null) {
                throw new Error('Missing required parameter resultId when calling serviceSurveysIdResultsResultIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Survey Result
         * @param id
         * @param resultId
         * @param operations
         */
        public serviceSurveysIdResultsResultIdPatch (params: {  id: number; resultId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SurveyResult> {
            const localVarPath = this.basePath + '/service/surveys/{id}/results/{resultId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'resultId' + '}', String(params.resultId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdResultsResultIdPatch');
            }
            // verify required parameter 'resultId' is set
            if (params.resultId == null) {
                throw new Error('Missing required parameter resultId when calling serviceSurveysIdResultsResultIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceSurveysIdResultsResultIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Survey Result
         * @param id
         * @param resultId
         * @param surveyResult
         */
        public serviceSurveysIdResultsResultIdPut (params: {  id: number; resultId: number; surveyResult: SurveyResult; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SurveyResult> {
            const localVarPath = this.basePath + '/service/surveys/{id}/results/{resultId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'resultId' + '}', String(params.resultId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdResultsResultIdPut');
            }
            // verify required parameter 'resultId' is set
            if (params.resultId == null) {
                throw new Error('Missing required parameter resultId when calling serviceSurveysIdResultsResultIdPut');
            }
            // verify required parameter 'surveyResult' is set
            if (params.surveyResult == null) {
                throw new Error('Missing required parameter surveyResult when calling serviceSurveysIdResultsResultIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.surveyResult),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SurveysApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Surveys Count
         * @param conditions
         */
        public serviceSurveysCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/surveys/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Surveys
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceSurveysGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Survey>> {
            const localVarPath = this.basePath + '/service/surveys';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Survey By Id
         * @param id
         */
        public serviceSurveysIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/surveys/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Survey By Id
         * @param id
         */
        public serviceSurveysIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Survey> {
            const localVarPath = this.basePath + '/service/surveys/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Survey
         * @param id
         * @param operations
         */
        public serviceSurveysIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Survey> {
            const localVarPath = this.basePath + '/service/surveys/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceSurveysIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Survey
         * @param id
         * @param survey
         */
        public serviceSurveysIdPut (params: {  id: number; survey: Survey; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Survey> {
            const localVarPath = this.basePath + '/service/surveys/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdPut');
            }
            // verify required parameter 'survey' is set
            if (params.survey == null) {
                throw new Error('Missing required parameter survey when calling serviceSurveysIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.survey),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Survey
         * @param survey
         */
        public serviceSurveysPost (params: {  survey: Survey; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Survey> {
            const localVarPath = this.basePath + '/service/surveys';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'survey' is set
            if (params.survey == null) {
                throw new Error('Missing required parameter survey when calling serviceSurveysPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.survey),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TaxCodeXRefsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Tax Code X Ref Count
         * @param id
         * @param conditions
         */
        public financeTaxCodesIdTaxCodeXRefsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/taxCodeXRefs/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdTaxCodeXRefsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Tax Code X Ref
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeTaxCodesIdTaxCodeXRefsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<TaxCodeXRef>> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/taxCodeXRefs'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdTaxCodeXRefsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Tax Code X Ref
         * @param id
         * @param taxCodeXRef
         */
        public financeTaxCodesIdTaxCodeXRefsPost (params: {  id: number; taxCodeXRef: TaxCodeXRef; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TaxCodeXRef> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/taxCodeXRefs'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdTaxCodeXRefsPost');
            }
            // verify required parameter 'taxCodeXRef' is set
            if (params.taxCodeXRef == null) {
                throw new Error('Missing required parameter taxCodeXRef when calling financeTaxCodesIdTaxCodeXRefsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.taxCodeXRef),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Tax Code X Ref By Id
         * @param id
         * @param taxCodeXRefId
         */
        public financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdDelete (params: {  id: number; taxCodeXRefId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/taxCodeXRefs/{taxCodeXRefId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'taxCodeXRefId' + '}', String(params.taxCodeXRefId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdDelete');
            }
            // verify required parameter 'taxCodeXRefId' is set
            if (params.taxCodeXRefId == null) {
                throw new Error('Missing required parameter taxCodeXRefId when calling financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Tax Code X Ref By Id
         * @param id
         * @param taxCodeXRefId
         */
        public financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdGet (params: {  id: number; taxCodeXRefId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TaxCodeXRef> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/taxCodeXRefs/{taxCodeXRefId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'taxCodeXRefId' + '}', String(params.taxCodeXRefId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdGet');
            }
            // verify required parameter 'taxCodeXRefId' is set
            if (params.taxCodeXRefId == null) {
                throw new Error('Missing required parameter taxCodeXRefId when calling financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Tax Code X Ref
         * @param id
         * @param taxCodeXRefId
         * @param operations
         */
        public financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdPatch (params: {  id: number; taxCodeXRefId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TaxCodeXRef> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/taxCodeXRefs/{taxCodeXRefId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'taxCodeXRefId' + '}', String(params.taxCodeXRefId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdPatch');
            }
            // verify required parameter 'taxCodeXRefId' is set
            if (params.taxCodeXRefId == null) {
                throw new Error('Missing required parameter taxCodeXRefId when calling financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Tax Code X Ref
         * @param id
         * @param taxCodeXRefId
         * @param taxCodeXRef
         */
        public financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdPut (params: {  id: number; taxCodeXRefId: number; taxCodeXRef: TaxCodeXRef; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TaxCodeXRef> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/taxCodeXRefs/{taxCodeXRefId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'taxCodeXRefId' + '}', String(params.taxCodeXRefId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdPut');
            }
            // verify required parameter 'taxCodeXRefId' is set
            if (params.taxCodeXRefId == null) {
                throw new Error('Missing required parameter taxCodeXRefId when calling financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdPut');
            }
            // verify required parameter 'taxCodeXRef' is set
            if (params.taxCodeXRef == null) {
                throw new Error('Missing required parameter taxCodeXRef when calling financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.taxCodeXRef),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TaxCodesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Tax Code Count
         * @param conditions
         */
        public financeTaxCodesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/taxCodes/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Tax Code
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeTaxCodesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<TaxCode>> {
            const localVarPath = this.basePath + '/finance/taxCodes';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Tax Code By Id
         * @param id
         */
        public financeTaxCodesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Tax Code By Id
         * @param id
         */
        public financeTaxCodesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TaxCode> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Tax Code
         * @param id
         * @param operations
         */
        public financeTaxCodesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TaxCode> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeTaxCodesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Tax Code
         * @param id
         * @param taxCode
         */
        public financeTaxCodesIdPut (params: {  id: number; taxCode: TaxCode; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TaxCode> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdPut');
            }
            // verify required parameter 'taxCode' is set
            if (params.taxCode == null) {
                throw new Error('Missing required parameter taxCode when calling financeTaxCodesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.taxCode),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Tax Code
         * @param taxCode
         */
        public financeTaxCodesPost (params: {  taxCode: TaxCode; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TaxCode> {
            const localVarPath = this.basePath + '/finance/taxCodes';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'taxCode' is set
            if (params.taxCode == null) {
                throw new Error('Missing required parameter taxCode when calling financeTaxCodesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.taxCode),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TicketNotesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Service Notes Count
         * @param id
         * @param conditions
         */
        public serviceTicketsIdNotesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/tickets/{id}/notes/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdNotesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Service Notes
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceTicketsIdNotesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ServiceNote>> {
            const localVarPath = this.basePath + '/service/tickets/{id}/notes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdNotesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Service Note By Id
         * @param id
         * @param noteId
         */
        public serviceTicketsIdNotesNoteIdDelete (params: {  id: number; noteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/tickets/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdNotesNoteIdDelete');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling serviceTicketsIdNotesNoteIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Service Note By Id
         * @param id
         * @param noteId
         */
        public serviceTicketsIdNotesNoteIdGet (params: {  id: number; noteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ServiceNote> {
            const localVarPath = this.basePath + '/service/tickets/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdNotesNoteIdGet');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling serviceTicketsIdNotesNoteIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Service Note
         * @param id
         * @param noteId
         * @param operations
         */
        public serviceTicketsIdNotesNoteIdPatch (params: {  id: number; noteId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ServiceNote> {
            const localVarPath = this.basePath + '/service/tickets/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdNotesNoteIdPatch');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling serviceTicketsIdNotesNoteIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceTicketsIdNotesNoteIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Service Note
         * @param id
         * @param noteId
         * @param serviceNote
         */
        public serviceTicketsIdNotesNoteIdPut (params: {  id: number; noteId: number; serviceNote: ServiceNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ServiceNote> {
            const localVarPath = this.basePath + '/service/tickets/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdNotesNoteIdPut');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling serviceTicketsIdNotesNoteIdPut');
            }
            // verify required parameter 'serviceNote' is set
            if (params.serviceNote == null) {
                throw new Error('Missing required parameter serviceNote when calling serviceTicketsIdNotesNoteIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.serviceNote),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Service Note
         * @param id
         * @param serviceNote
         */
        public serviceTicketsIdNotesPost (params: {  id: number; serviceNote: ServiceNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ServiceNote> {
            const localVarPath = this.basePath + '/service/tickets/{id}/notes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdNotesPost');
            }
            // verify required parameter 'serviceNote' is set
            if (params.serviceNote == null) {
                throw new Error('Missing required parameter serviceNote when calling serviceTicketsIdNotesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.serviceNote),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TicketStopwatchesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Ticket Stopwatches Count
         * @param conditions
         */
        public timeTicketstopwatchesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/time/ticketstopwatches/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Ticket Stopwatches
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public timeTicketstopwatchesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<TicketStopwatch>> {
            const localVarPath = this.basePath + '/time/ticketstopwatches';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Ticket Stopwatch By Id
         * @param id
         */
        public timeTicketstopwatchesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/time/ticketstopwatches/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeTicketstopwatchesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Ticket Stopwatch By Id
         * @param id
         */
        public timeTicketstopwatchesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TicketStopwatch> {
            const localVarPath = this.basePath + '/time/ticketstopwatches/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeTicketstopwatchesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Ticket Stopwatch
         * @param id
         * @param operations
         */
        public timeTicketstopwatchesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TicketStopwatch> {
            const localVarPath = this.basePath + '/time/ticketstopwatches/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeTicketstopwatchesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling timeTicketstopwatchesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Ticket Stopwatch
         * @param id
         * @param ticketStopwatch
         */
        public timeTicketstopwatchesIdPut (params: {  id: number; ticketStopwatch: TicketStopwatch; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TicketStopwatch> {
            const localVarPath = this.basePath + '/time/ticketstopwatches/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeTicketstopwatchesIdPut');
            }
            // verify required parameter 'ticketStopwatch' is set
            if (params.ticketStopwatch == null) {
                throw new Error('Missing required parameter ticketStopwatch when calling timeTicketstopwatchesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.ticketStopwatch),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Ticket Stopwatch
         * @param ticketStopwatch
         */
        public timeTicketstopwatchesPost (params: {  ticketStopwatch: TicketStopwatch; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TicketStopwatch> {
            const localVarPath = this.basePath + '/time/ticketstopwatches';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'ticketStopwatch' is set
            if (params.ticketStopwatch == null) {
                throw new Error('Missing required parameter ticketStopwatch when calling timeTicketstopwatchesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.ticketStopwatch),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TicketTasksApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Tasks Count
         * @param id
         * @param conditions
         */
        public serviceTicketsIdTasksCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/tickets/{id}/tasks/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdTasksCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Tasks
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceTicketsIdTasksGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Task>> {
            const localVarPath = this.basePath + '/service/tickets/{id}/tasks'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdTasksGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Task
         * @param id
         * @param task
         */
        public serviceTicketsIdTasksPost (params: {  id: number; task: Task; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Task> {
            const localVarPath = this.basePath + '/service/tickets/{id}/tasks'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdTasksPost');
            }
            // verify required parameter 'task' is set
            if (params.task == null) {
                throw new Error('Missing required parameter task when calling serviceTicketsIdTasksPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.task),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Task By Id
         * @param id
         * @param taskId
         */
        public serviceTicketsIdTasksTaskIdDelete (params: {  id: number; taskId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/tickets/{id}/tasks/{taskId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'taskId' + '}', String(params.taskId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdTasksTaskIdDelete');
            }
            // verify required parameter 'taskId' is set
            if (params.taskId == null) {
                throw new Error('Missing required parameter taskId when calling serviceTicketsIdTasksTaskIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Task By Id
         * @param id
         * @param taskId
         */
        public serviceTicketsIdTasksTaskIdGet (params: {  id: number; taskId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Task> {
            const localVarPath = this.basePath + '/service/tickets/{id}/tasks/{taskId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'taskId' + '}', String(params.taskId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdTasksTaskIdGet');
            }
            // verify required parameter 'taskId' is set
            if (params.taskId == null) {
                throw new Error('Missing required parameter taskId when calling serviceTicketsIdTasksTaskIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Task
         * @param id
         * @param taskId
         * @param operations
         */
        public serviceTicketsIdTasksTaskIdPatch (params: {  id: number; taskId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Task> {
            const localVarPath = this.basePath + '/service/tickets/{id}/tasks/{taskId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'taskId' + '}', String(params.taskId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdTasksTaskIdPatch');
            }
            // verify required parameter 'taskId' is set
            if (params.taskId == null) {
                throw new Error('Missing required parameter taskId when calling serviceTicketsIdTasksTaskIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceTicketsIdTasksTaskIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Task
         * @param id
         * @param taskId
         * @param task
         */
        public serviceTicketsIdTasksTaskIdPut (params: {  id: number; taskId: number; task: Task; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Task> {
            const localVarPath = this.basePath + '/service/tickets/{id}/tasks/{taskId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'taskId' + '}', String(params.taskId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdTasksTaskIdPut');
            }
            // verify required parameter 'taskId' is set
            if (params.taskId == null) {
                throw new Error('Missing required parameter taskId when calling serviceTicketsIdTasksTaskIdPut');
            }
            // verify required parameter 'task' is set
            if (params.task == null) {
                throw new Error('Missing required parameter task when calling serviceTicketsIdTasksTaskIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.task),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TicketsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Tickets Count
         * @param conditions
         * @param customFieldConditions
         */
        public serviceTicketsCountGet (params: {  conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/tickets/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.customFieldConditions !== undefined) {
                queryParameters['customFieldConditions'] = params.customFieldConditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Tickets
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceTicketsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Ticket>> {
            const localVarPath = this.basePath + '/service/tickets';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Ticket Activities Count
         * @param id
         */
        public serviceTicketsIdActivitiesCountGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/tickets/{id}/activities/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdActivitiesCountGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Ticket Activities
         * @param id
         * @param page
         * @param pageSize
         */
        public serviceTicketsIdActivitiesGet (params: {  id: number; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ActivityReference>> {
            const localVarPath = this.basePath + '/service/tickets/{id}/activities'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdActivitiesGet');
            }
            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Configuration Association
         * @param id
         * @param configId
         */
        public serviceTicketsIdConfigurationsConfigIdDelete (params: {  id: number; configId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/tickets/{id}/configurations/{configId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'configId' + '}', String(params.configId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdConfigurationsConfigIdDelete');
            }
            // verify required parameter 'configId' is set
            if (params.configId == null) {
                throw new Error('Missing required parameter configId when calling serviceTicketsIdConfigurationsConfigIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Configuration Association
         * @param id
         * @param configId
         */
        public serviceTicketsIdConfigurationsConfigIdGet (params: {  id: number; configId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationReference> {
            const localVarPath = this.basePath + '/service/tickets/{id}/configurations/{configId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'configId' + '}', String(params.configId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdConfigurationsConfigIdGet');
            }
            // verify required parameter 'configId' is set
            if (params.configId == null) {
                throw new Error('Missing required parameter configId when calling serviceTicketsIdConfigurationsConfigIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Ticket Configurations Count
         * @param id
         */
        public serviceTicketsIdConfigurationsCountGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/tickets/{id}/configurations/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdConfigurationsCountGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Ticket Configurations
         * @param id
         * @param page
         * @param pageSize
         */
        public serviceTicketsIdConfigurationsGet (params: {  id: number; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ConfigurationReference>> {
            const localVarPath = this.basePath + '/service/tickets/{id}/configurations'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdConfigurationsGet');
            }
            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Configuration Association
         * @param id
         * @param configuration
         */
        public serviceTicketsIdConfigurationsPost (params: {  id: number; configuration: ConfigurationReference; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationReference> {
            const localVarPath = this.basePath + '/service/tickets/{id}/configurations'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdConfigurationsPost');
            }
            // verify required parameter 'configuration' is set
            if (params.configuration == null) {
                throw new Error('Missing required parameter configuration when calling serviceTicketsIdConfigurationsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.configuration),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Ticket By Id
         * @param id
         */
        public serviceTicketsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/tickets/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Ticket Documents Count
         * @param id
         */
        public serviceTicketsIdDocumentsCountGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/tickets/{id}/documents/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdDocumentsCountGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Ticket Documents
         * @param id
         * @param page
         * @param pageSize
         */
        public serviceTicketsIdDocumentsGet (params: {  id: number; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<DocumentReference>> {
            const localVarPath = this.basePath + '/service/tickets/{id}/documents'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdDocumentsGet');
            }
            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Ticket By Id
         * @param id
         */
        public serviceTicketsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Ticket> {
            const localVarPath = this.basePath + '/service/tickets/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Ticket
         * @param id
         * @param operations
         */
        public serviceTicketsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Ticket> {
            const localVarPath = this.basePath + '/service/tickets/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceTicketsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Ticket Products Count
         * @param id
         */
        public serviceTicketsIdProductsCountGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/tickets/{id}/products/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdProductsCountGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Ticket Products
         * @param id
         * @param page
         * @param pageSize
         */
        public serviceTicketsIdProductsGet (params: {  id: number; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductReference>> {
            const localVarPath = this.basePath + '/service/tickets/{id}/products'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdProductsGet');
            }
            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Ticket
         * @param id
         * @param ticket
         */
        public serviceTicketsIdPut (params: {  id: number; ticket: Ticket; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Ticket> {
            const localVarPath = this.basePath + '/service/tickets/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdPut');
            }
            // verify required parameter 'ticket' is set
            if (params.ticket == null) {
                throw new Error('Missing required parameter ticket when calling serviceTicketsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.ticket),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Ticket Schedule Entries Count
         * @param id
         */
        public serviceTicketsIdScheduleentriesCountGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/tickets/{id}/scheduleentries/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdScheduleentriesCountGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Ticket Schedule Entries
         * @param id
         * @param page
         * @param pageSize
         */
        public serviceTicketsIdScheduleentriesGet (params: {  id: number; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ScheduleEntryReference>> {
            const localVarPath = this.basePath + '/service/tickets/{id}/scheduleentries'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdScheduleentriesGet');
            }
            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Ticket Time Entries Count
         * @param id
         */
        public serviceTicketsIdTimeentriesCountGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/tickets/{id}/timeentries/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdTimeentriesCountGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Ticket Time Entries
         * @param id
         * @param page
         * @param pageSize
         */
        public serviceTicketsIdTimeentriesGet (params: {  id: number; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<TimeEntryReference>> {
            const localVarPath = this.basePath + '/service/tickets/{id}/timeentries'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdTimeentriesGet');
            }
            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Ticket
         * @param ticket
         */
        public serviceTicketsPost (params: {  ticket: Ticket; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Ticket> {
            const localVarPath = this.basePath + '/service/tickets';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'ticket' is set
            if (params.ticket == null) {
                throw new Error('Missing required parameter ticket when calling serviceTicketsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.ticket),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Ticket Search
         * @param filterValues
         * @param page
         * @param pageSize
         */
        public serviceTicketsSearchPost (params: {  filterValues: FilterValues; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Ticket>> {
            const localVarPath = this.basePath + '/service/tickets/search';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'filterValues' is set
            if (params.filterValues == null) {
                throw new Error('Missing required parameter filterValues when calling serviceTicketsSearchPost');
            }
            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.filterValues),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TimeEntriesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Time Entries Count
         * @param conditions
         * @param customFieldConditions
         */
        public timeEntriesCountGet (params: {  conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/time/entries/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.customFieldConditions !== undefined) {
                queryParameters['customFieldConditions'] = params.customFieldConditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Time Entries
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public timeEntriesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<TimeEntry>> {
            const localVarPath = this.basePath + '/time/entries';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Time Entry By Id
         * @param id
         */
        public timeEntriesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/time/entries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeEntriesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Time Entry By Id
         * @param id
         */
        public timeEntriesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TimeEntry> {
            const localVarPath = this.basePath + '/time/entries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeEntriesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Time Entry
         * @param id
         * @param operations
         */
        public timeEntriesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TimeEntry> {
            const localVarPath = this.basePath + '/time/entries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeEntriesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling timeEntriesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Time Entry
         * @param id
         * @param timeEntry
         */
        public timeEntriesIdPut (params: {  id: number; timeEntry: TimeEntry; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TimeEntry> {
            const localVarPath = this.basePath + '/time/entries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeEntriesIdPut');
            }
            // verify required parameter 'timeEntry' is set
            if (params.timeEntry == null) {
                throw new Error('Missing required parameter timeEntry when calling timeEntriesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.timeEntry),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Time Entry
         * @param timeEntry
         */
        public timeEntriesPost (params: {  timeEntry: TimeEntry; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TimeEntry> {
            const localVarPath = this.basePath + '/time/entries';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'timeEntry' is set
            if (params.timeEntry == null) {
                throw new Error('Missing required parameter timeEntry when calling timeEntriesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.timeEntry),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class UnitOfMeasureConversionsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Delete Conversion By Id
         * @param id
         * @param conversionId
         */
        public procurementUnitOfMeasuresIdConversionsConversionIdDelete (params: {  id: number; conversionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/unitOfMeasures/{id}/conversions/{conversionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'conversionId' + '}', String(params.conversionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementUnitOfMeasuresIdConversionsConversionIdDelete');
            }
            // verify required parameter 'conversionId' is set
            if (params.conversionId == null) {
                throw new Error('Missing required parameter conversionId when calling procurementUnitOfMeasuresIdConversionsConversionIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Conversion By Id
         * @param id
         * @param conversionId
         */
        public procurementUnitOfMeasuresIdConversionsConversionIdGet (params: {  id: number; conversionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Conversion> {
            const localVarPath = this.basePath + '/procurement/unitOfMeasures/{id}/conversions/{conversionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'conversionId' + '}', String(params.conversionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementUnitOfMeasuresIdConversionsConversionIdGet');
            }
            // verify required parameter 'conversionId' is set
            if (params.conversionId == null) {
                throw new Error('Missing required parameter conversionId when calling procurementUnitOfMeasuresIdConversionsConversionIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Conversion
         * @param id
         * @param conversionId
         * @param operations
         */
        public procurementUnitOfMeasuresIdConversionsConversionIdPatch (params: {  id: number; conversionId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Conversion> {
            const localVarPath = this.basePath + '/procurement/unitOfMeasures/{id}/conversions/{conversionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'conversionId' + '}', String(params.conversionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementUnitOfMeasuresIdConversionsConversionIdPatch');
            }
            // verify required parameter 'conversionId' is set
            if (params.conversionId == null) {
                throw new Error('Missing required parameter conversionId when calling procurementUnitOfMeasuresIdConversionsConversionIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementUnitOfMeasuresIdConversionsConversionIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Conversion
         * @param id
         * @param conversionId
         * @param conversion
         */
        public procurementUnitOfMeasuresIdConversionsConversionIdPut (params: {  id: number; conversionId: number; conversion: Conversion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Conversion> {
            const localVarPath = this.basePath + '/procurement/unitOfMeasures/{id}/conversions/{conversionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'conversionId' + '}', String(params.conversionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementUnitOfMeasuresIdConversionsConversionIdPut');
            }
            // verify required parameter 'conversionId' is set
            if (params.conversionId == null) {
                throw new Error('Missing required parameter conversionId when calling procurementUnitOfMeasuresIdConversionsConversionIdPut');
            }
            // verify required parameter 'conversion' is set
            if (params.conversion == null) {
                throw new Error('Missing required parameter conversion when calling procurementUnitOfMeasuresIdConversionsConversionIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.conversion),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Conversion Count
         * @param id
         * @param conditions
         */
        public procurementUnitOfMeasuresIdConversionsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/unitOfMeasures/{id}/conversions/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementUnitOfMeasuresIdConversionsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Conversion
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementUnitOfMeasuresIdConversionsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Conversion>> {
            const localVarPath = this.basePath + '/procurement/unitOfMeasures/{id}/conversions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementUnitOfMeasuresIdConversionsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Conversion
         * @param id
         * @param conversion
         */
        public procurementUnitOfMeasuresIdConversionsPost (params: {  id: number; conversion: Conversion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Conversion> {
            const localVarPath = this.basePath + '/procurement/unitOfMeasures/{id}/conversions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementUnitOfMeasuresIdConversionsPost');
            }
            // verify required parameter 'conversion' is set
            if (params.conversion == null) {
                throw new Error('Missing required parameter conversion when calling procurementUnitOfMeasuresIdConversionsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.conversion),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class UnitOfMeasuresApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Unit Of Measure Count
         * @param conditions
         */
        public procurementUnitOfMeasuresCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/unitOfMeasures/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Unit Of Measure
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementUnitOfMeasuresGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<UnitOfMeasure>> {
            const localVarPath = this.basePath + '/procurement/unitOfMeasures';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Unit Of Measure By Id
         * @param id
         */
        public procurementUnitOfMeasuresIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/unitOfMeasures/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementUnitOfMeasuresIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Unit Of Measure By Id
         * @param id
         */
        public procurementUnitOfMeasuresIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<UnitOfMeasure> {
            const localVarPath = this.basePath + '/procurement/unitOfMeasures/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementUnitOfMeasuresIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Unit Of Measure
         * @param id
         * @param operations
         */
        public procurementUnitOfMeasuresIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<UnitOfMeasure> {
            const localVarPath = this.basePath + '/procurement/unitOfMeasures/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementUnitOfMeasuresIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementUnitOfMeasuresIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Unit Of Measure
         * @param id
         * @param unitOfMeasure
         */
        public procurementUnitOfMeasuresIdPut (params: {  id: number; unitOfMeasure: UnitOfMeasure; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<UnitOfMeasure> {
            const localVarPath = this.basePath + '/procurement/unitOfMeasures/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementUnitOfMeasuresIdPut');
            }
            // verify required parameter 'unitOfMeasure' is set
            if (params.unitOfMeasure == null) {
                throw new Error('Missing required parameter unitOfMeasure when calling procurementUnitOfMeasuresIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.unitOfMeasure),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Unit Of Measure
         * @param unitOfMeasure
         */
        public procurementUnitOfMeasuresPost (params: {  unitOfMeasure: UnitOfMeasure; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<UnitOfMeasure> {
            const localVarPath = this.basePath + '/procurement/unitOfMeasures';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'unitOfMeasure' is set
            if (params.unitOfMeasure == null) {
                throw new Error('Missing required parameter unitOfMeasure when calling procurementUnitOfMeasuresPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.unitOfMeasure),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class UserDefinedFieldsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get User Defined Fields Count
         * @param conditions
         */
        public systemUserDefinedFieldsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/userDefinedFields/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get User Defined Fields
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemUserDefinedFieldsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<UserDefinedField>> {
            const localVarPath = this.basePath + '/system/userDefinedFields';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete User Defined Field By Id
         * @param id
         */
        public systemUserDefinedFieldsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/userDefinedFields/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemUserDefinedFieldsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get User Defined Field By Id
         * @param id
         */
        public systemUserDefinedFieldsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<UserDefinedField> {
            const localVarPath = this.basePath + '/system/userDefinedFields/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemUserDefinedFieldsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update User Defined Field
         * @param id
         * @param operations
         */
        public systemUserDefinedFieldsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<UserDefinedField> {
            const localVarPath = this.basePath + '/system/userDefinedFields/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemUserDefinedFieldsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemUserDefinedFieldsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace User Defined Field
         * @param id
         * @param userDefinedField
         */
        public systemUserDefinedFieldsIdPut (params: {  id: number; userDefinedField: UserDefinedField; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<UserDefinedField> {
            const localVarPath = this.basePath + '/system/userDefinedFields/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemUserDefinedFieldsIdPut');
            }
            // verify required parameter 'userDefinedField' is set
            if (params.userDefinedField == null) {
                throw new Error('Missing required parameter userDefinedField when calling systemUserDefinedFieldsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.userDefinedField),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create User Defined Field
         * @param userDefinedField
         */
        public systemUserDefinedFieldsPost (params: {  userDefinedField: UserDefinedField; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<UserDefinedField> {
            const localVarPath = this.basePath + '/system/userDefinedFields';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'userDefinedField' is set
            if (params.userDefinedField == null) {
                throw new Error('Missing required parameter userDefinedField when calling systemUserDefinedFieldsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.userDefinedField),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
