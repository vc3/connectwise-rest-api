import * as querystring from 'querystring';
import * as fetch from 'isomorphic-fetch';
import {assign} from './assign';


export interface AccountingBatch {
    "id"?: number;
    "batchIdentifier": string;
    "exportInvoicesFlag"?: boolean;
    "exportExpensesFlag"?: boolean;
    "exportProductsFlag"?: boolean;
    "closedFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface AccountingPackage {
    "id"?: number;
    "identifier"?: string;
    "name"?: string;
    "directTransferFlag"?: boolean;
    "includeInvoicesFlag"?: boolean;
    "invoiceFormat"?: AccountingPackage.InvoiceFormatEnum;
    "includeExpenseFlag"?: boolean;
    "transferExpenseAsBillFlag"?: boolean;
    "expenseFormat"?: AccountingPackage.ExpenseFormatEnum;
    "supressMemoFlag"?: boolean;
    "syncPaymentInfoFlag"?: boolean;
    "includeSalesTaxFlag"?: boolean;
    "enableTaxGroupsFlag"?: boolean;
    "zeroDollarTaxAmountsFlag"?: boolean;
    "includeItemsFlag"?: boolean;
    "inventorySOHFlag"?: boolean;
    "sendComponentAmountFlag"?: boolean;
    "sendUomFlag"?: boolean;
    "includeCogsEntriesFlag"?: boolean;
    "includgeCogsDropShipFlag"?: boolean;
    "activeFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace AccountingPackage {

export type InvoiceFormatEnum = 'Default' | 'Condensed' | 'Detailed';

export type ExpenseFormatEnum = 'Default' | 'Condensed' | 'Detailed';
}
export interface Activity {
    "id"?: number;
    "name": string;
    "type"?: ActivityTypeReference;
    "company"?: CompanyReference;
    "contact"?: ContactReference;
    "phoneNumber"?: string;
    "email"?: string;
    "status"?: ActivityStatusReference;
    "opportunity"?: OpportunityReference;
    "ticket"?: TicketReference;
    "agreement"?: AgreementReference;
    "campaign"?: CampaignReference;
    "notes"?: string;
    "dateStart"?: Date;
    "dateEnd"?: Date;
    "assignedBy"?: MemberReference;
    "assignTo": MemberReference;
    "scheduleStatus"?: ScheduleStatusReference;
    "reminder"?: ReminderReference;
    "where"?: ServiceLocationReference;
    "notifyFlag"?: boolean;
    "mobileGuid"?: Guid;
    "currency"?: CurrencyReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "customFields"?: Array<CustomFieldValue>;
}

export interface ActivityReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ActivityStatus {
    "id"?: number;
    "name": string;
    "defaultFlag"?: boolean;
    "inactiveFlag"?: boolean;
    "spawnFollowupFlag"?: boolean;
    "closedFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

/**
 * Required when notifyType is set to: "Create Activity"
 */
export interface ActivityStatusReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ActivityStopwatch {

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "activityId": number;
    "activityMobileGuid"?: Guid;
    "agreement"?: AgreementReference;
    "billableOption"?: ActivityStopwatch.BillableOptionEnum;
    "businessUnitId"?: number;
    "dateEntered"?: Date;
    "endTime"?: Date;
    "id"?: number;
    "internalNotes"?: string;
    "locationId"?: number;
    "member": MemberReference;
    "mobileGuid"?: Guid;
    "notes"?: string;
    "startTime"?: Date;
    "status": ActivityStopwatch.StatusEnum;
    "totalPauseTime"?: number;
    "workRole"?: WorkRoleReference;
    "workType"?: WorkTypeReference;
}

export namespace ActivityStopwatch {

export type BillableOptionEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type StatusEnum = 'Reset' | 'Running' | 'Paused' | 'Stopped';
}
export interface ActivityType {
    "id"?: number;
    "name": string;
    "points"?: number;
    "defaultFlag"?: boolean;
    "inactiveFlag"?: boolean;
    "emailFlag"?: boolean;
    "memoFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

/**
 * Required when notifyType is set to: "Create Activity"
 */
export interface ActivityTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Addition {
    "id"?: number;
    "product": IvItemReference;
    "quantity"?: number;
    "lessIncluded"?: number;
    "unitPrice"?: number;
    "unitCost"?: number;
    "billCustomer": Addition.BillCustomerEnum;
    "effectiveDate"?: Date;
    "cancelledDate"?: Date;
    "taxableFlag"?: boolean;
    "serialNumber"?: string;
    "invoiceDescription"?: string;
    "purchaseItemFlag"?: boolean;
    "specialOrderFlag"?: boolean;
    "agreementId"?: number;
    "description"?: string;
    "billedQuantity"?: number;
    "uom"?: string;
    "extPrice"?: number;
    "extCost"?: number;
    "sequenceNumber"?: number;
    "margin"?: number;
    "prorateCost"?: number;
    "proratePrice"?: number;
    "extendedProrateCost"?: number;
    "extendedProratePrice"?: number;
    "prorateCurrentPeriodFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace Addition {

export type BillCustomerEnum = 'Billable' | 'DoNotBill' | 'NoCharge';
}
export interface AddressFormat {
    "id"?: number;
    "name": string;
    "format": string;
    "defaultFlag"?: boolean;
    "countryIds"?: Array<number>;
    "addAllCountries"?: boolean;
    "removeAllCountries"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface AddressFormatReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Adjustment {
    "id"?: number;
    "amount"?: number;
    "description"?: string;
    "effectiveDate"?: Date;
    "agreementId"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "identifier": string;
    "type": AdjustmentTypeReference;
    "reason"?: string;
    "notes"?: string;
    "closedFlag"?: boolean;
    "closedBy"?: string;
    "closedDate"?: Date;
}

export interface AdjustmentDetail {
    "id"?: number;
    "catalogItem": CatalogItemReference;
    "description"?: string;
    "quantityOnHand"?: number;
    "unitCost"?: number;
    "warehouse": WarehouseReference;
    "warehouseBin": WarehouseBinReference;
    "quantityAdjusted": number;
    "serialNumber"?: string;
    "adjustment"?: AdjustmentReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface AdjustmentReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface AdjustmentType {
    "id"?: number;
    "identifier": string;
    "name"?: string;
    "auditTrailFlag"?: boolean;
    "dateCreated"?: Date;
    "createdBy"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface AdjustmentTypeReference {
    "id"?: number;
    "identifier"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Agreement {
    "id"?: number;
    "name": string;
    "type": AgreementTypeReference;
    "company": CompanyReference;
    "contact": ContactReference;
    "subContractCompany"?: CompanyReference;
    "subContractContact"?: ContactReference;
    "parentAgreementId"?: number;
    "customerPO"?: string;
    "locationId"?: number;
    "businessUnitId"?: number;
    "restrictLocationFlag"?: boolean;
    "restrictDepartmentFlag"?: boolean;
    "startDate"?: Date;
    "endDate"?: Date;
    "noEndingDateFlag"?: boolean;
    "opportunity"?: OpportunityReference;
    "cancelledFlag"?: boolean;
    "dateCancelled"?: Date;
    "reasonCancelled"?: string;
    "slaId"?: number;
    "workOrder"?: string;
    "internalNotes"?: string;
    "applicationUnits"?: Agreement.ApplicationUnitsEnum;
    "applicationLimit"?: number;
    "applicationCycle"?: Agreement.ApplicationCycleEnum;
    "applicationUnlimitedFlag"?: boolean;
    "oneTimeFlag"?: boolean;
    "coverAgreementTime"?: boolean;
    "coverAgreementProduct"?: boolean;
    "coverAgreementExpense"?: boolean;
    "coverSalesTax"?: boolean;
    "carryOverUnused"?: boolean;
    "allowOverruns"?: boolean;
    "expiredDays"?: number;
    "limit"?: number;
    "expireWhenZero"?: boolean;
    "chargeToFirm"?: boolean;
    "employeeCompRate"?: Agreement.EmployeeCompRateEnum;
    "employeeCompNotExceed"?: Agreement.EmployeeCompNotExceedEnum;
    "compHourlyRate"?: number;
    "compLimitAmount"?: number;
    "billCycleId"?: number;
    "billOneTimeFlag"?: boolean;
    "billTermsId"?: number;
    "invoicingCycle"?: Agreement.InvoicingCycleEnum;
    "billToCompany"?: CompanyReference;
    "billToSite"?: SiteReference;
    "billAmount"?: number;
    "taxable"?: boolean;
    "prorateFirstBill"?: number;
    "billStartDate"?: Date;
    "taxCodeId"?: number;
    "restrictDownPayment"?: boolean;
    "prorateFlag"?: boolean;
    "invoiceDescription"?: string;
    "topComment"?: boolean;
    "bottomComment"?: boolean;
    "workRole"?: WorkRoleReference;
    "workType"?: WorkTypeReference;
    "projectTypeId"?: number;
    "invoiceTemplateSetupId"?: number;
    "billTime"?: Agreement.BillTimeEnum;
    "billExpenses"?: Agreement.BillExpensesEnum;
    "billProducts"?: Agreement.BillProductsEnum;
    "billableTimeInvoice"?: boolean;
    "billableExpenseInvoice"?: boolean;
    "billableProductInvoice"?: boolean;
    "currency"?: CurrencyReference;
    "periodType"?: Agreement.PeriodTypeEnum;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace Agreement {

export type ApplicationUnitsEnum = 'Amount' | 'Hours' | 'Incidents';

export type ApplicationCycleEnum = 'Contract2Weeks' | 'Contract4Weeks' | 'ContractYear' | 'CalendarMonth' | 'CalendarQuarter' | 'CalendarWeek' | 'ContractQuarter' | 'CalendarYear' | 'OneTimeOnly';

export type EmployeeCompRateEnum = 'Actual' | 'Hourly';

export type EmployeeCompNotExceedEnum = 'Billing' | 'Percent' | 'Amount';

export type InvoicingCycleEnum = 'CalendarYear' | 'ContractYear';

export type BillTimeEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillExpensesEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillProductsEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type PeriodTypeEnum = 'Current' | 'Future' | 'Both' | 'Undefined';
}
export interface AgreementBatchSetup {
    "id"?: number;
    "nextRunDate": Date;
    "daysInAdvance": number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface AgreementReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface AgreementSite {
    "id"?: number;
    "company": CompanyReference;
    "site"?: SiteReference;
    "agreementId"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface AgreementType {
    "id"?: number;
    "name": string;
    "prefixSuffixOption"?: AgreementType.PrefixSuffixOptionEnum;
    "defaultFlag"?: boolean;
    "inactiveFlag"?: boolean;
    "prePaymentFlag"?: boolean;
    "invoicePreSuffix"?: string;
    "location"?: SystemLocationReference;
    "department"?: SystemDepartmentReference;
    "restrictLocationFlag"?: boolean;
    "restrictDepartmentFlag"?: boolean;
    "sla"?: SLAReference;
    "applicationUnits"?: AgreementType.ApplicationUnitsEnum;
    "applicationLimit"?: number;
    "applicationCycle"?: AgreementType.ApplicationCycleEnum;
    "applicationUnlimitedFlag"?: boolean;
    "oneTimeFlag"?: boolean;
    "coverAgreementTimeFlag"?: boolean;
    "coverAgreementProductFlag"?: boolean;
    "coverAgreementExpenseFlag"?: boolean;
    "coverSalesTaxFlag"?: boolean;
    "carryOverUnusedFlag"?: boolean;
    "allowOverrunsFlag"?: boolean;
    "expiredDays"?: number;
    "limit"?: number;
    "expireWhenZero"?: boolean;
    "chargeToFirmFlag"?: boolean;
    "employeeCompRate": AgreementType.EmployeeCompRateEnum;
    "employeeCompNotExceed": AgreementType.EmployeeCompNotExceedEnum;
    "compHourlyRate"?: number;
    "compLimitAmount"?: number;
    "billingCycle"?: BillingCycleReference;
    "billOneTimeFlag"?: boolean;
    "billingTerms"?: BillingTermsReference;
    "invoicingCycle": AgreementType.InvoicingCycleEnum;
    "billAmount"?: number;
    "taxableFlag"?: boolean;
    "restrictDownPaymentFlag"?: boolean;
    "invoiceDescription"?: string;
    "topCommentFlag"?: boolean;
    "bottomCommentFlag"?: boolean;
    "workRole"?: WorkRoleReference;
    "workType"?: WorkTypeReference;
    "projectType"?: ProjectTypeReference;
    "invoiceTemplate"?: InvoiceTemplateReference;
    "billTime": AgreementType.BillTimeEnum;
    "billExpenses": AgreementType.BillExpensesEnum;
    "billProducts": AgreementType.BillProductsEnum;
    "billableTimeInvoiceFlag"?: boolean;
    "billableExpenseInvoiceFlag"?: boolean;
    "billableProductInvoiceFlag"?: boolean;
    "copyWorkRolesFlag"?: boolean;
    "copyWorkTypesFlag"?: boolean;
    "exclusionWorkRoleIds"?: Array<number>;
    "addAllWorkRoleExclusions"?: boolean;
    "removeAllWorkRoleExclusions"?: boolean;
    "exclusionWorkTypeIds"?: Array<number>;
    "addAllWorkTypeExclusions"?: boolean;
    "removeAllWorkTypeExclusions"?: boolean;
    "integrationXRef"?: string;
    "prorateFlag"?: boolean;
    "emailTemplate"?: EmailTemplateReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace AgreementType {

export type PrefixSuffixOptionEnum = 'Prefix' | 'Suffix';

export type ApplicationUnitsEnum = 'Amount' | 'Hours' | 'Incidents';

export type ApplicationCycleEnum = 'Contract2Weeks' | 'Contract4Weeks' | 'ContractYear' | 'CalendarMonth' | 'CalendarQuarter' | 'CalendarWeek' | 'ContractQuarter' | 'CalendarYear';

export type EmployeeCompRateEnum = 'Actual' | 'Hourly';

export type EmployeeCompNotExceedEnum = 'Billing' | 'Percent' | 'Amount';

export type InvoicingCycleEnum = 'CalendarYear' | 'ContractYear';

export type BillTimeEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillExpensesEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillProductsEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';
}
export interface AgreementTypeBoardDefault {
    "id"?: number;
    "type"?: AgreementTypeReference;
    "location": SystemLocationReference;
    "department"?: SystemDepartmentReference;
    "board"?: BoardReference;
    "serviceType"?: ServiceTypeReference;
    "defaultFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

/**
 * agreementType or configurationType is required
 */
export interface AgreementTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface AgreementTypeWorkRole {
    "id"?: number;
    "type"?: AgreementTypeReference;
    "workRole"?: WorkRoleReference;
    "effectiveDate"?: Date;
    "endingDate"?: Date;
    "rate"?: number;
    "rateType": AgreementTypeWorkRole.RateTypeEnum;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace AgreementTypeWorkRole {

export type RateTypeEnum = 'AdjAmount' | 'Custom' | 'Multiplier';
}
export interface AgreementTypeWorkRoleExclusion {
    "id"?: number;
    "type"?: AgreementTypeReference;
    "workRole": WorkRoleReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface AgreementTypeWorkType {
    "id"?: number;
    "type"?: AgreementTypeReference;
    "workType"?: WorkTypeReference;
    "effectiveDate"?: Date;
    "endingDate"?: Date;
    "rate"?: number;
    "rateType": AgreementTypeWorkType.RateTypeEnum;
    "billTime": AgreementTypeWorkType.BillTimeEnum;
    "hoursMin"?: number;
    "hoursMax"?: number;
    "roundBillHours"?: number;
    "overageRate"?: number;
    "overageRateType": AgreementTypeWorkType.OverageRateTypeEnum;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace AgreementTypeWorkType {

export type RateTypeEnum = 'AdjAmount' | 'Custom' | 'Multiplier';

export type BillTimeEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type OverageRateTypeEnum = 'AdjAmount' | 'Custom' | 'Multiplier';
}
export interface AgreementTypeWorkTypeExclusion {
    "id"?: number;
    "type"?: AgreementTypeReference;
    "workType": WorkTypeReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface AgreementWorkRole {
    "id"?: number;
    "workRole"?: WorkRoleReference;
    "locationId"?: number;
    "rateType": AgreementWorkRole.RateTypeEnum;
    "rate"?: number;
    "limitTo"?: number;
    "effectiveDate"?: Date;
    "endingDate"?: Date;
    "agreementId"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace AgreementWorkRole {

export type RateTypeEnum = 'AdjAmount' | 'Custom' | 'Multiplier';
}
export interface AgreementWorkRoleExclusion {
    "id"?: number;
    "workRole": WorkRoleReference;
    "agreementId"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface AgreementWorkType {
    "id"?: number;
    "workType"?: WorkTypeReference;
    "locationId"?: number;
    "rateType": AgreementWorkType.RateTypeEnum;
    "billTime": AgreementWorkType.BillTimeEnum;
    "rate"?: number;
    "hoursMax"?: number;
    "hoursMin"?: number;
    "roundBillHours"?: number;
    "overageRate"?: number;
    "overageRateType"?: AgreementWorkType.OverageRateTypeEnum;
    "agreementLimit"?: number;
    "site"?: SiteReference;
    "effectiveDate"?: Date;
    "endingDate"?: Date;
    "agreementId"?: number;
    "company"?: CompanyReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace AgreementWorkType {

export type RateTypeEnum = 'AdjAmount' | 'Custom' | 'Multiplier';

export type BillTimeEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type OverageRateTypeEnum = 'AdjAmount' | 'Custom' | 'Multiplier';
}
export interface AgreementWorkTypeExclusion {
    "id"?: number;
    "workType": WorkTypeReference;
    "agreementId"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface AuditTrailEntry {
    "text"?: string;
    "enteredDate"?: string;
    "enteredBy"?: string;
    "auditType"?: string;
    "auditSubType"?: string;
    "auditSource"?: string;
}

export interface AuthAnvil {
    "id"?: number;
    "serverLocationUrl": string;
    "siteId": number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

/**
 * Required when notifyType is set to: "Run Connectwise Automate Script"
 */
export interface AutomateScriptReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface BatchRequest {
    "id"?: string;
    "requests"?: Array<EndpointRequest>;

    /**
     * Metadata of the entity
     */
    "headers"?: Metadata;
}

export interface BatchResponse {
    "id"?: string;
    "responses"?: Array<EndpointResponse>;
}

export interface BillingCycle {
    "id"?: number;
    "identifier": string;
    "name": string;
    "defaultFlag": boolean;
    "inactiveFlag"?: boolean;
    "billingOptions"?: BillingOptionsReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface BillingCycleReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface BillingDeliveryReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface BillingOptionsReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface BillingSetup {
    "id"?: number;
    "remitName": string;
    "location": SystemLocationReference;
    "addressOne"?: string;
    "addressTwo"?: string;
    "city"?: string;
    "state"?: StateReference;
    "zip"?: string;
    "country"?: CountryReference;
    "phone"?: string;
    "invoiceTitle": string;
    "payableName": string;
    "topcomment"?: string;
    "invoiceFooter"?: string;
    "quoteFooter"?: string;
    "overallInvoiceDefault": InvoiceTemplateReference;
    "standardInvoiceActual"?: InvoiceTemplateReference;
    "standardInvoiceFixed"?: InvoiceTemplateReference;
    "progressInvoice"?: InvoiceTemplateReference;
    "agreementInvoice"?: InvoiceTemplateReference;
    "creditMemoInvoice"?: InvoiceTemplateReference;
    "downPaymentInvoice"?: InvoiceTemplateReference;
    "miscInvoice"?: InvoiceTemplateReference;
    "salesOrderInvoice"?: InvoiceTemplateReference;
    "excludeDoNotBillTimeFlag"?: boolean;
    "excludeDoNotBillExpenseFlag"?: boolean;
    "excludeDoNotBillProductFlag"?: boolean;
    "prefixSuffixFlag"?: BillingSetup.PrefixSuffixFlagEnum;
    "prefixSuffixText"?: string;
    "chargeAdjToFirmFlag"?: boolean;
    "noWatermarkFlag"?: boolean;
    "displayTaxFlag"?: boolean;
    "allowRestrictedDeptOnRoutingFlag"?: boolean;
    "billTicketSeparatelyFlag"?: boolean;
    "billTicketCompleteFlag"?: boolean;
    "billTicketUnapprovedFlag"?: boolean;
    "billProjectCompleteFlag"?: boolean;
    "billProjectUnapprovedFlag"?: boolean;
    "progressTimeFlag"?: boolean;
    "restrictProjectDownpaymentFlag"?: boolean;
    "billSalesOrderCompleteFlag"?: boolean;
    "billProductAfterShipFlag"?: boolean;
    "restrictDownpaymentFlag"?: boolean;
    "copyNonServiceProductsFlag"?: boolean;
    "copyServiceProductsFlag"?: boolean;
    "copyAgreementProductsFlag"?: boolean;
    "printLogoFlag"?: boolean;
    "readReceiptFlag"?: boolean;
    "deliveryReceiptFlag"?: boolean;
    "disableRoutingEmailFlag"?: boolean;
    "emailTemplate": OrderStatusEmailTemplateReference;
    "localizedCountry"?: CountryReference;
    "businessNumber"?: string;
    "currency"?: CurrencyReference;
    "customLabel"?: string;
    "customText"?: string;
    "companyCode"?: string;
    "excludeAvalaraFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace BillingSetup {

export type PrefixSuffixFlagEnum = 'Prefix' | 'Suffix';
}
export interface BillingSetupRouting {
    "id"?: number;
    "sequenceNumber": number;
    "invoiceRule": BillingSetupRouting.InvoiceRuleEnum;
    "routingRule": BillingSetupRouting.RoutingRuleEnum;
    "member"?: MemberReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace BillingSetupRouting {

export type InvoiceRuleEnum = 'Agreement' | 'All' | 'Project' | 'Standard';

export type RoutingRuleEnum = 'Account' | 'Department' | 'Creator' | 'Location' | 'Project' | 'Sales' | 'Member' | 'Territory';
}
export interface BillingStatus {
    "id"?: number;
    "name": string;
    "sortOrder"?: number;
    "defaultFlag"?: boolean;
    "closedFlag"?: boolean;
    "inactiveFlag"?: boolean;
    "sentFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface BillingStatusReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface BillingTerm {
    "id"?: number;
    "name": string;
    "defaultFlag": boolean;
    "dueDays": number;
    "termsXref"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface BillingTermsReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Board {
    "id"?: number;
    "name": string;
    "location": SystemLocationReference;
    "department": SystemDepartmentReference;
    "inactiveFlag"?: boolean;
    "signOffTemplate"?: ServiceSignoffReference;
    "sendToContactFlag"?: boolean;
    "contactTemplate"?: ServiceEmailTemplateReference;
    "sendToResourceFlag"?: boolean;
    "resourceTemplate"?: ServiceEmailTemplateReference;
    "projectFlag"?: boolean;

    /**
     * This field only shows if it is Project Board.
     */
    "showDependenciesFlag"?: boolean;

    /**
     * This field only shows if it is Project Board.
     */
    "showEstimatesFlag"?: boolean;
    "boardIcon"?: DocumentReference;
    "billTicketsAfterClosedFlag"?: boolean;
    "billTicketSeparatelyFlag"?: boolean;
    "billUnapprovedTimeExpenseFlag"?: boolean;
    "overrideBillingSetupFlag"?: boolean;
    "dispatchMember"?: MemberReference;
    "serviceManagerMember"?: MemberReference;
    "dutyManagerMember"?: MemberReference;
    "oncallMember"?: MemberReference;
    "workRole"?: WorkRoleReference;
    "workType"?: WorkTypeReference;
    "billTime"?: Board.BillTimeEnum;
    "billExpense"?: Board.BillExpenseEnum;
    "billProduct"?: Board.BillProductEnum;
    "autoCloseStatus"?: ServiceStatusReference;
    "autoAssignNewTicketsFlag"?: boolean;
    "autoAssignNewECTicketsFlag"?: boolean;
    "autoAssignNewPortalTicketsFlag"?: boolean;
    "discussionsLockedFlag"?: boolean;
    "timeEntryLockedFlag"?: boolean;
    "notifyEmailFrom"?: string;
    "notifyEmailFromName"?: string;
    "closedLoopDiscussionsFlag"?: boolean;
    "closedLoopResolutionFlag"?: boolean;
    "closedLoopInternalAnalysisFlag"?: boolean;
    "timeEntryDiscussionFlag"?: boolean;
    "timeEntryResolutionFlag"?: boolean;
    "timeEntryInternalAnalysisFlag"?: boolean;
    "problemSort"?: Board.ProblemSortEnum;
    "resolutionSort"?: Board.ResolutionSortEnum;
    "internalAnalysisSort"?: Board.InternalAnalysisSortEnum;
    "emailConnectorAllowReopenClosedFlag"?: boolean;

    /**
     * This field is only required when emailConnectorAllowReopenClosed is true
     */
    "emailConnectorReopenStatus"?: ServiceStatusReference;

    /**
     * This field can only be set when emailConnectorAllowReopenClosed is true
     */
    "emailConnectorReopenResourcesFlag"?: boolean;

    /**
     * This field can only be set when emailConnectorAllowReopenClosed is true
     */
    "emailConnectorNewTicketNoMatchFlag"?: boolean;

    /**
     * This field can only be set when emailConnectorAllowReopenClosed is true
     */
    "emailConnectorNeverReopenByDaysFlag"?: boolean;
    "emailConnectorReopenDaysLimit"?: number;
    "useMemberDisplayNameFlag"?: boolean;
    "sendToCCFlag"?: boolean;
    "autoAssignTicketOwnerFlag"?: boolean;
    "closedLoopAllFlag"?: boolean;
    "allSort"?: Board.AllSortEnum;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace Board {

export type BillTimeEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillExpenseEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillProductEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type ProblemSortEnum = 'Ascending' | 'Descending';

export type ResolutionSortEnum = 'Ascending' | 'Descending';

export type InternalAnalysisSortEnum = 'Ascending' | 'Descending';

export type AllSortEnum = 'Ascending' | 'Descending';
}
export interface BoardAutoAssignResource {
    "id"?: number;
    "notifyWho": NotificationRecipientReference;
    "member"?: MemberReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface BoardAutoTemplate {
    "id"?: number;
    "type": ServiceTypeReference;
    "subtype": ServiceSubTypeReference;
    "item": ServiceItemReference;
    "serviceTemplate": ServiceTemplateReference;
    "board"?: BoardReference;
    "summarySetting"?: BoardAutoTemplate.SummarySettingEnum;
    "discussionSetting"?: BoardAutoTemplate.DiscussionSettingEnum;
    "internalAnalysisSetting"?: BoardAutoTemplate.InternalAnalysisSettingEnum;
    "tasksSetting"?: BoardAutoTemplate.TasksSettingEnum;
    "documentsSetting"?: BoardAutoTemplate.DocumentsSettingEnum;
    "resourcesSetting"?: BoardAutoTemplate.ResourcesSettingEnum;
    "budgetHoursSetting"?: BoardAutoTemplate.BudgetHoursSettingEnum;
    "financeInformationSetting"?: BoardAutoTemplate.FinanceInformationSettingEnum;
    "autoApplyFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace BoardAutoTemplate {

export type SummarySettingEnum = 'Append' | 'Overwrite' | 'Ignore';

export type DiscussionSettingEnum = 'Append' | 'Overwrite' | 'Ignore';

export type InternalAnalysisSettingEnum = 'Append' | 'Overwrite' | 'Ignore';

export type TasksSettingEnum = 'Append' | 'Overwrite' | 'Ignore';

export type DocumentsSettingEnum = 'Append' | 'Overwrite' | 'Ignore';

export type ResourcesSettingEnum = 'Append' | 'Overwrite' | 'Ignore';

export type BudgetHoursSettingEnum = 'Append' | 'Overwrite' | 'Ignore';

export type FinanceInformationSettingEnum = 'Append' | 'Overwrite' | 'Ignore';
}
export interface BoardCopy {
    "id"?: number;
    "name": string;
}

export interface BoardDefault {
    "id"?: number;
    "board": BoardReference;
    "serviceType"?: ServiceTypeReference;
    "defaultFlag"?: boolean;
    "agreementId"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface BoardExcludedMember {
    "id"?: number;
    "memberId": number;
    "boardId"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface BoardItem {
    "id"?: number;
    "name": string;
    "inactiveFlag"?: boolean;
    "board"?: BoardReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface BoardItemAssociation {
    "id": number;
    "subTypeAssociationIds"?: Array<number>;
    "addAllSubTypesFlag"?: boolean;
    "removeAllSubTypesFlag"?: boolean;
    "item"?: ServiceItemReference;
    "board"?: BoardReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface BoardNotification {
    "id"?: number;
    "notifyWho": NotificationRecipientReference;
    "member"?: MemberReference;
    "email"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface BoardReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface BoardStatus {
    "id"?: number;
    "name": string;
    "board"?: BoardReference;
    "externalIntegrationXref"?: ExternalIntegrationStatusReference;
    "sortOrder"?: number;
    "displayOnBoard"?: boolean;
    "inactive"?: boolean;
    "closedStatus"?: boolean;
    "timeEntryNotAllowed"?: boolean;
    "defaultFlag"?: boolean;
    "escalationStatus": BoardStatus.EscalationStatusEnum;
    "customerPortalDescription"?: string;
    "customerPortalFlag"?: boolean;
    "emailTemplate"?: ServiceEmailTemplateReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace BoardStatus {

export type EscalationStatusEnum = 'NotResponded' | 'Responded' | 'ResolutionPlan' | 'Resolved' | 'NoEscalation';
}
export interface BoardStatusNotification {
    "id"?: number;
    "notifyWho": NotificationRecipientReference;
    "status"?: ServiceStatusReference;

    /**
     * Service Status Notification member must be entered if the notify type is "Specific Member"
     */
    "member"?: MemberReference;

    /**
     * Service Status Notification email must be entered if the notify type is "Email Address"
     */
    "email"?: string;
    "workflowStep"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface BoardSubType {
    "id"?: number;
    "name": string;
    "inactiveFlag"?: boolean;
    "typeAssociationIds"?: Array<number>;
    "addAllTypesFlag"?: boolean;
    "removeAllTypesFlag"?: boolean;
    "board"?: BoardReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface BoardTeam {
    "id"?: number;
    "name": string;
    "teamLeader": MemberReference;
    "members"?: Array<number>;
    "defaultFlag"?: boolean;
    "notifyOnTicketDelete"?: boolean;
    "boardId"?: number;
    "locationId"?: number;
    "businessUnitId"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface BoardType {
    "id"?: number;
    "name": string;
    "category"?: BoardType.CategoryEnum;
    "defaultFlag"?: boolean;
    "inactiveFlag"?: boolean;
    "requestForChangeFlag"?: boolean;
    "integrationXref"?: string;
    "board"?: BoardReference;
    "location"?: SystemLocationReference;
    "department"?: SystemDepartmentReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace BoardType {

export type CategoryEnum = 'Reactive' | 'Proactive';
}
export interface BoardTypeSubTypeItemAssociation {
    "id"?: number;
    "type"?: ServiceTypeReference;
    "subType"?: ServiceSubTypeReference;
    "item"?: ServiceItemReference;
    "board"?: BoardReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Calendar {
    "id"?: number;
    "name": string;
    "holidayList"?: HolidayListReference;
    "mondayStartTime"?: string;
    "mondayEndTime"?: string;
    "tuesdayStartTime"?: string;
    "tuesdayEndTime"?: string;
    "wednesdayStartTime"?: string;
    "wednesdayEndTime"?: string;
    "thursdayStartTime"?: string;
    "thursdayEndTime"?: string;
    "fridayStartTime"?: string;
    "fridayEndTime"?: string;
    "saturdayStartTime"?: string;
    "saturdayEndTime"?: string;
    "sundayStartTime"?: string;
    "sundayEndTime"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

/**
 * customCalendar is a required reference if basedOn SLA Hours Type is Custom
 */
export interface CalendarReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CalendarSetupReference {
    "id"?: number;
    "ownerId"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CallbackEntry {
    "id"?: number;
    "description"?: string;
    "url": string;
    "objectId": number;
    "type": string;
    "level": string;
    "memberId"?: number;
    "inactiveFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Campaign {
    "id"?: number;
    "name": string;
    "type": CampaignTypeReference;
    "subType": CampaignSubTypeReference;
    "status"?: CampaignStatusReference;
    "startDate": Date;
    "endDate"?: Date;
    "locationId"?: number;
    "member"?: MemberReference;
    "inactive"?: boolean;
    "inactiveDaysAfterEnd"?: number;
    "notes"?: string;
    "defaultGroup"?: GroupReference;
    "marketingManagerDefaultTrackId"?: number;
    "opportunityDefaultTrackId"?: number;
    "impressions"?: number;
    "budgetRevenue"?: number;
    "budgetCost"?: number;
    "actualCost"?: number;
    "budgetGrossMargin"?: number;
    "budgetROI"?: number;
    "actualRevenue"?: number;
    "actualGrossMargin"?: number;
    "actualROI"?: number;
    "emailsSent"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CampaignAudit {
    "id"?: number;
    "emailsSent": number;
    "emailsUnsent"?: number;
    "documentsCreated"?: number;
    "emailSubject"?: string;
    "group"?: GroupReference;
    "campaignId"?: number;
    "createdBy"?: string;
    "dateCreated"?: string;
}

export interface CampaignReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CampaignStatus {
    "id"?: number;
    "name": string;
    "defaultFlag"?: boolean;
    "inactiveFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CampaignStatusReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CampaignSubType {
    "id"?: number;
    "type": CampaignTypeReference;
    "name": string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CampaignSubTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CampaignType {
    "id"?: number;
    "name": string;
    "defaultFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CampaignTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CatalogComponent {
    "id"?: number;
    "sequenceNumber"?: number;
    "quantity": number;
    "catalogItem": CatalogItemReference;
    "hidePriceFlag"?: boolean;
    "hideItemIdentifierFlag"?: boolean;
    "hideDescriptionFlag"?: boolean;
    "hideQuantityFlag"?: boolean;
    "hideExtendedPriceFlag"?: boolean;
    "parentCatalogItem"?: CatalogItemReference;
    "price"?: number;
    "cost"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CatalogItem {
    "id"?: number;
    "identifier": string;
    "description": string;
    "inactiveFlag"?: boolean;
    "subcategory": ProductSubCategoryReference;
    "type": ProductTypeReference;

    /**
     * Defaults to Non-Inventory
     */
    "productClass"?: CatalogItem.ProductClassEnum;
    "serializedFlag"?: boolean;
    "serializedCostFlag"?: boolean;
    "phaseProductFlag"?: boolean;
    "unitOfMeasure"?: UnitOfMeasureReference;
    "minStockLevel"?: number;
    "price"?: number;
    "cost"?: number;
    "priceAttribute"?: CatalogItem.PriceAttributeEnum;
    "taxableFlag"?: boolean;
    "customerDescription": string;
    "manufacturer"?: ManufacturerReference;
    "manufacturerPartNumber"?: string;
    "vendor"?: CompanyReference;
    "vendorSku"?: string;
    "notes"?: string;
    "integrationXRef"?: string;
    "dateEntered"?: string;
    "category"?: ProductCategoryReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "customFields"?: Array<CustomFieldValue>;
}

export namespace CatalogItem {

export type ProductClassEnum = 'Agreement' | 'Bundle' | 'Inventory' | 'NonInventory' | 'Service';

export type PriceAttributeEnum = 'FixedFee' | 'NotToExceed' | 'TimeAndMaterials' | 'OverrideRate';
}
export interface CatalogItemReference {
    "id"?: number;
    "identifier"?: string;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Category {
    "id"?: number;
    "name": string;
    "inactiveFlag"?: boolean;
    "priceLevelXref"?: string;
    "integrationXref"?: string;
    "locationIds"?: Array<number>;
    "addAllLocations"?: boolean;
    "removeAllLocations"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Certification {
    "id"?: number;
    "name": string;
    "company": CompanyReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CertificationReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ChargeCode {
    "id"?: number;
    "name": string;
    "company": CompanyReference;
    "location"?: SystemLocationReference;
    "department"?: SystemDepartmentReference;
    "billTime"?: ChargeCode.BillTimeEnum;
    "expenseEntryFlag"?: boolean;
    "allowAllExpenseTypeFlag"?: boolean;
    "timeEntryFlag"?: boolean;

    /**
     * on UPDATE, if timeEntryFlag is set to true, workType will be required.
     */
    "workType"?: WorkTypeReference;
    "workRole"?: WorkRoleReference;
    "integrationXref"?: string;
    "expenseTypeIds"?: Array<number>;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace ChargeCode {

export type BillTimeEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';
}
export interface ChargeCodeExpenseType {
    "id"?: number;
    "type": ExpenseTypeReference;
    "chargeCode"?: ChargeCodeReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ChargeCodeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Classification {
    "id"?: number;
    "name"?: string;
    "multiplier"?: number;
    "defaultFlag"?: boolean;
    "companyFlag"?: boolean;
    "employeeFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ClassificationReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ClearPickerRequest {
    "member"?: MemberReference;
    "type"?: ClearPickerRequest.TypeEnum;
}

export namespace ClearPickerRequest {

export type TypeEnum = 'Company' | 'Vendor';
}
export interface Code {
    "id"?: number;
    "name": string;
    "description": string;
    "boardId"?: number;
    "locationId"?: number;
    "businessUnitId"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Commission {
    "id"?: number;
    "member": MemberReference;
    "commissionPercent"?: number;
    "dateStart"?: Date;
    "dateEnd"?: Date;
    "location"?: SystemLocationReference;
    "department"?: SystemDepartmentReference;
    "company"?: CompanyReference;
    "site"?: SiteReference;
    "agreement"?: AgreementReference;
    "project"?: ProjectReference;
    "serviceBoard"?: BoardReference;
    "ticket"?: TicketReference;
    "territory"?: SystemLocationReference;
    "billingMethod"?: Commission.BillingMethodEnum;
    "serviceType"?: ServiceTypeReference;
    "projectBoard"?: ProjectBoardReference;
    "projectType"?: ProjectTypeReference;
    "agreementType"?: AgreementTypeReference;
    "numberOfMonths"?: number;
    "productCategory"?: ProductCategoryReference;
    "productSubCategory"?: ProductSubCategoryReference;
    "item"?: IvItemReference;
    "commissionBasis"?: Commission.CommissionBasisEnum;
    "invoiceOption"?: Commission.InvoiceOptionEnum;
    "servicesFlag"?: boolean;
    "agreementsFlag"?: boolean;
    "productsFlag"?: boolean;
    "myOpportunitiesFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace Commission {

export type BillingMethodEnum = 'Agreement' | 'CreditMemo' | 'DownPayment' | 'Miscellaneous' | 'Progress' | 'Standard';

export type CommissionBasisEnum = 'SalesAmount' | 'GrossProfit';

export type InvoiceOptionEnum = 'PaidInvoices' | 'AllInvoices';
}
export interface CommunicationTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Company {
    "id"?: number;
    "identifier": string;
    "name": string;
    "status"?: CompanyStatusReference;
    "type"?: CompanyTypeReference;

    /**
     * At least one address field is required -- addressLine1, addressLine2, city, state, zip and/or country
     */
    "addressLine1"?: string;

    /**
     * At least one address field is required -- addressLine1, addressLine2, city, state, zip and/or country
     */
    "addressLine2"?: string;

    /**
     * At least one address field is required -- addressLine1, addressLine2, city, state, zip and/or country
     */
    "city"?: string;

    /**
     * At least one address field is required -- addressLine1, addressLine2, city, state, zip and/or country
     */
    "state"?: string;

    /**
     * At least one address field is required -- addressLine1, addressLine2, city, state, zip and/or country
     */
    "zip"?: string;

    /**
     * At least one address field is required -- addressLine1, addressLine2, city, state, zip and/or country
     */
    "country"?: CountryReference;
    "phoneNumber"?: string;
    "faxNumber"?: string;
    "website"?: string;
    "territoryId"?: number;
    "marketId"?: number;
    "accountNumber"?: string;
    "defaultContact"?: ContactReference;
    "dateAcquired"?: Date;
    "sicCode"?: SicCodeReference;
    "parentCompany"?: CompanyReference;
    "annualRevenue"?: number;
    "numberOfEmployees"?: number;
    "ownershipType"?: OwnershipTypeReference;

    /**
     * The specified system time zone for the Company
     */
    "timeZone"?: TimeZoneSetupReference;
    "leadSource"?: string;
    "leadFlag"?: boolean;
    "unsubscribeFlag"?: boolean;
    "calendarId"?: number;
    "userDefinedField1"?: string;
    "userDefinedField2"?: string;
    "userDefinedField3"?: string;
    "userDefinedField4"?: string;
    "userDefinedField5"?: string;
    "userDefinedField6"?: string;
    "userDefinedField7"?: string;
    "userDefinedField8"?: string;
    "userDefinedField9"?: string;
    "userDefinedField10"?: string;
    "vendorIdentifier"?: string;
    "taxIdentifier"?: string;

    /**
     * New companies will be created with the default tax code unless otherwise specified.
     */
    "taxCode"?: TaxCodeReference;
    "billingTerms"?: BillingTermsReference;
    "invoiceTemplate"?: InvoiceTemplateReference;
    "pricingSchedule"?: PricingScheduleReference;

    /**
     * Based on CompanyEntityType Report
     */
    "companyEntityType"?: EntityTypeReference;
    "billToCompany"?: CompanyReference;
    "billingSite"?: SiteReference;
    "billingContact"?: ContactReference;
    "invoiceDeliveryMethod"?: BillingDeliveryReference;
    "invoiceToEmailAddress"?: string;
    "invoiceCCEmailAddress"?: string;
    "deletedFlag"?: boolean;
    "dateDeleted"?: Date;
    "deletedBy"?: string;
    "mobileGuid"?: Guid;
    "facebookUrl"?: string;
    "twitterUrl"?: string;
    "linkedInUrl"?: string;
    "currency"?: CurrencyReference;
    "territoryManager"?: MemberReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "customFields"?: Array<CustomFieldValue>;
}

export interface CompanyCustomNote {
    "id"?: number;
    "customNote": string;
    "status": CompanyStatusReference;
    "company"?: CompanyReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CompanyGroup {
    "id"?: number;
    "group": GroupReference;
    "company"?: CompanyReference;
    "defaultContactFlag"?: boolean;
    "allContactsFlag"?: boolean;
    "removeAllContactsFlag"?: boolean;
    "unsubscribeFlag"?: boolean;
    "contactIds"?: Array<number>;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CompanyManagementSummary {
    "id"?: number;
    "managementSolution"?: ManagementSolutionReference;
    "groupIdentifier": string;

    /**
     * deviceType is required if the managementSolution is Legacy
     */
    "deviceType"?: CompanyManagementSummary.DeviceTypeEnum;
    "agreement"?: AgreementReference;
    "snmpMachines"?: number;
    "totalWorkstations"?: number;
    "totalServers"?: number;
    "totalWindowsServers"?: number;
    "totalWindowsWorkstations"?: number;
    "totalManagedMachines"?: number;
    "serversOffline"?: number;
    "serversDiskSpaceLow"?: number;
    "failedBackupJobs"?: number;
    "totalNotifications"?: number;
    "successfulBackupJobs"?: number;
    "serverAvailability"?: number;
    "virusesRemoved"?: number;
    "spywareItemsRemoved"?: number;
    "windowsPatchesInstalled"?: number;
    "diskCleanups"?: number;
    "diskDefragmentations"?: number;
    "fullyPatchedMachines"?: number;
    "missingOneTwoPatchesMachines"?: number;
    "missingThreeFivePatchesMachines"?: number;
    "missingMoreFivePatchesMachines"?: number;
    "missingUnscannedPatchesMachines"?: number;
    "alertsGenerated"?: string;
    "internetConnectivity"?: number;
    "diskSpaceCleanedMb"?: number;
    "missingSecurityPatches"?: string;
    "cpuUtilization"?: number;
    "memoryUtilization"?: number;
    "company"?: CompanyReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace CompanyManagementSummary {

export type DeviceTypeEnum = 'WorkstationsAndServers' | 'BackupStats' | 'Servers' | 'Workstations';
}
export interface CompanyMerge {
    "toCompanyId": number;
    "name"?: CompanyMerge.NameEnum;
    "identifier"?: CompanyMerge.IdentifierEnum;
    "status"?: CompanyMerge.StatusEnum;
    "type"?: CompanyMerge.TypeEnum;
    "primaryAddress"?: CompanyMerge.PrimaryAddressEnum;
    "primaryContact"?: CompanyMerge.PrimaryContactEnum;
    "phone"?: CompanyMerge.PhoneEnum;
    "fax"?: CompanyMerge.FaxEnum;
    "website"?: CompanyMerge.WebsiteEnum;
    "market"?: CompanyMerge.MarketEnum;
    "territory"?: CompanyMerge.TerritoryEnum;
    "revenue"?: CompanyMerge.RevenueEnum;
    "revenueYear"?: CompanyMerge.RevenueYearEnum;
    "numberOfEmployees"?: CompanyMerge.NumberOfEmployeesEnum;
    "sicCode"?: CompanyMerge.SicCodeEnum;
    "dateAcquired"?: CompanyMerge.DateAcquiredEnum;
    "timeZone"?: CompanyMerge.TimeZoneEnum;
    "sourceList"?: CompanyMerge.SourceListEnum;
    "userDefinedField1"?: CompanyMerge.UserDefinedField1Enum;
    "userDefinedField2"?: CompanyMerge.UserDefinedField2Enum;
    "userDefinedField3"?: CompanyMerge.UserDefinedField3Enum;
    "userDefinedField4"?: CompanyMerge.UserDefinedField4Enum;
    "userDefinedField5"?: CompanyMerge.UserDefinedField5Enum;
    "userDefinedField6"?: CompanyMerge.UserDefinedField6Enum;
    "userDefinedField7"?: CompanyMerge.UserDefinedField7Enum;
    "userDefinedField8"?: CompanyMerge.UserDefinedField8Enum;
    "userDefinedField9"?: CompanyMerge.UserDefinedField9Enum;
    "userDefinedField10"?: CompanyMerge.UserDefinedField10Enum;
    "billingAddress"?: CompanyMerge.BillingAddressEnum;
    "billingContact"?: CompanyMerge.BillingContactEnum;
    "taxCode"?: CompanyMerge.TaxCodeEnum;
    "accountNumber"?: CompanyMerge.AccountNumberEnum;
    "billingTerms"?: CompanyMerge.BillingTermsEnum;
    "notes"?: CompanyMerge.NotesEnum;
    "sites"?: CompanyMerge.SitesEnum;
    "activities"?: CompanyMerge.ActivitiesEnum;
    "opportunities"?: CompanyMerge.OpportunitiesEnum;
    "services"?: CompanyMerge.ServicesEnum;
    "projects"?: CompanyMerge.ProjectsEnum;
    "contacts"?: CompanyMerge.ContactsEnum;
    "documents"?: CompanyMerge.DocumentsEnum;
}

export namespace CompanyMerge {

export type NameEnum = 'From' | 'To';

export type IdentifierEnum = 'From' | 'To';

export type StatusEnum = 'From' | 'To';

export type TypeEnum = 'From' | 'To';

export type PrimaryAddressEnum = 'From' | 'To';

export type PrimaryContactEnum = 'From' | 'To';

export type PhoneEnum = 'From' | 'To';

export type FaxEnum = 'From' | 'To';

export type WebsiteEnum = 'From' | 'To';

export type MarketEnum = 'From' | 'To';

export type TerritoryEnum = 'From' | 'To';

export type RevenueEnum = 'From' | 'To';

export type RevenueYearEnum = 'From' | 'To';

export type NumberOfEmployeesEnum = 'From' | 'To';

export type SicCodeEnum = 'From' | 'To';

export type DateAcquiredEnum = 'From' | 'To';

export type TimeZoneEnum = 'From' | 'To';

export type SourceListEnum = 'From' | 'To';

export type UserDefinedField1Enum = 'From' | 'To';

export type UserDefinedField2Enum = 'From' | 'To';

export type UserDefinedField3Enum = 'From' | 'To';

export type UserDefinedField4Enum = 'From' | 'To';

export type UserDefinedField5Enum = 'From' | 'To';

export type UserDefinedField6Enum = 'From' | 'To';

export type UserDefinedField7Enum = 'From' | 'To';

export type UserDefinedField8Enum = 'From' | 'To';

export type UserDefinedField9Enum = 'From' | 'To';

export type UserDefinedField10Enum = 'From' | 'To';

export type BillingAddressEnum = 'From' | 'To';

export type BillingContactEnum = 'From' | 'To';

export type TaxCodeEnum = 'From' | 'To';

export type AccountNumberEnum = 'From' | 'To';

export type BillingTermsEnum = 'From' | 'To';

export type NotesEnum = 'Discard' | 'Merge';

export type SitesEnum = 'Discard' | 'Merge';

export type ActivitiesEnum = 'Discard' | 'Merge';

export type OpportunitiesEnum = 'Discard' | 'Merge';

export type ServicesEnum = 'Discard' | 'Merge';

export type ProjectsEnum = 'Discard' | 'Merge';

export type ContactsEnum = 'Discard' | 'Merge';

export type DocumentsEnum = 'Discard' | 'Merge';
}
export interface CompanyNote {
    "id"?: number;
    "text": string;
    "type"?: NoteTypeReference;
    "flagged"?: boolean;
    "enteredBy"?: string;
    "company"?: CompanyReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CompanyPickerItem {
    "id"?: number;
    "member"?: MemberReference;

    /**
     * The company or vendor selected by member from the company/vendor picker component
     */
    "company": CompanyReference;
    "companyStatus"?: CompanyStatusReference;
    "companyType"?: CompanyTypeReference;
    "companySite"?: SiteReference;
    "companyLocation"?: SystemLocationReference;
    "companyCountry"?: CountryReference;

    /**
     * If true, this record was created by the vendor picker component. Otherwise, the record was created by the company picker component.
     */
    "vendorPickerFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

/**
 * Vendor Can be either Member or Company Reference
 */
export interface CompanyReference {
    "id"?: number;
    "identifier"?: string;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CompanySite {
    "id"?: number;
    "name": string;
    "addressLine1"?: string;
    "addressLine2"?: string;
    "city"?: string;
    "state"?: string;
    "zip"?: string;
    "country"?: CountryReference;
    "addressFormat"?: string;
    "phoneNumber"?: string;
    "faxNumber"?: string;
    "taxCodeId"?: number;
    "expenseReimbursement"?: number;
    "primaryAddressFlag"?: boolean;
    "defaultShippingFlag"?: boolean;
    "defaultBillingFlag"?: boolean;
    "defaultMailingFlag"?: boolean;
    "mobileGuid"?: Guid;
    "calendar"?: CalendarReference;
    "timeZone"?: TimeZoneSetupReference;
    "company"?: CompanyReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CompanyStatus {
    "id"?: number;
    "name": string;
    "defaultFlag"?: boolean;
    "inactiveFlag"?: boolean;
    "notifyFlag"?: boolean;
    "disallowSavingFlag"?: boolean;
    "notificationMessage"?: string;
    "customNoteFlag"?: boolean;
    "cancelOpenTracksFlag"?: boolean;
    "track"?: TrackReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

/**
 * Required when notifyType is set to: "Change Company Status"
 */
export interface CompanyStatusReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

/**
 * A list of customers for which the member holds a team role
 */
export interface CompanyTeam {
    "id"?: number;
    "company"?: CompanyReference;
    "teamRole": TeamRoleReference;
    "locationId"?: number;
    "businessUnitId"?: number;
    "contact"?: ContactReference;
    "member"?: MemberReference;
    "accountManagerFlag"?: boolean;
    "techFlag"?: boolean;
    "salesFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "count"?: number;
    "reAssignToMember"?: MemberReference;
    "reAssignToContact"?: ContactReference;
}

export interface CompanyType {
    "id"?: number;
    "name": string;
    "defaultFlag"?: boolean;
    "vendorFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CompanyTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Configuration {
    "id"?: number;
    "name": string;
    "type": ConfigurationTypeReference;
    "status"?: ConfigurationStatusReference;
    "company": CompanyReference;
    "contact"?: ContactReference;
    "site"?: SiteReference;
    "locationId"?: number;
    "businessUnitId"?: number;
    "deviceIdentifier"?: string;
    "serialNumber"?: string;
    "modelNumber"?: string;
    "tagNumber"?: string;
    "purchaseDate"?: Date;
    "installationDate"?: Date;
    "installedBy"?: MemberReference;
    "warrantyExpirationDate"?: Date;
    "vendorNotes"?: string;
    "notes"?: string;
    "macAddress"?: string;
    "lastLoginName"?: string;
    "billFlag"?: boolean;
    "backupSuccesses"?: number;
    "backupIncomplete"?: number;
    "backupFailed"?: number;
    "backupRestores"?: number;
    "lastBackupDate"?: Date;
    "backupServerName"?: string;
    "backupBillableSpaceGb"?: number;
    "backupProtectedDeviceList"?: string;
    "backupYear"?: number;
    "backupMonth"?: number;
    "ipAddress"?: string;
    "defaultGateway"?: string;
    "osType"?: string;
    "osInfo"?: string;
    "cpuSpeed"?: string;
    "ram"?: string;
    "localHardDrives"?: string;
    "parentConfigurationId"?: number;
    "vendor"?: CompanyReference;
    "manufacturer"?: ManufacturerReference;
    "questions"?: Array<ConfigurationQuestion>;
    "activeFlag"?: boolean;
    "managementLink"?: string;
    "remoteLink"?: string;
    "sla"?: SLAReference;
    "mobileGuid"?: Guid;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "displayVendorFlag"?: boolean;
    "customFields"?: Array<CustomFieldValue>;
}

export interface ConfigurationQuestion {
    "answerId"?: number;
    "questionId"?: number;
    "question"?: string;
    "answer"?: string;
    "sequenceNumber"?: number;
    "numberOfDecimals"?: number;
    "fieldType"?: ConfigurationQuestion.FieldTypeEnum;
    "requiredFlag"?: boolean;
}

export namespace ConfigurationQuestion {

export type FieldTypeEnum = 'Button' | 'Checkbox' | 'Currency' | 'Date' | 'Hyperlink' | 'IPAddress' | 'Number' | 'Password' | 'Percent' | 'Text' | 'TextArea';
}
export interface ConfigurationReference {
    "id"?: number;
    "deviceIdentifier"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ConfigurationStatus {
    "id"?: number;
    "description": string;
    "closedFlag"?: boolean;
    "defaultFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ConfigurationStatusReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ConfigurationType {
    "id"?: number;
    "name": string;
    "inactiveFlag"?: boolean;
    "systemFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ConfigurationTypeQuestion {
    "id"?: number;
    "configurationType"?: ConfigurationTypeReference;
    "fieldType": ConfigurationTypeQuestion.FieldTypeEnum;
    "entryType": ConfigurationTypeQuestion.EntryTypeEnum;
    "sequenceNumber": number;
    "question": string;
    "numberOfDecimals"?: number;
    "requiredFlag"?: boolean;
    "inactiveFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace ConfigurationTypeQuestion {

export type FieldTypeEnum = 'Button' | 'Checkbox' | 'Currency' | 'Date' | 'Hyperlink' | 'IPAddress' | 'Number' | 'Password' | 'Percent' | 'Text' | 'TextArea';

export type EntryTypeEnum = 'EntryField' | 'List' | 'Option';
}
export interface ConfigurationTypeQuestionReference {
    "id"?: number;
    "question"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ConfigurationTypeQuestionValue {
    "id"?: number;
    "configurationType"?: ConfigurationTypeReference;
    "question"?: ConfigurationTypeQuestionReference;
    "value": string;
    "defaultFlag"?: boolean;
    "inactiveFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ConfigurationTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ConnectWiseHostedSetup {
    "id"?: number;

    /**
     * Can be obtained via ConnectWiseHostedApiScreen report
     */
    "screenId": number;
    "description": string;
    "url": string;
    "type": ConnectWiseHostedSetup.TypeEnum;
    "origin"?: string;
    "podHeight"?: number;
    "toolbarButtonDialogHeight"?: number;
    "toolbarButtonDialogWidth"?: number;

    /**
     * Only required for ToolbarButtons
     */
    "toolbarButtonText"?: string;
    "toolbarButtonToolTip"?: string;
    "toolbarButtonIconDocumentId"?: number;
    "disabledFlag"?: boolean;
    "createdBy"?: string;
    "dateCreated"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace ConnectWiseHostedSetup {

export type TypeEnum = 'Tab' | 'Pod' | 'ToolbarButton';
}
export interface Contact {
    "id"?: number;
    "firstName": string;
    "lastName"?: string;
    "type"?: ContactTypeReference;
    "company"?: CompanyReference;
    "site"?: SiteReference;
    "addressLine1"?: string;
    "addressLine2"?: string;
    "city"?: string;
    "state"?: string;
    "zip"?: string;
    "country"?: string;
    "relationship"?: RelationshipReference;
    "department"?: ContactDepartmentReference;
    "inactiveFlag"?: boolean;
    "defaultMergeContactId"?: number;
    "securityIdentifier"?: string;
    "managerContactId"?: number;
    "assistantContactId"?: number;
    "title"?: string;
    "school"?: string;
    "nickName"?: string;
    "marriedFlag"?: boolean;
    "childrenFlag"?: boolean;
    "significantOther"?: string;
    "portalPassword"?: string;
    "portalSecurityLevel"?: number;
    "disablePortalLoginFlag"?: boolean;
    "unsubscribeFlag"?: boolean;
    "gender"?: Contact.GenderEnum;
    "birthDay"?: Date;
    "anniversary"?: Date;
    "presence"?: Contact.PresenceEnum;
    "mobileGuid"?: Guid;
    "facebookUrl"?: string;
    "twitterUrl"?: string;
    "linkedInUrl"?: string;
    "defaultBillingFlag"?: boolean;
    "defaultFlag"?: boolean;
    "communicationItems"?: Array<ContactCommunicationItem>;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "customFields"?: Array<CustomFieldValue>;
}

export namespace Contact {

export type GenderEnum = 'Male' | 'Female';

export type PresenceEnum = 'Online' | 'DoNotDisturb' | 'Away' | 'Offline' | 'NoAgent';
}
export interface ContactCommunication {
    "id"?: number;
    "contactId"?: number;
    "type": CommunicationTypeReference;
    "value": string;
    "extension"?: string;
    "defaultFlag"?: boolean;
    "mobileGuid"?: Guid;
    "communicationType"?: ContactCommunication.CommunicationTypeEnum;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace ContactCommunication {

export type CommunicationTypeEnum = 'Phone' | 'Fax' | 'Email';
}
export interface ContactCommunicationItem {
    "id"?: number;
    "type": CommunicationTypeReference;
    "value": string;
    "extension"?: string;
    "defaultFlag"?: boolean;
    "communicationType"?: ContactCommunicationItem.CommunicationTypeEnum;
}

export namespace ContactCommunicationItem {

export type CommunicationTypeEnum = 'Phone' | 'Fax' | 'Email';
}
export interface ContactDepartment {
    "id"?: number;
    "name": string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ContactDepartmentReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ContactGroup {
    "id"?: number;
    "group": GroupReference;
    "contact"?: ContactReference;
    "description"?: string;
    "unsubscribeFlag"?: boolean;
    "companyUnsubcribedEmailMessage"?: string;
    "companyGroupUnsubscribedEmailMessage"?: string;
    "contactUnsubscribedEmailMessage"?: string;
    "contactGroupUnsubscribedEmailMessage"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ContactNote {
    "id"?: number;
    "contactId"?: number;
    "text": string;
    "type"?: NoteTypeReference;
    "flagged"?: boolean;
    "enteredBy"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ContactReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ContactRelationship {
    "id"?: number;
    "name": string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ContactType {
    "id"?: number;
    "description": string;
    "defaultFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ContactTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Conversion {
    "id"?: number;
    "quantity": number;
    "uomType": UnitOfMeasureReference;
    "parentUOM"?: UnitOfMeasureReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CorporateStructure {
    "id"?: number;
    "levelCount"?: CorporateStructure.LevelCountEnum;
    "level1Name"?: string;
    "level2Name"?: string;
    "level3Name"?: string;
    "level4Name"?: string;
    "level5Name"?: string;
    "fiscalYearStart": CorporateStructure.FiscalYearStartEnum;
    "locationCaption": string;
    "groupCaption": string;
    "baseCurrency": CurrencyReference;
    "president"?: MemberReference;
    "chiefOperatingOfficer"?: MemberReference;
    "controller"?: MemberReference;
    "dispatcher"?: MemberReference;
    "serviceManager"?: MemberReference;
    "dutyManager"?: MemberReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace CorporateStructure {

export type LevelCountEnum = 'Level1' | 'Level2' | 'Level3' | 'Level4' | 'Level5';

export type FiscalYearStartEnum = 'January' | 'February' | 'March' | 'April' | 'May' | 'June' | 'July' | 'August' | 'September' | 'October' | 'November' | 'December';
}
export interface CorporateStructureLevel {
    "id"?: number;
    "name"?: string;
}

export interface CorporateStructureLevelReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Count {
    "count"?: number;
}

export interface Country {
    "id"?: number;
    "name": string;
    "defaultFlag"?: boolean;
    "currency": CurrencyReference;
    "cityCaption"?: string;
    "stateCaption"?: string;
    "zipCaption"?: string;
    "zipMinimumLength"?: number;
    "dialingPrefix"?: string;
    "addressFormat"?: AddressFormatReference;
    "countryCode"?: string;
    "localizationCaptionOne"?: string;
    "localizationValueOne"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

/**
 * At least one address field is required -- addressLine1, addressLine2, city, state, zip and/or country
 */
export interface CountryReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CreateAccountingBatchRequest {
    "id"?: number;
    "batchIdentifier": string;
    "glInterfaceIdentifier"?: string;

    /**
     * Batch must export Invoices, Expenses or Products
     */
    "exportInvoicesFlag"?: boolean;

    /**
     * Batch must export Invoices, Expenses or Products
     */
    "exportExpensesFlag"?: boolean;

    /**
     * Batch must export Invoices, Expenses or Products
     */
    "exportProductsFlag"?: boolean;
    "processedRecordIds": Array<number>;
    "summarizeExpenses"?: boolean;
}

export interface Crm {
    "id"?: number;
    "companyListCount"?: number;
    "lockProbabilityFlag"?: boolean;
    "accountManagerRole": TeamRoleReference;
    "technicalContactRole": TeamRoleReference;
    "salesRepRole": TeamRoleReference;
    "companyIdGenerationFlag"?: boolean;
    "excludeSpacesFlag"?: boolean;
    "field1Caption"?: string;
    "field2Caption"?: string;
    "field3Caption"?: string;
    "field4Caption"?: string;
    "field5Caption"?: string;
    "field6Caption"?: string;
    "field7Caption"?: string;
    "field8Caption"?: string;
    "field9Caption"?: string;
    "field10Caption"?: string;
    "primaryRepCaption"?: string;
    "secondaryRepCaption"?: string;
    "other1Caption"?: string;
    "other2Caption"?: string;
    "defaultYear"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Currency {
    "id"?: number;
    "currencyIdentifier": string;
    "name": string;
    "symbol"?: string;
    "displayIdFlag"?: boolean;
    "displaySymbolFlag"?: boolean;
    "isoCode": string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CurrencyReference {
    "id"?: number;
    "symbol"?: string;
    "isoCode"?: string;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CustomFieldValue {
    "id"?: number;
    "caption"?: string;
    "type"?: CustomFieldValue.TypeEnum;
    "entryMethod"?: CustomFieldValue.EntryMethodEnum;
    "numberOfDecimals"?: number;
    "value"?: string;
}

export namespace CustomFieldValue {

export type TypeEnum = 'Button' | 'Checkbox' | 'Currency' | 'Date' | 'Hyperlink' | 'IPAddress' | 'Number' | 'Password' | 'Percent' | 'Text' | 'TextArea';

export type EntryMethodEnum = 'EntryField' | 'List' | 'Option';
}
export interface CustomReport {
    "id"?: number;
    "reportLink": string;
    "name": string;

    /**
     * The Module Name
     */
    "module": CustomReport.ModuleEnum;
    "description": string;
    "generatedFlag"?: boolean;
    "parameterPrefix"?: string;
    "parameterSeparator"?: string;
    "parameterNameSeparator"?: string;
    "parameterSuffix"?: string;
    "locationFlag"?: boolean;

    /**
     * Parameter unique identifier for the Custom Report's Location parameter
     */
    "locationParamId"?: number;
    "locationDefaultFlag"?: boolean;
    "locationOverride"?: string;
    "departmentFlag"?: boolean;

    /**
     * Parameter unique identifier for the Custom Report's Department parameter
     */
    "departmentParamId"?: number;
    "departmentDefaultFlag"?: boolean;
    "departmentOverride"?: string;
    "territoryFlag"?: boolean;

    /**
     * Parameter unique identifier for the Custom Report's Terriroty parameter
     */
    "territoryParamId"?: number;
    "territoryDefaultFlag"?: boolean;
    "territoryOverride"?: string;
    "companyFlag"?: boolean;

    /**
     * Parameter unique identifier for the Custom Report's Company parameter
     */
    "companyParamId"?: number;
    "companyOverride"?: string;
    "memberFlag"?: boolean;

    /**
     * Parameter unique identifier for the Custom Report's Member parameter
     */
    "memberParamId"?: number;
    "memberOverride"?: string;
    "startDateFlag"?: boolean;

    /**
     * Parameter unique identifier for the Custom Report's Start Date parameter
     */
    "startDateParamId"?: number;
    "startDateOverride"?: string;
    "endDateFlag"?: boolean;

    /**
     * Parameter unique identifier for the Custom Report's End Date parameter
     */
    "endDateParamId"?: number;
    "endDateOverride"?: string;
    "oppTypeFlag"?: boolean;

    /**
     * Parameter unique identifier for the Custom Report's Opportunity Type parameter
     */
    "oppTypeParamId"?: number;
    "oppTypeOverride"?: string;
    "opportunityFlag"?: boolean;

    /**
     * Parameter unique identifier for the Custom Report's Opportunity parameter
     */
    "opportunityParamId"?: number;
    "opportunityOverride"?: string;
    "marketingCampaignFlag"?: boolean;

    /**
     * Parameter unique identifier for the Custom Report's Marketing Campaign parameter
     */
    "marketingCampaignParamId"?: number;
    "marketingCampaignOverride"?: string;
    "serviceBoardFlag"?: boolean;

    /**
     * Parameter unique identifier for the Custom Report's Service Board parameter
     */
    "serviceBoardParamId"?: number;
    "serviceBoardDefaultFlag"?: boolean;
    "serviceBoardOverride"?: string;
    "serviceTypeFlag"?: boolean;

    /**
     * Parameter unique identifier for the Custom Report's Service Type parameter
     */
    "serviceTypeParamId"?: number;
    "serviceTypeOverride"?: string;
    "serviceStatusFlag"?: boolean;

    /**
     * Parameter unique identifier for the Custom Report's Service Status parameter
     */
    "serviceStatusParamId"?: number;
    "serviceStatusOverride"?: string;
    "agreementTypeFlag"?: boolean;

    /**
     * Parameter unique identifier for the Custom Report's Agreement Type parameter
     */
    "agreementTypeParamId"?: number;
    "agreementTypeOverride"?: string;
    "agreementFlag"?: boolean;

    /**
     * Parameter unique identifier for the Custom Report's Agreement parameter
     */
    "agreementParamId"?: number;
    "agreementOverride"?: string;
    "projectTypeFlag"?: boolean;

    /**
     * Parameter unique identifier for the Custom Report's Project Type parameter
     */
    "projectTypeParamId"?: number;
    "projectTypeOverride"?: string;
    "projectFlag"?: boolean;

    /**
     * Parameter unique identifier for the Custom Report's Project parameter
     */
    "projectParamId"?: number;
    "projectOverride"?: string;
    "workRoleFlag"?: boolean;

    /**
     * Parameter unique identifier for the Custom Report's Work Role parameter
     */
    "workRoleParamId"?: number;
    "workRoleOverride"?: string;
    "workTypeFlag"?: boolean;

    /**
     * Parameter unique identifier for the Custom Report's Work Type parameter
     */
    "workTypeParamId"?: number;
    "workTypeOverride"?: string;
    "invoiceFlag"?: boolean;

    /**
     * Parameter unique identifier for the Custom Report's Invoice Type parameter
     */
    "invoiceParamId"?: number;
    "invoiceOverride"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace CustomReport {

export type ModuleEnum = 'Companies' | 'Finance' | 'Marketing' | 'Procurement' | 'Project' | 'Sales' | 'ServiceDesk' | 'TimeExpense';
}
export interface CustomReportParameter {
    "id"?: number;

    /**
     * Either a caption name or parameter name is required
     */
    "name"?: string;

    /**
     * Either a caption name or parameter name is required
     */
    "captionName"?: string;
    "customReport"?: CustomReportReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface CustomReportReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface DeliveryMethod {
    "id"?: number;
    "name": string;
    "defaultFlag"?: boolean;
    "emailFlag"?: boolean;
    "integrationEmailFlag"?: boolean;
    "integrationPrintFlag"?: boolean;
    "integrationActiveFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Department {
    "id"?: number;
    "identifier": string;
    "name": string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface DepartmentLocation {
    "id"?: number;
    "location": SystemLocationReference;
    "department": SystemDepartmentReference;
    "departmentManager"?: MemberReference;
    "dispatch"?: MemberReference;
    "serviceManager"?: MemberReference;
    "dutyManager"?: MemberReference;
    "ldapConfig"?: LdapConfigurationReference;
    "addAllLocations"?: boolean;
    "removeAllLocations"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface DepartmentMananager {
    "count"?: number;
    "reAssignToMember"?: MemberReference;
}

export interface DispatchMember {
    "count"?: number;
    "reAssignToMember"?: MemberReference;
}

export interface DocumentInfo {
    "id"?: number;
    "title"?: string;
    "fileName"?: string;
    "serverFileName"?: string;
    "owner"?: string;
    "linkFlag"?: boolean;
    "imageFlag"?: boolean;
    "publicFlag"?: boolean;
    "htmlTemplateFlag"?: boolean;
    "readOnlyFlag"?: boolean;
    "size"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface DocumentReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface DocumentSetup {
    "id"?: number;
    "uploadAsLinkFlag"?: boolean;
    "isPublicFlag"?: boolean;
    "docPath"?: string;
    "templatePath"?: string;
    "templateOutputPath"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface DutyManager {
    "count"?: number;
    "reAssignToMember"?: MemberReference;
}

export interface EmailConnector {
    "id"?: number;
    "imapSetup": ImapSetupReference;
    "serviceBoard": BoardReference;
    "defaultCompany": CompanyReference;
    "defaultMember": MemberReference;
    "location"?: SystemLocationReference;
    "department"?: SystemDepartmentReference;
    "emailNotifyFrom"?: string;
    "bccEmailTo"?: string;
    "emailErrorsTo": string;
    "setEmailToDefaultContactFlag"?: boolean;
    "noResponseFlag"?: boolean;
    "neverRespondFlag"?: boolean;
    "discardDuplicatesFlag"?: boolean;
    "postRepliesToTicketFlag"?: boolean;
    "createContactFlag"?: boolean;
    "responseEmailForNew"?: string;
    "responseEmailForExisting"?: string;
    "sourceOverride"?: ServiceSourceReference;
    "priorityOverride"?: PriorityReference;
    "typeOverride"?: ServiceTypeReference;
    "subTypeOverride"?: ServiceSubTypeReference;
    "itemOverride"?: ServiceItemReference;
    "statusOverride"?: ServiceStatusReference;
    "addCcFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface EmailConnectorParsingRule {
    "id"?: number;
    "parsingStyle"?: EmailConnectorParsingStyleReference;
    "priority": number;
    "parsingVariable": EmailConnectorParsingVariableReference;
    "searchTerm": string;
    "servicePriority"?: PriorityReference;
    "serviceStatus"?: ServiceStatusReference;
    "serviceType"?: ServiceTypeReference;
    "serviceSubType"?: ServiceSubTypeReference;
    "serviceItem"?: ServiceItemReference;
    "serviceBoard"?: BoardReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface EmailConnectorParsingStyle {
    "id"?: number;
    "parsingType": EmailConnectorParsingTypeReference;
    "parseRule": string;
    "priority": number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface EmailConnectorParsingStyleReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface EmailConnectorParsingTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface EmailConnectorParsingVariableReference {
    "id"?: number;
    "name"?: string;
    "identifier"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface EmailConnectorReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface EmailOpened {
    "id"?: number;
    "campaignId"?: number;
    "contactId": number;
    "dateOpened"?: Date;
}

export interface EmailTemplateReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface EmailToken {
    "id"?: number;
    "token"?: string;
    "description"?: string;
    "addressFlag"?: boolean;
    "agreementFlag"?: boolean;
    "companyFlag"?: boolean;
    "configFlag"?: boolean;
    "contactFlag"?: boolean;
    "invoiceFlag"?: boolean;
    "purchaseOrderFlag"?: boolean;
    "purchaseOrderStatusFlag"?: boolean;
    "rmaFlag"?: boolean;
    "salesFlag"?: boolean;
    "serviceFlag"?: boolean;
    "tracksFlag"?: boolean;
    "workflowFlag"?: boolean;
}

export interface EndpointRequest {
    "id"?: string;
    "contentType"?: string;
    "method"?: string;
    "relativeUrl"?: string;
    "body"?: string;
}

export interface EndpointResponse {
    "id"?: string;
    "code"?: number;
    "message"?: string;
    "sort"?: number;
}

/**
 * Based on CompanyEntityType Report
 */
export interface EntityTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Error {
    "code"?: string;
    "message"?: string;
    "errors"?: Array<ValidationError>;
}

export interface ExpenseEntry {
    "id"?: number;

    /**
     * Company or chargeToType is required
     */
    "company"?: CompanyReference;
    "chargeToId"?: number;

    /**
     * Company or chargeToType is required
     */
    "chargeToType"?: ExpenseEntry.ChargeToTypeEnum;
    "type": ExpenseTypeReference;
    "member"?: MemberReference;
    "paymentMethod"?: PaymentMethodReference;
    "classification"?: ClassificationReference;
    "amount": number;
    "billableOption": ExpenseEntry.BillableOptionEnum;
    "date": Date;
    "locationId"?: number;
    "businessUnitId"?: number;
    "notes"?: string;
    "agreement"?: AgreementReference;
    "invoiceAmount"?: number;
    "mobileGuid"?: Guid;
    "taxes"?: Array<ExpenseTax>;
    "invoice"?: InvoiceReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace ExpenseEntry {

export type ChargeToTypeEnum = 'ServiceTicket' | 'ProjectTicket' | 'ChargeCode' | 'Activity';

export type BillableOptionEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';
}
export interface ExpenseReport {
    "id"?: number;
    "member"?: MemberReference;
    "year"?: number;
    "period"?: number;
    "dateStart"?: Date;
    "dateEnd"?: Date;
    "status"?: ExpenseReport.StatusEnum;
    "total"?: number;
    "dueDate"?: Date;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace ExpenseReport {

export type StatusEnum = 'Open' | 'Rejected' | 'PendingApproval' | 'ErrorsCorrected' | 'PendingProjectApproval' | 'ApprovedByTierOne' | 'RejectBySecondTier' | 'ApprovedByTierTwo' | 'ReadyToBill' | 'Billed' | 'WrittenOff' | 'BilledAgreement';
}
export interface ExpenseTax {
    "id"?: number;
    "amount"?: number;
    "type"?: ExpenseTaxTypeReference;
}

export interface ExpenseTaxTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ExpenseType {
    "id"?: number;
    "name": string;
    "amountCaption": string;
    "reimbursementRate"?: number;
    "billExpenses": ExpenseType.BillExpensesEnum;
    "invoiceMarkupOption": ExpenseType.InvoiceMarkupOptionEnum;
    "invoiceMarkupAmount"?: number;
    "advancedAmountFlag"?: boolean;
    "mileageFlag"?: boolean;
    "quantityFlag"?: boolean;
    "inactiveFlag"?: boolean;
    "maxAmount"?: number;
    "externalIntegrationXRef"?: ExternalExpenseTypeIntegrationReference;
    "integrationXRef"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace ExpenseType {

export type BillExpensesEnum = 'Billable' | 'DoNotBill' | 'NoCharge';

export type InvoiceMarkupOptionEnum = 'Percent' | 'Amount' | 'Mile';
}
export interface ExpenseTypeExemption {
    "id"?: number;
    "expenseType": ExpenseTypeReference;

    /**
     * At least one level flag is required -- levelOneFlag, levelTwoFlag, levelThreeFlag, levelFourFlag, and/or levelFiveFlag
     */
    "levelOneFlag"?: boolean;

    /**
     * At least one level flag is required -- levelOneFlag, levelTwoFlag, levelThreeFlag, levelFourFlag, and/or levelFiveFlag
     */
    "levelTwoFlag"?: boolean;

    /**
     * At least one level flag is required -- levelOneFlag, levelTwoFlag, levelThreeFlag, levelFourFlag, and/or levelFiveFlag
     */
    "levelThreeFlag"?: boolean;

    /**
     * At least one level flag is required -- levelOneFlag, levelTwoFlag, levelThreeFlag, levelFourFlag, and/or levelFiveFlag
     */
    "levelFourFlag"?: boolean;

    /**
     * At least one level flag is required -- levelOneFlag, levelTwoFlag, levelThreeFlag, levelFourFlag, and/or levelFiveFlag
     */
    "levelFiveFlag"?: boolean;
    "taxCode"?: TaxCodeReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ExpenseTypeExternalIntegrationReference {
    "id"?: number;
    "identifier"?: string;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ExpenseTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ExportAccountingBatchRequest {
    "batchIdentifier": string;
    "glInterfaceIdentifier"?: string;
    "thruDate"?: Date;
    "locationId"?: number;
    "summarizeInvoices"?: ExportAccountingBatchRequest.SummarizeInvoicesEnum;

    /**
     * Batch export must include invoices, expenses, or products (procurement)
     */
    "exportInvoicesFlag"?: boolean;
    "includedInvoiceIds"?: Array<number>;
    "excludedInvoiceIds"?: Array<number>;

    /**
     * Batch export must include invoices, expenses, or products (procurement)
     */
    "exportExpensesFlag"?: boolean;
    "includedExpenseIds"?: Array<number>;
    "excludedExpenseIds"?: Array<number>;

    /**
     * Batch export must include invoices, expenses, or products (procurement)
     */
    "exportProductsFlag"?: boolean;
    "includedProductIds"?: Array<string>;
    "excludedProductIds"?: Array<string>;
}

export namespace ExportAccountingBatchRequest {

export type SummarizeInvoicesEnum = 'Default' | 'Condensed' | 'Detailed';
}
export interface ExternalExpenseTypeIntegrationReference {
    "id"?: number;
    "identifier"?: string;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ExternalIntegrationStatusReference {
    "id"?: number;
    "identifier"?: string;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ExternalWorkTypeIntegrationReference {
    "id"?: number;
    "identifier"?: string;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface FilterValues {
    "conditions"?: string;
    "orderBy"?: string;
    "childconditions"?: string;
    "customfieldconditions"?: string;
}

export interface Forecast {
    "id"?: number;
    "name"?: string;
    "revenue"?: number;
    "cost"?: number;
    "type": Forecast.TypeEnum;
    "status"?: OpportunityStatusReference;
    "includedFlag"?: boolean;
    "recurring"?: ProductRecurring;
    "percent"?: number;
    "margin"?: number;
    "opportunityId"?: number;
    "quoteNumber"?: string;
    "quoteName"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace Forecast {

export type TypeEnum = 'Product' | 'Service' | 'Agreement' | 'Other1' | 'Other2';
}
export interface FormSubmitted {
    "id"?: number;
    "campaignId"?: number;
    "contactId": number;
    "dateSubmitted"?: Date;
    "url": string;
    "queryString"?: string;
    "pageType"?: string;
    "pageSubType"?: string;
    "topic"?: string;
    "version"?: string;
    "status"?: string;
}

export interface GLExport {

    /**
     * Mapped to GlPreferences Class
     */
    "exportSettings"?: GLExportSettings;
    "vendors"?: Array<GLExportVendor>;
    "customers"?: Array<GLExportCustomer>;
    "transactions"?: Array<GLExportTransaction>;
    "expenses"?: Array<GLExportExpense>;
    "expenseBills"?: Array<GLExportExpenseBill>;
    "purchaseTransactions"?: Array<GLExportPurchaseTransaction>;
    "adjustmentTransactions"?: Array<GLExportAdjustmentTransaction>;
    "inventoryTransfers"?: Array<GLExportInventoryTransfer>;
}

export interface GLExportAdjustmentTransaction {
    "id"?: string;
    "documentType"?: string;
    "documentDate"?: Date;
    "glTypeID"?: string;
    "accountNumber"?: string;
    "memo"?: string;
    "glClass"?: string;
    "adjustmentDescription"?: string;
    "adjustmentDetail"?: Array<GLExportAdjustmentTransactionDetail>;
}

export interface GLExportAdjustmentTransactionDetail {
    "glClass"?: string;
    "description"?: string;
    "memo"?: string;
    "item"?: IvItemReference;
    "quantity"?: number;
    "total"?: number;
    "cost"?: number;
    "costAccountNumber"?: string;
    "inventoryAccountNumber"?: string;
    "accountNumber"?: string;
    "productAccountNumber"?: string;
}

export interface GLExportCustomer {
    "company"?: CompanyReference;
    "companyType"?: CompanyTypeReference;
    "contact"?: ContactReference;
    "site"?: SiteReference;
    "accountNumber"?: string;
    "billingTerms"?: BillingTermsReference;
    "billingTermsXref"?: string;
    "dueDays"?: number;
    "taxable"?: boolean;
    "taxCode"?: TaxCodeReference;
    "currency"?: CurrencyReference;
    "stateTaxXref"?: string;
    "countyTaxXref"?: string;
    "cityTaxXref"?: string;
    "countryTaxXref"?: string;
    "compositeTaxXref"?: string;
    "stateTaxRate"?: number;
    "countyTaxRate"?: number;
    "cityTaxRate"?: number;
    "countryTaxRate"?: number;
    "compositeTaxRate"?: number;
    "taxGroupRate"?: number;
    "taxAgencyXref"?: string;
    "stateTaxAgencyXref"?: string;
    "countyTaxAgencyXref"?: string;
    "cityTaxAgencyXref"?: string;
    "countryTaxAgencyXref"?: string;
    "compositeTaxAgencyXref"?: string;
}

export interface GLExportExpense {
    "id"?: number;
    "documentDate"?: Date;
    "documentType"?: string;
    "apAccountNumber"?: string;
    "apClass"?: string;
    "accountNumber"?: string;
    "glClass"?: string;
    "glTypeId"?: string;
    "memo"?: string;
    "description"?: string;
    "periodStartDate"?: Date;
    "periodEndDate"?: Date;
    "member"?: MemberReference;
    "vendorNumber"?: string;
    "company"?: CompanyReference;
    "companyAccountNumber"?: string;
    "project"?: ProjectReference;
    "currency"?: CurrencyReference;
    "total"?: number;
    "offset"?: GLExportExpenseOffset;
}

export interface GLExportExpenseBill {
    "id"?: number;
    "documentDate"?: string;
    "documentType"?: string;
    "documentNumber"?: string;
    "memo"?: string;
    "glClass"?: string;
    "apAccountNumber"?: string;
    "member"?: MemberReference;
    "vendorNumber"?: string;
    "currency"?: CurrencyReference;
    "total"?: number;
    "detail"?: Array<GLExportExpenseBillDetail>;
}

export interface GLExportExpenseBillDetail {
    "id"?: number;
    "documentDate"?: string;
    "glTypeId"?: string;
    "memo"?: string;
    "company"?: CompanyReference;
    "accountNumber"?: string;
    "expenseClass"?: ClassificationReference;
    "currency"?: CurrencyReference;
    "total"?: number;
    "billable"?: boolean;
    "reimbursable"?: boolean;
    "companyAdvance"?: boolean;
}

export interface GLExportExpenseOffset {
    "id"?: number;
    "documentDate"?: Date;
    "documentType"?: string;
    "accountNumber"?: string;
    "glTypeId"?: string;
    "glClass"?: string;
    "member"?: MemberReference;
    "memo"?: string;
    "description"?: string;
    "total"?: number;
}

export interface GLExportInventoryTransfer {
    "id"?: string;
    "documentType"?: string;
    "documentDate"?: Date;
    "accountNumber"?: string;
    "glClass"?: string;
    "glTypeId"?: string;
    "description"?: string;
    "salesCode"?: string;
    "memo"?: string;
    "costAcccountNumber"?: string;
    "inventoryAccountNumber"?: string;
    "transferId"?: number;
    "item"?: IvItemReference;
    "glItemId"?: string;
    "salesDescription"?: string;
    "itemDescription"?: string;
    "currency"?: CurrencyReference;
    "itemPrice"?: number;
    "taxable"?: boolean;
    "unitOfMeasure"?: UnitOfMeasureReference;
    "quantity"?: number;
    "cost"?: number;
    "total"?: number;
    "subCategory"?: ProductSubCategoryReference;
    "serializedFlag"?: boolean;
    "serialNumbers"?: string;
    "shipmentMethod"?: ShipmentMethodReference;
    "bin"?: WarehouseBinReference;
    "warehouse"?: WarehouseReference;
    "transferFromBin"?: WarehouseBinReference;
    "transferFromLocationXref"?: string;
    "transferToBin"?: WarehouseBinReference;
    "transferToLocationXref"?: string;
    "locationXref"?: string;
    "priceLevelXref"?: string;
    "uomScheduleXref"?: string;
    "itemTypeXref"?: string;
    "inventoryXref"?: string;
    "cogsXref"?: string;
    "taxNote"?: string;
    "taxCode"?: TaxCodeReference;
    "offset"?: GLExportInventoryTransferOffset;
}

export interface GLExportInventoryTransferOffset {
    "id"?: number;
    "documentType"?: string;
    "documentDate"?: Date;
    "accountNumber"?: string;
    "glClass"?: string;
    "total"?: number;
    "memo"?: string;
    "description"?: string;
    "glTypeId"?: string;
}

export interface GLExportPurchaseTransaction {
    "id"?: string;
    "documentDate"?: Date;
    "documentNumber"?: string;
    "description"?: string;
    "memo"?: string;
    "apAccountNumber"?: string;
    "purchaseDate"?: Date;
    "company"?: CompanyReference;
    "companyType"?: CompanyTypeReference;
    "contact"?: ContactReference;
    "site"?: SiteReference;
    "purchaseClass"?: string;
    "freightAmount"?: number;
    "freightPackingSlip"?: string;
    "packingSlip"?: string;
    "dropshipFlag"?: boolean;
    "currency"?: CurrencyReference;
    "total"?: number;
    "billingTerms"?: BillingTermsReference;
    "billingTermsXref"?: string;
    "dueDays"?: number;
    "vendorNumber"?: string;
    "vendorAccountNumber"?: string;
    "vendorInvoiceDate"?: Date;
    "vendorInvoiceNumber"?: string;
    "taxAgencyXref"?: string;
    "stateTaxXref"?: string;
    "countyTaxXref"?: string;
    "cityTaxXref"?: string;
    "shipToCompany"?: CompanyReference;
    "shipToCompanyAccountNumber"?: string;
    "shipToCompanyType"?: CompanyTypeReference;
    "shipToContact"?: ContactReference;
    "shipToSite"?: SiteReference;
    "shipToTaxGroup"?: string;
    "taxCode"?: TaxCodeReference;
    "taxGroupRate"?: number;
    "useAvalaraTaxFlag"?: boolean;
    "purchaseHeaderTaxGroup"?: string;
    "purchaseHeaderTaxableFlag"?: boolean;
    "purchaseHeaderFreightTaxableFlag"?: boolean;
    "purchaseDetail"?: Array<GLExportPurchaseTransactionDetail>;
    "purchaseDetailTax"?: Array<GLExportPurchaseTransactionDetailTax>;
}

export interface GLExportPurchaseTransactionDetail {
    "id"?: number;
    "documentDate"?: Date;
    "glClass"?: string;
    "glTypeId"?: string;
    "glItemId"?: string;
    "salesCode"?: string;
    "description"?: string;
    "cost"?: number;
    "memo"?: string;
    "taxNote"?: string;
    "vendorNumber"?: string;
    "accountNumber"?: string;
    "costAccountNumber"?: string;
    "inventoryAccountNumber"?: string;
    "vendorAccountNumber"?: string;
    "item"?: IvItemReference;
    "itemDescription"?: string;
    "salesDescription"?: string;
    "taxable"?: boolean;
    "itemPrice"?: number;
    "itemCost"?: number;
    "unitOfMeasure"?: UnitOfMeasureReference;
    "quantity"?: number;
    "total"?: number;
    "currency"?: CurrencyReference;
    "serializedFlag"?: boolean;
    "serialNumbers"?: string;
    "dropShippedFlag"?: boolean;
    "lineNumber"?: number;
    "warehouseBin"?: WarehouseBinReference;
    "warehouseSite"?: SiteReference;
    "subCategory"?: ProductSubCategoryReference;
    "shipmentMethod"?: ShipmentMethodReference;
    "itemTypeXref"?: string;
    "inventoryXref"?: string;
    "cogsXref"?: string;
    "uomScheduleXref"?: string;
    "priceLevelXref"?: string;
    "locationXref"?: string;
    "taxCode"?: TaxCodeReference;
    "purchaseHeaderTaxGroup"?: string;
    "taxCodeXref"?: string;
    "taxRate"?: number;
    "taxAgencyXref"?: string;
}

export interface GLExportPurchaseTransactionDetailTax {
    "id"?: number;
    "documentDate"?: Date;
    "accountNumber"?: string;
    "glClass"?: string;
    "cost"?: number;
    "salesCode"?: string;
    "glTypeId"?: string;
    "glItemId"?: string;
    "memo"?: string;
    "vendorNumber"?: string;
    "vendorAccountNumber"?: string;
    "costAccountNumber"?: string;
    "inventoryAccountNumber"?: string;
    "itemTypeXref"?: string;
    "inventoryXref"?: string;
    "cogsXref"?: string;
    "uomScheduleXref"?: string;
    "priceLevelXref"?: string;
    "locationXref"?: string;
    "item"?: IvItemReference;
    "taxableFlag"?: boolean;
    "salesDescription"?: string;
    "itemDescription"?: string;
    "itemPrice"?: number;
    "itemCost"?: number;
    "unitOfMeasure"?: UnitOfMeasureReference;
    "quantity"?: number;
    "total"?: number;
    "currency"?: CurrencyReference;
    "serializedFlag"?: boolean;
    "serialNumbers"?: string;
    "dropShippedFlag"?: boolean;
    "lineNumber"?: number;
    "warehouseSite"?: SiteReference;
    "warehouseBin"?: WarehouseBinReference;
    "shipmentMethod"?: ShipmentMethodReference;
    "subCategory"?: ProductSubCategoryReference;
    "taxCode"?: TaxCodeReference;
    "taxRate"?: number;
    "taxRatePercent"?: number;
    "taxAgencyXref"?: string;
    "taxNote"?: string;
    "purchaseHeaderTaxGroup"?: string;
}

/**
 * Mapped to GlPreferences Class
 */
export interface GLExportSettings {
}

export interface GLExportTransaction {
    "id"?: number;
    "glClass"?: string;
    "glTypeId"?: string;
    "documentDate"?: Date;
    "documentNumber"?: string;
    "documentType"?: string;
    "memo"?: string;
    "description"?: string;
    "attention"?: string;
    "salesTerritory"?: string;
    "company"?: CompanyReference;
    "companyType"?: CompanyTypeReference;
    "companyAccountNumber"?: string;
    "site"?: SiteReference;
    "billingTerms"?: BillingTermsReference;
    "billingTermsXref"?: string;
    "dueDays"?: number;
    "dueDate"?: Date;
    "emailDeliveryFlag"?: boolean;
    "printDeliveryFlag"?: boolean;
    "agreementPrePaymentFlag"?: boolean;
    "accountNumber"?: string;
    "billingType"?: string;
    "glEntryIds"?: string;
    "purchaseOrder"?: PurchaseOrderReference;
    "project"?: ProjectReference;
    "currency"?: CurrencyReference;
    "total"?: number;
    "salesRepId"?: string;
    "salesRepName"?: string;
    "taxable"?: boolean;
    "taxableTotal"?: number;
    "taxCode"?: TaxCodeReference;
    "taxGroupRate"?: number;
    "piggyBackFlag"?: boolean;
    "taxAccountNumber"?: string;
    "salesTax"?: number;
    "stateTax"?: number;
    "countyTax"?: number;
    "cityTax"?: number;
    "taxableAmount1"?: number;
    "taxableAmount2"?: number;
    "taxableAmount3"?: number;
    "taxableAmount4"?: number;
    "taxableAmount5"?: number;
    "taxAgencyXref"?: string;
    "stateTaxXref"?: string;
    "countyTaxXref"?: string;
    "taxId"?: string;
    "taxDpAppliedFlag"?: boolean;
    "useAvalaraFlag"?: boolean;
    "sendAvalaraTaxFlag"?: boolean;
    "shipToCompany"?: CompanyReference;
    "shipCompanyAccountNumber"?: string;
    "shipCompanyType"?: CompanyTypeReference;
    "shipTaxId"?: string;
    "shipSite"?: SiteReference;
    "shipContact"?: ContactReference;
    "detail"?: Array<GLExportTransactionDetail>;
}

export interface GLExportTransactionDetail {
    "id"?: number;
    "documentDate"?: Date;
    "documentType"?: string;
    "accountNumber"?: string;
    "glClass"?: string;
    "glTypeId"?: string;
    "glItemId"?: string;
    "invoiceSummaryOption"?: number;
    "cost"?: number;
    "salesCode"?: string;
    "memo"?: string;
    "description"?: string;
    "quantity"?: number;
    "total"?: number;
    "currency"?: CurrencyReference;
    "timeEntry"?: TimeEntryReference;
    "costAccountNumber"?: string;
    "inventoryAccountNumber"?: string;
    "productAccountNumber"?: string;
    "taxCode"?: TaxCodeReference;
    "taxCodeXref"?: string;
    "taxAgencyXref"?: string;
    "taxNote"?: string;
    "taxRate"?: number;
    "taxRatePercent"?: number;
    "taxableFlag"?: boolean;
    "taxable2Flag"?: boolean;
    "taxable3Flag"?: boolean;
    "taxable4Flag"?: boolean;
    "taxable5Flag"?: boolean;
    "item"?: IvItemReference;
    "itemTaxableFlag"?: boolean;
    "itemPrice"?: number;
    "itemCost"?: number;
    "itemDescription"?: string;
    "salesDescription"?: string;
    "unitOfMeasure"?: UnitOfMeasureReference;
    "subCategory"?: ProductSubCategoryReference;
    "serializedFlag"?: boolean;
    "serialNumbers"?: string;
    "warehouseSite"?: SiteReference;
    "warehouseBin"?: WarehouseBinReference;
    "shipmentMethod"?: ShipmentMethodReference;
    "dropShippedFlag"?: boolean;
    "itemTypeXref"?: string;
    "inventoryXref"?: string;
    "cogsXref"?: string;
    "uomScheduleXref"?: string;
    "priceLevelXref"?: string;
    "locationXref"?: string;
}

export interface GLExportVendor {

    /**
     * Vendor Can be either Member or Company Reference
     */
    "member"?: MemberReference;

    /**
     * Vendor Can be either Member or Company Reference
     */
    "vendor"?: CompanyReference;
    "vendorNumber"?: string;
    "company"?: CompanyReference;
    "contact"?: ContactReference;
    "accountNumber"?: string;
    "billingTerms"?: BillingTermsReference;
    "dueDays"?: number;
    "site"?: SiteReference;
    "taxCode"?: TaxCodeReference;
}

export interface GenericIdIdentifierReference {
    "id"?: number;
    "identifier"?: string;
    "name"?: string;
}

export interface Group {
    "id"?: number;
    "name": string;
    "publicDescription"?: string;
    "publicFlag"?: boolean;
    "inactiveFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

/**
 * Required when notifyType is set to: "Add to Group"
 */
export interface GroupReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Guid {
}

export interface Holiday {
    "id"?: number;
    "name": string;

    /**
     * Can be set to false to set a holiday for specific hours (Defaults to True)
     */
    "allDayFlag"?: boolean;

    /**
     * If this is not a full day holiday dateStart and dateEnd must be specified
     */
    "dateStart": Date;
    "dateEnd"?: Date;
    "holidayList"?: HolidayListReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface HolidayList {
    "id"?: number;
    "name": string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface HolidayListReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Imap {
    "id"?: number;
    "name"?: string;
    "imapName"?: string;
    "processedName"?: string;
    "server"?: string;
    "userName"?: string;
    "password"?: string;
    "port"?: number;
    "sslFlag"?: boolean;
    "emailConnector"?: EmailConnectorReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ImapSetupReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Impact {
    "id"?: number;
    "name"?: string;
    "description": string;
    "defaultFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ImportMassMaintenance {
    "deletedContactCount"?: number;
    "deletedCompanyCount"?: number;
    "message"?: string;
    "success"?: boolean;
}

export interface InOutBoard {
    "id"?: number;
    "member": MemberReference;
    "inOutType": InOutTypeReference;
    "additionalInfo"?: string;
    "dateBack": Date;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface InOutType {
    "id"?: number;
    "description": string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface InOutTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Info {
    "version"?: string;
    "isCloud"?: boolean;
    "serverTimeZone"?: string;
}

export interface IntegratorLogin {
    "id"?: number;
    "username": string;

    /**
     * The password will never be returned in response
     */
    "password": string;

    /**
     * This flag controls whether the integrator can access only the db records it created, or all system records
     */
    "canAccessAllRecordsFlag"?: boolean;
    "canAccessAllApisFlag"?: boolean;
    "inactiveFlag"?: boolean;
    "dateInactivated"?: Date;
    "inactivatedBy"?: MemberReference;
    "serviceTicketApiFlag"?: boolean;

    /**
     * If integrator has access to ServiceTicket API, a service board is required
     */
    "board"?: BoardReference;
    "serviceBoardCallbackUrl"?: string;
    "serviceBoardLegacyCallbackFlag"?: boolean;
    "timeEntryApiFlag"?: boolean;

    /**
     * If integrator has access to TimeEntry API, a member is required
     */
    "member"?: MemberReference;
    "timeEntryCallbackUrl"?: string;
    "timeEntryLegacyCallbackFlag"?: boolean;
    "managedServicesApiFlag"?: boolean;
    "managedServicesAutoChildFlag"?: boolean;

    /**
     * True if integrator is allowed to child configurations
     */
    "managedServicesChildingFlag"?: boolean;
    "contactApiFlag"?: boolean;
    "contactCallbackUrl"?: string;
    "contactLegacyCallbackFlag"?: boolean;
    "companyApiFlag"?: boolean;
    "companyCallbackUrl"?: string;
    "companyLegacyCallbackFlag"?: boolean;
    "activityApiFlag"?: boolean;
    "activityCallbackUrl"?: string;
    "activityLegacyCallbackFlag"?: boolean;
    "ntrSupportApiFlag"?: boolean;
    "logMeInSupportApiFlag"?: boolean;
    "invoiceApiFlag"?: boolean;
    "productApiFlag"?: boolean;
    "productCallbackUrl"?: string;
    "productLegacyCallbackFlag"?: boolean;
    "opportunityApiFlag"?: boolean;
    "opportunityCallbackUrl"?: string;
    "opportunityLegacyCallbackFlag"?: boolean;

    /**
     * True if the member has access to the Opportunity Conversion Api
     */
    "opportunityConversionApiFlag"?: boolean;
    "memberApiFlag"?: boolean;
    "marketingApiFlag"?: boolean;
    "purchasingApiFlag"?: boolean;
    "purchasingCallbackUrl"?: string;
    "purchasingLegacyCallbackFlag"?: boolean;
    "reportingApiFlag"?: boolean;
    "systemApiFlag"?: boolean;
    "projectApiFlag"?: boolean;
    "projectCallbackUrl"?: string;
    "projectLegacyCallbackFlag"?: boolean;
    "configurationApiFlag"?: boolean;
    "configurationAutoChildFlag"?: boolean;

    /**
     * True if integrator is allowed to child configurations
     */
    "configurationChildlingFlag"?: boolean;
    "configurationCallbackUrl"?: string;
    "configurationLegacyCallbackFlag"?: boolean;
    "scheduleApiFlag"?: boolean;
    "scheduleCallbackUrl"?: string;
    "scheduleLegacyCallbackFlag"?: boolean;
    "agreementApiFlag"?: boolean;
    "agreementCallbackUrl"?: string;
    "agreementCallbackLegacyFlag"?: boolean;
    "documentApiFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface IntegratorLoginReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Invoice {
    "id"?: number;
    "invoiceNumber"?: string;
    "type": Invoice.TypeEnum;
    "status"?: BillingStatusReference;
    "company": CompanyReference;
    "billToCompany"?: CompanyReference;
    "shipToCompany"?: CompanyReference;
    "applyToType"?: Invoice.ApplyToTypeEnum;
    "applyToId"?: number;
    "attention"?: string;
    "billingSite"?: SiteReference;
    "shippingSite"?: SiteReference;
    "billingTerms"?: BillingTermsReference;
    "reference"?: string;
    "customerPO"?: string;

    /**
     * Can be obtained via InvoiceTemplate report
     */
    "templateSetupId"?: number;

    /**
     * Can be obtained via InvoiceEmailTemplate report
     */
    "emailTemplateId"?: number;
    "addToBatchEmailList"?: boolean;
    "date"?: Date;
    "restrictDownpaymentFlag"?: boolean;
    "locationId"?: number;

    /**
     * departmentId is only required for special invoices
     */
    "departmentId"?: number;
    "territoryId"?: number;
    "topComment"?: string;
    "bottomComment"?: string;
    "taxableFlag"?: boolean;
    "taxCode"?: TaxCodeReference;
    "internalNotes"?: string;
    "downpaymentPreviouslyTaxedFlag"?: boolean;
    "serviceTotal"?: number;
    "currency"?: CurrencyReference;
    "dueDate"?: Date;
    "expenseTotal"?: number;
    "productTotal"?: number;
    "previousProgressApplied"?: number;
    "serviceAdjustmentAmount"?: number;
    "agreementAmount"?: number;
    "downpaymentApplied"?: number;
    "subtotal"?: number;
    "total"?: number;
    "remainingDownpayment"?: number;
    "salesTax"?: number;
    "adjustmentReason"?: string;
    "adjustedBy"?: string;
    "payments"?: number;
    "credits"?: number;
    "balance"?: number;
    "specialInvoiceFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace Invoice {

export type TypeEnum = 'Agreement' | 'CreditMemo' | 'DownPayment' | 'Miscellaneous' | 'Progress' | 'Standard';

export type ApplyToTypeEnum = 'All' | 'Agreement' | 'Project' | 'ProjectPhase' | 'SalesOrder' | 'Ticket';
}
export interface InvoiceEmailTemplate {
    "id"?: number;
    "name": string;
    "serviceSurvey"?: ServiceSurveyReference;
    "useSenderFlag"?: boolean;

    /**
     * From fields (first name, last name, email address) are required if useSenderFlag is false
     */
    "firstName"?: string;

    /**
     * From fields (first name, last name, email address) are required if useSenderFlag is false
     */
    "lastName"?: string;

    /**
     * From fields (first name, last name, email address) are required if useSenderFlag is false
     */
    "emailAddress"?: string;
    "subject": string;
    "body"?: string;
    "copySenderFlag"?: boolean;
    "invoiceStatus"?: BillingStatusReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface InvoiceReference {
    "id"?: number;
    "identifier"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface InvoiceTemplate {
    "id"?: number;
    "name": string;
    "marginLeft"?: number;
    "marginRight"?: number;
    "marginTop"?: number;
    "marginBottom"?: number;
    "logoVisibleFlag"?: boolean;
    "headerLogoPosition"?: InvoiceTemplate.HeaderLogoPositionEnum;
    "remitToVisibileFlag"?: boolean;
    "headerAddressPosition"?: InvoiceTemplate.HeaderAddressPositionEnum;
    "headerTitleVisibileFlag"?: boolean;
    "headerTitleCaption"?: string;
    "headerTitlePosition"?: InvoiceTemplate.HeaderTitlePositionEnum;
    "headerTitleFont"?: InvoiceTemplate.HeaderTitleFontEnum;
    "headerTermsVisibleFlag"?: boolean;
    "headerTermsCaption"?: string;
    "headerDueDateVisibleFlag"?: boolean;
    "headerDueDateCaption"?: string;
    "headerPoNumberVisibleFlag"?: boolean;
    "headerPoNumberCaption"?: string;
    "headerReferenceVisibleFlag"?: boolean;
    "headerReferenceCaption"?: string;
    "headerAccountVisibleFlag"?: boolean;
    "headerAccountCaption"?: string;
    "headerTaxIdVisibleFlag"?: boolean;
    "headerTaxIdCaption"?: string;
    "headerShipToVisibleFlag"?: boolean;
    "headerShipToCaption"?: string;
    "serviceHeaderTicketNumberVisibleFlag"?: boolean;
    "serivceHeaderTicketNumberCaption"?: string;
    "serviceHeaderCompanyNameVisibleFlag"?: boolean;
    "serviceHeaderCompanyNameCaption"?: string;
    "serviceHeaderSummaryVisibleFlag"?: boolean;
    "serviceHeaderSummaryCaption"?: string;
    "serviceHeaderContactNameVisibleFlag"?: boolean;
    "serviceHeaderContactNameCaption"?: string;
    "serviceHeaderDetailDescriptionVisibleFlag"?: boolean;
    "serviceHeaderDetailDescriptionCaption"?: string;
    "serviceHeaderResolutionVisibleFlag"?: boolean;
    "serviceHeaderResolutionCaption"?: string;
    "serviceHeaderAmountVisibleFlag"?: boolean;
    "serviceHeaderAmountCaption"?: string;
    "serviceHeaderBillingMethodVisibleFlag"?: boolean;
    "serviceHeaderBillingMethodCaption"?: string;
    "serviceHeaderClosedTasksVisibleFlag"?: boolean;
    "serviceHeaderOpenTasksVisibleFlag"?: boolean;
    "serviceHeaderBundledTicketsVisibleFlag"?: boolean;
    "projectHeaderProjectNameVisibleFlag"?: boolean;
    "projectHeaderProjectNameCaption"?: string;
    "projectHeaderCompanyNameVisibleFlag"?: boolean;
    "projectHeaderCompanyNameCaption"?: string;
    "projectHeaderOriginalDownpaymentVisibleFlag"?: boolean;
    "projectHeaderOriginalDownpaymentCaption"?: string;
    "projectHeaderContactNameVisibleFlag"?: boolean;
    "projectHeaderContactNameCaption"?: string;
    "projectHeaderAmountVisibleFlag"?: boolean;
    "projectHeaderAmountCaption"?: string;
    "projectHeaderBillingMethodVisibleFlag"?: boolean;
    "projectHeaderBillingMethodCaption"?: string;
    "projectHeaderBillingTypeVisibleFlag"?: boolean;
    "projectHeaderBillingTypeCaption"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace InvoiceTemplate {

export type HeaderLogoPositionEnum = 'LeftSide' | 'RightSide' | 'Center';

export type HeaderAddressPositionEnum = 'LeftSide' | 'RightSide' | 'Center';

export type HeaderTitlePositionEnum = 'LeftSide' | 'RightSide' | 'Center';

export type HeaderTitleFontEnum = 'Regular' | 'RegularBold' | 'Large' | 'LargeBold' | 'ExtraLarge' | 'ExtraLargeBold';
}
export interface InvoiceTemplateReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface InvoiceTemplateSetup {
    "id"?: number;
    "name"?: string;
    "customFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface IvItemReference {
    "id"?: number;
    "identifier"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface JArray {
}

export interface JObject {
}

export interface KPI {
    "id"?: number;
    "name"?: string;
    "category": KPICategoryReference;
    "dateFilter"?: string;
    "sortOrder"?: number;
    "inactiveFlag"?: boolean;
}

export interface KPICategory {
    "id"?: number;
    "name"?: string;
    "sortOrder"?: number;
}

export interface KPICategoryReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface KPIReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface KnowledgeBaseArticle {
    "id"?: number;
    "title": string;
    "issue": string;
    "resolution": string;
    "locationId"?: number;
    "businessUnitId"?: number;
    "board"?: BoardReference;
    "categoryId"?: number;
    "subCategoryId"?: number;
    "dateCreated"?: string;
    "createdBy"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

/**
 * A list of knowledge base articles that the member is the approver
 */
export interface KnowledgebaseArticle {
    "count"?: number;
    "reAssignToMember"?: MemberReference;
}

export interface LdapConfiguration {
    "id"?: number;
    "name": string;

    /**
     * FQDN of the Server.
     */
    "server": string;

    /**
     * Domain Name of the server.
     */
    "domain": string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface LdapConfigurationReference {
    "id"?: number;
    "name"?: string;
    "server"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface LegacySubCategory {
    "id"?: number;
    "name": string;
    "inactiveFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Link {
    "id"?: number;
    "name": string;
    "tableReferenceId"?: number;
    "url"?: string;
    "screenLink"?: Link.ScreenLinkEnum;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace Link {

export type ScreenLinkEnum = 'Company' | 'Contact' | 'Service' | 'Invoice' | 'PurchaseOrder' | 'SalesOrder';
}
export interface LinkClicked {
    "id"?: number;
    "campaignId"?: number;
    "contactId": number;
    "dateClicked"?: Date;
    "url": string;
    "queryString"?: string;
}

export interface Location {
    "id"?: number;
    "ownerLevelId"?: number;
    "structureLevel": CorporateStructureLevelReference;
    "name": string;
    "manager"?: MemberReference;
    "reportsTo"?: SystemLocationReference;
    "salesRep"?: string;
    "timeZoneSetup"?: TimeZoneSetupReference;
    "calendar"?: CalendarReference;
    "overrideAddressLine1"?: string;
    "overrideAddressLine2"?: string;
    "overrideCity"?: string;
    "overrideState"?: string;
    "overrideZip"?: string;
    "overrideCountry"?: CountryReference;
    "overridePhoneNumber"?: string;
    "overrideFaxNumber"?: string;
    "owaUrl"?: string;
    "payrollXref"?: string;
    "locationFlag"?: boolean;
    "clientFlag"?: boolean;
    "workRoleIds"?: Array<number>;
    "departmentIds"?: Array<number>;
    "topNavigationLogo"?: DocumentReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface LocationDepartment {
    "id"?: number;
    "location"?: SystemLocationReference;
    "department"?: SystemDepartmentReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface LocationWorkRole {
    "id"?: number;
    "location"?: SystemLocationReference;
    "workRole"?: WorkRoleReference;
    "workRoleInactiveFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ManagedDevicesIntegration {
    "id"?: number;
    "name": string;
    "solution": string;
    "portalUrl"?: string;
    "loginBy": ManagedDevicesIntegration.LoginByEnum;

    /**
     * This is only required when globalLoginFlag = true
     */
    "globalLoginUsername"?: string;

    /**
     * This is only required when globalLoginFlag = true
     */
    "globalLoginPassword"?: string;
    "defaultBillingLevel": ManagedDevicesIntegration.DefaultBillingLevelEnum;
    "managementItSetupType"?: string;
    "defaultLocation"?: SystemLocationReference;
    "defaultDepartment"?: SystemDepartmentReference;
    "integratorLogin"?: IntegratorLoginReference;
    "matchOnSerialNumberFlag"?: boolean;
    "disableNewCrossReferencesFlag"?: boolean;
    "configBillCustomerFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace ManagedDevicesIntegration {

export type LoginByEnum = 'Member' | 'Global';

export type DefaultBillingLevelEnum = 'Summary' | 'Detail';
}
export interface ManagedDevicesIntegrationCrossReference {
    "id"?: number;
    "managedDevicesIntegration"?: ManagedDevicesIntegrationReference;
    "vendorType"?: string;
    "vendorLevel"?: string;

    /**
     * agreementType or configurationType is required
     */
    "agreementType"?: AgreementTypeReference;
    "product"?: IvItemReference;

    /**
     * agreementType or configurationType is required
     */
    "configurationType"?: ConfigurationTypeReference;
    "inactiveFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ManagedDevicesIntegrationLogin {
    "id"?: number;
    "managedDevicesIntegration"?: ManagedDevicesIntegrationReference;
    "username": string;
    "password": string;
    "member": MemberReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ManagedDevicesIntegrationNotification {
    "id"?: number;
    "managedDevicesIntegration"?: ManagedDevicesIntegrationReference;
    "notifyWho": NotificationRecipientReference;

    /**
     * Required if notifyWho/identifier == 'M' (Specific Member)
     */
    "member"?: MemberReference;
    "logType": ManagedDevicesIntegrationNotification.LogTypeEnum;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace ManagedDevicesIntegrationNotification {

export type LogTypeEnum = 'All' | 'Error' | 'NewManagedSolution' | 'NewDeviceType' | 'NewConfiguration' | 'NewAddition' | 'Info';
}
export interface ManagedDevicesIntegrationReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Management {
    "id"?: number;
    "runTime"?: Date;
    "addedConfigurationStatus": ConfigurationStatusReference;
    "deletedConfigurationStatus": ConfigurationStatusReference;
    "integratorLogin": IntegratorLoginReference;
    "scheduleExecutiveSummaryReportFlag": boolean;

    /**
     * This is only required when scheduleExecutiveSummaryReportFlag = true
     */
    "executiveSummaryReportScheduleDay"?: number;

    /**
     * This is only required when scheduleExecutiveSummaryReportFlag = true. Input should be in 24 hour format, ie 2pm is 14
     */
    "executiveSummaryReportScheduleHour"?: number;

    /**
     * This is only required when scheduleExecutiveSummaryReportFlag = true
     */
    "executiveSummaryReportScheduleMinute"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ManagementBackup {
    "id"?: number;
    "type": AgreementTypeReference;
    "item": CatalogItemReference;
    "billingLevel": ManagementBackup.BillingLevelEnum;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace ManagementBackup {

export type BillingLevelEnum = 'Summary' | 'Detail';
}
export interface ManagementEmail {
    "id"?: number;
    "name": string;
    "managementSolution": ManagementEmail.ManagementSolutionEnum;
    "identifier": string;

    /**
     * emailUsername is required when managementSolution set to Postini.
     */
    "emailUsername"?: string;

    /**
     * emailPassword is required when managementSolution set to Postini. The password field can only be set on initial POST.
     */
    "emailPassword"?: string;

    /**
     * serverPrefix is required when managementSolution set to Postini.
     */
    "serverPrefix"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace ManagementEmail {

export type ManagementSolutionEnum = 'DoubleCheck' | 'Postini';
}
export interface ManagementItSolution {
    "id"?: number;
    "name": string;
    "managementItSolutionType": ManagementItSolution.ManagementItSolutionTypeEnum;

    /**
     * This is only required when managementItSolutionType is Custom
     */
    "managementSolutionName"?: string;

    /**
     * This is only required for Level Platforms and Kaseya
     */
    "managementServerUrl"?: string;

    /**
     * This is only required for Level Platforms and Kaseya when overrideWebServiceLocationFlag is true
     */
    "webserviceOverrideUrl"?: string;

    /**
     * This is only required for Level Platforms and Kaseya when overrideLoginLocationFlag is true
     */
    "portalOverrideLoginUrl"?: string;
    "globalLoginFlag"?: boolean;

    /**
     * This is only required when globalLoginFlag = true
     */
    "globalLoginUsername"?: string;

    /**
     * This is only required when globalLoginFlag = true
     */
    "globalLoginPassword"?: string;
    "usingSslFlag"?: boolean;

    /**
     * This is only required for N-Able solution
     */
    "nAbleUsername"?: string;

    /**
     * This is only required for N-Able solution
     */
    "nAblePassword"?: string;
    "overrideWebServiceLocationFlag"?: boolean;
    "overrideLoginLocationFlag"?: boolean;

    /**
     * This is only required for Continuum solution
     */
    "continuumApiUsername"?: string;

    /**
     * This is only required for Continuum solution
     */
    "continuumApiPassword"?: string;

    /**
     * This is only required for Level Platforms solution
     */
    "levelApiUsername"?: string;

    /**
     * This is only required for Level Platforms solution
     */
    "levelApiPassword"?: string;

    /**
     * This is only required for Level Platforms solution
     */
    "levelVarDomain"?: string;
    "noDisplayFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace ManagementItSolution {

export type ManagementItSolutionTypeEnum = 'LevelPlatforms' | 'Kaseya' | 'NAble' | 'Continuum' | 'Custom';
}
export interface ManagementItSolutionAgreementInterfaceParameter {
    "id"?: number;
    "managedDevicesIntegration"?: ManagedDevicesIntegrationReference;
    "agreementType": AgreementTypeReference;
    "serverProduct"?: IvItemReference;
    "workstationProduct"?: IvItemReference;
    "spamStatsProduct"?: IvItemReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ManagementLogDocumentInfo {
}

export interface ManagementNetworkSecurity {
    "id"?: number;
    "name": string;
    "username"?: string;
    "password"?: string;
    "site": string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ManagementReportNotification {
    "id"?: number;
    "notifyWho": NotificationRecipientReference;
    "member"?: MemberReference;
    "email"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ManagementSolutionReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Manufacturer {
    "id"?: number;
    "name": string;
    "inactiveFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ManufacturerReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface MarketDescription {
    "id"?: number;
    "name": string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface MarketingCompany {
    "id": number;
    "groupId"?: number;
    "defaultContactFlag"?: boolean;
    "allContactsFlag"?: boolean;
    "unsubscribeFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface MarketingContact {
    "id": number;
    "groupId"?: number;
    "note"?: string;
    "unsubscribeFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Member {
    "id"?: number;
    "identifier": string;

    /**
     * ConditionallyRequired. API Member will get random password generated
     */
    "password"?: string;
    "firstName": string;
    "middleInitial"?: string;
    "lastName": string;
    "title"?: string;
    "reportCard"?: ReportCardReference;

    /**
     * F = Full Member, A = API Member, C = StreamlineIT Member, X = Subcontractor Member
     */
    "licenseClass": Member.LicenseClassEnum;
    "disableOnlineFlag"?: boolean;
    "enableMobileFlag"?: boolean;
    "type"?: MemberTypeReference;
    "employeeIdentifer"?: string;
    "vendorNumber"?: string;
    "notes"?: string;
    "timeZone": TimeZoneSetupReference;
    "country"?: CountryReference;
    "serviceBoardTeamIds"?: Array<number>;
    "enableMobileGpsFlag"?: boolean;
    "inactiveDate"?: Date;
    "inactiveFlag"?: boolean;
    "lastLogin"?: string;
    "photo"?: DocumentReference;
    "officeEmail"?: string;
    "officePhone"?: string;
    "officeExtension"?: string;
    "mobileEmail"?: string;
    "mobilePhone"?: string;
    "mobileExtension"?: string;
    "homeEmail"?: string;
    "homePhone"?: string;
    "homeExtension"?: string;
    "defaultEmail": Member.DefaultEmailEnum;
    "defaultPhone": Member.DefaultPhoneEnum;
    "securityRole": SecurityRoleReference;
    "adminFlag"?: boolean;
    "structureLevel": StructureReference;
    "securityLocation": SystemLocationReference;
    "defaultLocation": SystemLocationReference;
    "defaultDepartment": SystemDepartmentReference;
    "reportsTo"?: MemberReference;
    "restrictLocationFlag"?: boolean;
    "restrictDepartmentFlag"?: boolean;
    "workRole": WorkRoleReference;
    "workType"?: WorkTypeReference;
    "timeApprover": MemberReference;
    "expenseApprover": MemberReference;
    "billableForecast"?: number;
    "dailyCapacity"?: number;
    "hourlyCost"?: number;
    "hourlyRate"?: number;
    "includeInUtilizationReportingFlag"?: boolean;
    "requireExpenseEntryFlag"?: boolean;
    "requireTimeSheetEntryFlag"?: boolean;
    "requireStartAndEndTimeOnTimeEntryFlag"?: boolean;
    "allowInCellEntryOnTimeSheet"?: boolean;
    "enterTimeAgainstCompanyFlag"?: boolean;
    "allowExpensesEnteredAgainstCompaniesFlag"?: boolean;
    "timeReminderEmailFlag"?: boolean;
    "daysTolerance"?: number;
    "minimumHours"?: number;
    "timeSheetStartDate"?: Date;
    "hireDate": Date;
    "serviceDefaultLocation"?: SystemLocationReference;
    "serviceDefaultDepartment"?: SystemDepartmentReference;
    "serviceDefaultBoard"?: BoardReference;
    "restrictServiceDefaultLocationFlag"?: boolean;
    "restrictServiceDefaultDepartmentFlag"?: boolean;
    "excludedServiceBoardIds"?: Array<number>;
    "projectDefaultLocation"?: SystemLocationReference;
    "projectDefaultDepartment"?: SystemDepartmentReference;
    "projectDefaultBoard"?: ProjectBoardReference;
    "restrictProjectDefaultLocationFlag"?: boolean;
    "restrictProjectDefaultDepartmentFlag"?: boolean;
    "excludedProjectBoardIds"?: Array<number>;
    "scheduleDefaultLocation"?: SystemLocationReference;
    "scheduleDefaultDepartment"?: SystemDepartmentReference;
    "scheduleCapacity"?: number;
    "serviceLocation"?: ServiceLocationReference;
    "restrictScheduleFlag"?: boolean;
    "hideMemberInDispatchPortalFlag"?: boolean;
    "calendar"?: CalendarReference;
    "salesDefaultLocation": SystemLocationReference;
    "restrictDefaultSalesTerritoryFlag"?: boolean;
    "warehouse"?: WarehouseReference;
    "warehouseBin"?: WarehouseBinReference;
    "restrictDefaultWarehouseFlag"?: boolean;
    "restrictDefaultWarehouseBinFlag"?: boolean;
    "mapiName"?: string;
    "calendarSyncIntegrationFlag"?: boolean;
    "enableLdapAuthenticationFlag"?: boolean;
    "ldapConfiguration"?: LdapConfigurationReference;
    "ldapUserName"?: string;
    "companyActivityTabFormat": Member.CompanyActivityTabFormatEnum;
    "invoiceTimeTabFormat": Member.InvoiceTimeTabFormatEnum;
    "invoiceScreenDefaultTabFormat": Member.InvoiceScreenDefaultTabFormatEnum;
    "invoicingDisplayOptions": Member.InvoicingDisplayOptionsEnum;
    "agreementInvoicingDisplayOptions": Member.AgreementInvoicingDisplayOptionsEnum;
    "corelyticsUsername"?: string;
    "corelyticsPassword"?: string;
    "remotePackage"?: Member.RemotePackageEnum;
    "remotePackagePlatform"?: string;
    "remotePackageUserName"?: string;
    "remotePackagePassword"?: string;
    "remotePackageAccount"?: string;
    "authenticationServiceType"?: Member.AuthenticationServiceTypeEnum;
    "timebasedOneTimePasswordActivated"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace Member {

export type LicenseClassEnum = 'F' | 'A' | 'C' | 'X';

export type DefaultEmailEnum = 'Office' | 'Mobile' | 'Home';

export type DefaultPhoneEnum = 'Office' | 'Mobile' | 'Home';

export type CompanyActivityTabFormatEnum = 'SummaryList' | 'DetailList';

export type InvoiceTimeTabFormatEnum = 'SummaryList' | 'DetailList';

export type InvoiceScreenDefaultTabFormatEnum = 'ShowInvoicingTab' | 'ShowAgreementInvoicingTab';

export type InvoicingDisplayOptionsEnum = 'RemainOnInvoicingScreen' | 'ShowRecentInvoices';

export type AgreementInvoicingDisplayOptionsEnum = 'RemainOnInvoicingScreen' | 'ShowRecentInvoices';

export type RemotePackageEnum = 'LogMeIn' | 'NTR';

export type AuthenticationServiceTypeEnum = 'AuthAnvil' | 'GoogleAuthenticator';
}
export interface MemberAccrual {
    "id"?: number;
    "accrualType": MemberAccrual.AccrualTypeEnum;
    "year": number;
    "hours": number;
    "reason": string;
    "member"?: MemberReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace MemberAccrual {

export type AccrualTypeEnum = 'Holiday' | 'PTO' | 'Sick' | 'Vacation';
}
export interface MemberCertification {
    "id"?: number;
    "certification": CertificationReference;
    "percentComplete"?: number;
    "dateReceived"?: Date;
    "dateExpires"?: Date;
    "certificationNumber"?: string;
    "notes"?: string;
    "member"?: MemberReference;
    "company"?: CompanyReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface MemberDeactivation {

    /**
     * The List of Activities Assigned to the Member
     */
    "salesActivity"?: SalesActivity;
    "serviceTeam"?: ServiceTeam;

    /**
     * A list of customers for which the member holds a team role
     */
    "companyTeam"?: CompanyTeam;

    /**
     * The Workflows to which the member is assigned
     */
    "workflow"?: Workflow;
    "statusWorkflow"?: StatusWorkflow;

    /**
     * The Service (Ticket) Templates on which the Member is the assignedTo resource
     */
    "serviceTemplate"?: ServiceTemplate;

    /**
     * A list of the member's currently assigned Opportunities
     */
    "opportunity"?: Opportunity;

    /**
     * A list of Sales Teams to which the member is assigned
     */
    "salesTeam"?: SalesTeam;

    /**
     * A list of Projects that the member is the project manager
     */
    "projectManager"?: ProjectManager;

    /**
     * A list of knowledge base articles that the member is the approver
     */
    "knowledgeBasebArticle"?: KnowledgebaseArticle;
    "myCompanyPresidentRole"?: MyCompanyPresidentRole;
    "myCompanyCOORole"?: MyCompanyCOORole;
    "myCompanyControllerRole"?: MyCompanyControllerRole;
    "myCompanyDispatchRole"?: MyCompanyDispatchRole;
    "myCompanyServiceManagerRole"?: MyCompanyServiceManagerRole;
    "myCompanyDutyManagerRole"?: MyCompanyDutyManagerRole;
    "departmentManager"?: DepartmentMananager;
    "dispatchMember"?: DispatchMember;
    "serviceManager"?: ServiceManger;
    "dutyManager"?: DutyManager;
    "deleteOpenTimeSheetsFlag"?: boolean;
}

export interface MemberDelegation {
    "id"?: number;
    "delegationType": MemberDelegation.DelegationTypeEnum;
    "delegatedTo": MemberReference;
    "dateStart": Date;
    "dateEnd": Date;
    "member"?: MemberReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace MemberDelegation {

export type DelegationTypeEnum = 'Approval' | 'Project';
}
/**
 * Service Status Notification member must be entered if the notify type is "Specific Member"
 */
export interface MemberReference {
    "id"?: number;
    "identifier"?: string;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface MemberSkill {
    "id"?: number;
    "skill": SkillReference;
    "skillLevel": MemberSkill.SkillLevelEnum;
    "certifiedFlag"?: boolean;
    "yearsExperience"?: number;
    "notes"?: string;
    "member"?: MemberReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace MemberSkill {

export type SkillLevelEnum = 'Beginner' | 'Intermediate' | 'Advanced' | 'Expert';
}
export interface MemberTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface MenuEntry {
    "id"?: number;
    "menuLocation": MenuLocationReference;
    "caption": string;
    "link": string;
    "newWindowFlag": boolean;
    "locationIds"?: Array<number>;
    "origin"?: string;
    "addAllLocations"?: boolean;
    "removeAllLocations"?: boolean;
    "smallMenuIconId"?: number;
    "largeMenuIconId"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface MenuEntryLocation {
    "id"?: number;
    "location": SystemLocationReference;
    "menuEntry"?: SystemMenuEntryReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface MenuLocationReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

/**
 * Metadata of the entity
 */
export interface Metadata {
}

export interface MyCompanyCOORole {
    "count"?: number;
    "reAssignToMember"?: MemberReference;
}

export interface MyCompanyControllerRole {
    "count"?: number;
    "reAssignToMember"?: MemberReference;
}

export interface MyCompanyDispatchRole {
    "count"?: number;
    "reAssignToMember"?: MemberReference;
}

export interface MyCompanyDutyManagerRole {
    "count"?: number;
    "reAssignToMember"?: MemberReference;
}

export interface MyCompanyPresidentRole {
    "count"?: number;
    "reAssignToMember"?: MemberReference;
}

export interface MyCompanyServiceManagerRole {
    "count"?: number;
    "reAssignToMember"?: MemberReference;
}

export interface NoteType {
    "id"?: number;
    "identifier"?: string;
    "name": string;
    "defaultFlag"?: boolean;
    "importFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface NoteTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface NotificationRecipient {
    "id"?: number;
    "identifier"?: string;
    "name"?: string;
    "externalFlag"?: boolean;
    "serviceFlag"?: boolean;
    "salesFlag"?: boolean;
    "invoiceFlag"?: boolean;
    "agreementFlag"?: boolean;
    "memberFlag"?: boolean;
    "configFlag"?: boolean;
    "mspFlag"?: boolean;
    "trackFlag"?: boolean;
    "projectFlag"?: boolean;
    "procurementFlag"?: boolean;
    "knowledgeBaseFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

/**
 * Required when notifyType is set to: "Create Activity", "Send Email", "Add Follower", "Assign Resource", "Close Survey"
 */
export interface NotificationRecipientReference {
    "id"?: number;
    "identifier"?: string;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface NotifyTypeReference {
    "id"?: number;
    "identifier"?: string;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

/**
 * A list of the member's currently assigned Opportunities
 */
export interface Opportunity {
    "id"?: number;
    "name": string;
    "expectedCloseDate"?: Date;
    "type"?: OpportunityTypeReference;
    "stage"?: OpportunityStageReference;
    "status"?: OpportunityStatusReference;
    "priority"?: OpportunityPriorityReference;
    "notes"?: string;
    "probability"?: OpportunityProbabilityReference;
    "source"?: string;
    "rating"?: OpportunityRatingReference;
    "campaign"?: CampaignReference;
    "primarySalesRep": MemberReference;
    "secondarySalesRep"?: MemberReference;
    "locationId"?: number;
    "businessUnitId"?: number;
    "company": CompanyReference;
    "contact": ContactReference;
    "site": SiteReference;
    "customerPO"?: string;
    "pipelineChangeDate"?: Date;
    "dateBecameLead"?: Date;
    "closedDate"?: Date;
    "closedBy"?: MemberReference;
    "totalSalesTax"?: number;
    "shipToCompany"?: CompanyReference;
    "shipToContact"?: ContactReference;
    "shipToSite"?: SiteReference;
    "billToCompany"?: CompanyReference;
    "billToContact"?: ContactReference;
    "billToSite"?: SiteReference;
    "billingTerms"?: BillingTermsReference;
    "taxCode"?: TaxCodeReference;
    "currency"?: CurrencyReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "customFields"?: Array<CustomFieldValue>;
    "count"?: number;
    "reAssignToMember"?: MemberReference;
}

export interface OpportunityContact {
    "id"?: number;
    "contact": ContactReference;
    "company"?: CompanyReference;
    "role"?: OpportunitySalesRoleReference;
    "notes"?: string;
    "referralFlag"?: boolean;
    "opportunityId"?: number;
    "phoneNumber"?: string;
    "emailAddress"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface OpportunityNote {
    "id"?: number;
    "opportunityId"?: number;
    "type"?: NoteTypeReference;
    "text": string;
    "flagged"?: boolean;
    "enteredBy"?: string;
    "mobileGuid"?: Guid;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface OpportunityPriorityReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface OpportunityProbabilityReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface OpportunityRating {
    "id"?: number;
    "name": string;
    "sortOrder"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface OpportunityRatingReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface OpportunityReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface OpportunitySalesRoleReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface OpportunityStage {
    "id"?: number;
    "name": string;
    "probability"?: OpportunityProbabilityReference;
    "color"?: string;
    "sequenceNumber"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface OpportunityStageReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface OpportunityStatus {
    "id"?: number;
    "name": string;
    "wonFlag"?: boolean;
    "lostFlag"?: boolean;
    "closedFlag"?: boolean;
    "inactiveFlag"?: boolean;
    "defaultFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "enteredBy"?: string;
    "dateEntered"?: Date;
}

/**
 * Required when acceptanceChangeStatusFlag is true
 */
export interface OpportunityStatusReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface OpportunityToAgreementConversion {
    "agreementId"?: number;
    "name"?: string;
    "type"?: AgreementTypeReference;
    "startDate"?: string;
    "endDate"?: string;
    "noEndingDateFlag"?: boolean;
    "billCycleId"?: number;
    "billOneTimeFlag"?: boolean;
    "locationId"?: number;
    "businessUnitId"?: number;
    "includeAllNotesFlag"?: boolean;
    "includeAllDocumentsFlag"?: boolean;
    "includeAllProductsFlag"?: boolean;
    "includeNoteIds"?: Array<number>;
    "includeDocumentIds"?: Array<number>;
    "includeProductIds"?: Array<number>;
}

export interface OpportunityToProjectConversion {
    "projectId"?: number;
    "name"?: string;
    "status"?: ProjectStatusReference;
    "locationId"?: number;
    "businessUnitId"?: number;
    "board"?: ProjectBoardReference;
    "manager"?: MemberReference;
    "estimatedStart"?: string;
    "estimatedEnd"?: string;
    "includeAllNotesFlag"?: boolean;
    "includeAllDocumentsFlag"?: boolean;
    "includeAllProductsFlag"?: boolean;
    "includeNoteIds"?: Array<number>;
    "includeDocumentIds"?: Array<number>;
    "includeProductIds"?: Array<number>;
}

export interface OpportunityToSalesOrderConversion {
    "salesOrderId"?: number;
    "name"?: string;
    "includeAllNotesFlag"?: boolean;
    "includeAllDocumentsFlag"?: boolean;
    "includeAllProductsFlag"?: boolean;
    "includeNoteIds"?: Array<number>;
    "includeDocumentIds"?: Array<number>;
    "includeProductIds"?: Array<number>;
}

export interface OpportunityToServiceTicketConversion {
    "ticketId"?: number;
    "summary"?: string;
    "includeAllNotesFlag"?: boolean;
    "includeAllDocumentsFlag"?: boolean;
    "includeAllProductsFlag"?: boolean;
    "includeNoteIds"?: Array<number>;
    "includeDocumentIds"?: Array<number>;
    "includeProductIds"?: Array<number>;
}

export interface OpportunityType {
    "id"?: number;
    "description": string;
    "inactiveFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface OpportunityTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Order {
    "id"?: number;
    "company": CompanyReference;
    "contact"?: ContactReference;
    "phone"?: string;
    "phoneExt"?: string;
    "email"?: string;
    "site"?: SiteReference;
    "status": OrderStatusReference;
    "opportunity"?: OpportunityReference;
    "orderDate"?: Date;
    "dueDate"?: Date;
    "billingTerms"?: BillingTermsReference;
    "taxCode"?: TaxCodeReference;
    "poNumber"?: string;
    "locationId"?: number;
    "businessUnitId"?: number;
    "salesRep": MemberReference;
    "notes"?: string;
    "billClosedFlag"?: boolean;
    "billShippedFlag"?: boolean;
    "restrictDownpaymentFlag"?: boolean;
    "description"?: string;
    "topCommentFlag"?: boolean;
    "bottomCommentFlag"?: boolean;
    "shipToCompany"?: CompanyReference;
    "shipToContact"?: ContactReference;
    "shipToSite"?: SiteReference;
    "billToCompany"?: CompanyReference;
    "billToContact"?: ContactReference;
    "billToSite"?: SiteReference;
    "productIds"?: Array<number>;
    "documentIds"?: Array<number>;
    "invoiceIds"?: Array<number>;
    "configIds"?: Array<number>;
    "total"?: number;
    "taxTotal"?: number;
    "currency"?: CurrencyReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface OrderStatus {
    "id"?: number;
    "name": string;
    "defaultFlag"?: boolean;
    "inactiveFlag"?: boolean;
    "sortOrder"?: number;
    "closedFlag"?: boolean;
    "emailTemplate"?: OrderStatusEmailTemplateReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface OrderStatusEmailTemplate {
    "id"?: number;
    "status"?: OrderStatusReference;
    "useSenderFlag"?: boolean;
    "firstName"?: string;
    "lastName"?: string;
    "emailAddress"?: string;
    "subject": string;
    "body": string;
    "copySenderFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface OrderStatusEmailTemplateReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface OrderStatusNotification {
    "id"?: number;
    "notifyWho": NotificationRecipientReference;
    "status"?: OrderStatusReference;

    /**
     * Order Status Notification member must be entered if the notify type is "Specific Member"
     */
    "member"?: MemberReference;

    /**
     * Order Status Notification sendEmail must be entered if the notify type is "Email Address"
     */
    "email"?: string;
    "workflowStep"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

/**
 * Required when notifyType is set to: "Change Sales Order Status"
 */
export interface OrderStatusReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Other {
    "id"?: number;
    "defaultLdap"?: LdapConfigurationReference;
    "defaultFromAddress": string;
    "portalUrlOverride": string;
    "siteUrl": string;
    "logoPath"?: string;
    "contactSync"?: Other.ContactSyncEnum;
    "serverTimeZone": TimeZoneSetupReference;
    "defaultCalendar": CalendarReference;
    "defaultAddressFormat": AddressFormatReference;
    "useSslFlag"?: boolean;
    "syncLeadsFlag"?: boolean;
    "includePortalLinkFlag"?: boolean;
    "useExpandedFormatTimeFlag"?: boolean;
    "useExpandedFormatActivityFlag"?: boolean;

    /**
     * If true, all Members time zone will also be set to serverTimeZone. Otherwise, only My Company time zone will be updated.
     */
    "updateMemberTimeZonesFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace Other {

export type ContactSyncEnum = 'FL' | 'LF' | 'CFL' | 'CLF';
}
export interface OwnershipType {
    "id"?: number;
    "name": string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface OwnershipTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ParsingType {
    "id"?: number;
    "name"?: string;
    "parseRule"?: string;
    "defaultFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ParsingVariable {
    "id"?: number;
    "name"?: string;
    "code"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface PatchOperation {
    "op"?: string;
    "path"?: string;
    "value"?: string;
}

export interface Payment {
    "id"?: number;
    "type"?: string;
    "invoice"?: InvoiceReference;
    "amount": number;
    "paymentDate"?: Date;
    "appliedBy"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface PaymentMethodReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface PaymentType {
    "id"?: number;
    "name": string;
    "classification": ClassificationReference;
    "defaultFlag"?: boolean;
    "companyFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface PhaseStatusReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface PortalCalendar {
    "id"?: number;
    "weekStart": PortalCalendar.WeekStartEnum;
    "adjust1Start"?: string;
    "adjust1End"?: string;
    "adjust1Hours"?: number;
    "adjust2Start"?: string;
    "adjust2End"?: string;
    "adjust2Hours"?: number;
    "adjust3Start"?: string;
    "adjust3End"?: string;
    "adjust3Hours"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace PortalCalendar {

export type WeekStartEnum = 'Sunday' | 'Monday' | 'Tuesday' | 'Wednesday' | 'Thursday' | 'Friday' | 'Saturday';
}
export interface PortalConfiguration {
    "id"?: number;
    "name": string;
    "defaultFlag"?: boolean;
    "company"?: CompanyReference;
    "loginBackgroundColor"?: string;
    "portalBackgroundColor"?: string;
    "menuColor"?: string;
    "buttonColor"?: string;
    "headerColor"?: string;
    "url"?: string;
    "language"?: PortalConfiguration.LanguageEnum;
    "welcomeText"?: string;
    "boardIds"?: Array<number>;
    "agreementTypeIds"?: Array<number>;
    "configTypeIds"?: Array<number>;
    "locationIds"?: Array<number>;
    "displayVendorFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace PortalConfiguration {

export type LanguageEnum = 'English' | 'Spanish' | 'French' | 'British' | 'Australian' | 'BrazilianPortuguese' | 'CanadianFrench' | 'German' | 'NewZealand';
}
export interface PortalConfigurationInvoiceSetup {
    "id"?: number;
    "portalConfiguration"?: PortalConfigurationReference;
    "displayInvPmtFlag"?: boolean;
    "allowInvPmtFlag"?: boolean;
    "location"?: SystemLocationReference;
    "paymentProcessor"?: PortalConfigurationInvoiceSetup.PaymentProcessorEnum;
    "login"?: string;
    "password"?: string;
    "urlOverride"?: string;
    "billingStatusIds"?: Array<number>;
    "addAllStatuses"?: boolean;
    "removeAllStatuses"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace PortalConfigurationInvoiceSetup {

export type PaymentProcessorEnum = 'AuthorizeNET' | 'PayPal';
}
export interface PortalConfigurationOpportunitySetup {
    "id"?: number;
    "opportunityStatusRecIDs"?: Array<number>;
    "addAllOpportunityStatuses"?: boolean;
    "removeAllOpportunityStatuses"?: boolean;
    "opportunityTypeRecIDs"?: Array<number>;
    "addAllOpportunityTypes"?: boolean;
    "removeAllOpportunityTypes"?: boolean;
    "restrictViewByOpportunityStatusFlag"?: boolean;
    "restrictViewByOpportunityTypeFlag"?: boolean;
    "acceptanceChangeStatusFlag"?: boolean;
    "acceptanceCreateActivityFlag"?: boolean;

    /**
     * Required when acceptanceChangeStatusFlag is true
     */
    "acceptanceOpportunityStatus"?: OpportunityStatusReference;
    "acceptanceSendEmailFlag"?: boolean;
    "acceptanceEmailFromFirstName"?: string;
    "acceptanceEmailFromLastName"?: string;
    "acceptanceEmailSubject"?: string;
    "acceptanceEmailBody"?: string;

    /**
     * Required when acceptanceSendEmailFlag is true
     */
    "acceptanceFromEmail"?: string;

    /**
     * Required when acceptanceCreateActivityFlag is true
     */
    "acceptanceEmailActivityType"?: ActivityTypeReference;

    /**
     * Required when acceptanceCreateActivityFlag is true
     */
    "acceptanceEmailAssignedByMember"?: MemberReference;
    "rejectionChangeStatusFlag"?: boolean;
    "rejectionCreateActivityFlag"?: boolean;

    /**
     * Required when rejectionChangeStatusFlag is true
     */
    "rejectionOpportunityStatus"?: OpportunityStatusReference;
    "rejectionSendEmailFlag"?: boolean;
    "rejectionEmailFromFirstName"?: string;
    "rejectionEmailFromLastName"?: string;

    /**
     * Required when rejectionSendEmailFlag is true
     */
    "rejectionFromEmail"?: string;
    "rejectionEmailSubject"?: string;
    "rejectionEmailBody"?: string;

    /**
     * Required when rejectionCreateActivityFlag is true
     */
    "rejectionEmailActivityType"?: ActivityTypeReference;

    /**
     * Required when rejectionCreateActivityFlag is true
     */
    "rejectionEmailAssignedByMember"?: MemberReference;
    "confirmationSendEmailFlag"?: boolean;
    "confirmationEmailUseDefaultCompanyEmailAddressFlag"?: boolean;
    "confirmationEmailFromFirstName"?: string;
    "confirmationEmailFromLastName"?: string;

    /**
     * Required when confirmationSendEmailFlag is true
     */
    "confirmationFromEmail"?: string;
    "confirmationEmailSubject"?: string;
    "confirmationEmailBody"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface PortalConfigurationPasswordEmailSetup {
    "id"?: number;
    "validPasswordEmailUseCustomEmailFlag"?: boolean;
    "validPasswordEmailFromFirstName"?: string;
    "validPasswordEmailFromLastName"?: string;

    /**
     * Required when validPasswordEmailUseCustomEmailFlag is true
     */
    "validPasswordEmailFromEmail"?: string;
    "validPasswordEmailSubject"?: string;
    "validPasswordEmailBody"?: string;
    "invalidPasswordEmailUseCustomEmailFlag"?: boolean;
    "invalidPasswordEmailFromFirstName"?: string;
    "invalidPasswordEmailFromLastName"?: string;

    /**
     * Required when invalidPasswordEmailUseCustomEmailFlag is true
     */
    "invalidPasswordEmailFromEmail"?: string;
    "invalidPasswordEmailSubject"?: string;
    "invalidPasswordEmailBody"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface PortalConfigurationProjectSetup {
    "id"?: number;
    "portalConfig"?: PortalConfigurationReference;
    "projectNameFlag"?: boolean;
    "projectTypeFlag"?: boolean;
    "statusFlag"?: boolean;
    "projectManagerFlag"?: boolean;
    "billingMethodFlag"?: boolean;
    "contactFlag"?: boolean;
    "estimatedStartFlag"?: boolean;
    "estimatedEndFlag"?: boolean;
    "descriptionFlag"?: boolean;
    "lastUpdatedFlag"?: boolean;
    "onlyDisplay"?: PortalConfigurationProjectSetup.OnlyDisplayEnum;
    "timeMaterialBudgetHrsFlag"?: boolean;
    "timeMaterialScheduledStartFlag"?: boolean;
    "timeMaterialScheduledFinishFlag"?: boolean;
    "timeMaterialScheduledHrsFlag"?: boolean;
    "timeMaterialActualStartFlag"?: boolean;
    "timeMaterialActualFinishFlag"?: boolean;
    "timeMaterialActualHrsFlag"?: boolean;
    "timeMaterialBillFlag"?: boolean;
    "timeMaterialStatusFlag"?: boolean;
    "timeMaterialAssignedFlag"?: boolean;
    "fixedFeeBudgetHrsFlag"?: boolean;
    "fixedFeeScheduledStartFlag"?: boolean;
    "fixedFeeScheduledFinishFlag"?: boolean;
    "fixedFeeScheduledHrsFlag"?: boolean;
    "fixedFeeActualStartFlag"?: boolean;
    "fixedFeeActualFinishFlag"?: boolean;
    "fixedFeeActualHrsFlag"?: boolean;
    "fixedFeeBillFlag"?: boolean;
    "fixedFeeStatusFlag"?: boolean;
    "fixedFeeAssignedFlag"?: boolean;
    "projectIssueBudgetHrsFlag"?: boolean;
    "projectIssueScheduledStartFlag"?: boolean;
    "projectIssueScheduledFinishFlag"?: boolean;
    "projectIssueScheduledHrsFlag"?: boolean;
    "projectIssueActualStartFlag"?: boolean;
    "projectIssueActualFinishFlag"?: boolean;
    "projectIssueActualHrsFlag"?: boolean;
    "projectIssueBillFlag"?: boolean;
    "projectIssueStatusFlag"?: boolean;
    "projectIssueAssignedFlag"?: boolean;
    "projectDetailTotalHoursFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace PortalConfigurationProjectSetup {

export type OnlyDisplayEnum = 'DoNotDisplay' | 'Closed30Days' | 'Closed60Days' | 'Closed90Days' | 'Closed120Days' | 'AllClosed';
}
export interface PortalConfigurationReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface PortalConfigurationServiceSetup {
    "id"?: number;
    "serviceTypeFlag"?: boolean;
    "serviceSubTypeFlag"?: boolean;
    "serviceSubTypeItemFlag"?: boolean;
    "statusFlag"?: boolean;
    "siteNameFlag"?: boolean;
    "enteredDateFlag"?: boolean;
    "lastUpdateFlag"?: boolean;
    "requiredDateFlag"?: boolean;
    "contactFlag"?: boolean;
    "assignedResourcesFlag"?: boolean;
    "slaInfoFlag"?: boolean;
    "serviceBoardFlag"?: boolean;
    "budgetHoursFlag"?: boolean;
    "actualHoursFlag"?: boolean;
    "approvalStatusFlag"?: boolean;
    "openTasksFlag"?: boolean;
    "closedTasksFlag"?: boolean;
    "displayClosedTicketsOption": PortalConfigurationServiceSetup.DisplayClosedTicketsOptionEnum;
    "timeMaterialsTicketTemplate": ServiceSignoffReference;
    "fixedFeeTicketTemplate": ServiceSignoffReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace PortalConfigurationServiceSetup {

export type DisplayClosedTicketsOptionEnum = 'DoNotDisplay' | 'Closed30Days' | 'Closed60Days' | 'Closed90Days' | 'Closed120Days' | 'AllClosed';
}
export interface PortalReport {
    "id"?: number;
    "portalConfiguration"?: PortalConfigurationReference;
    "name": string;
    "url": string;
    "openSameWindowFlag"?: boolean;
    "customFlag"?: boolean;
    "displayFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface PortalSecurity {
    "identifier"?: string;
    "enabled"?: boolean;
    "id"?: number;
    "functionIdentifier"?: string;
    "functionDescription"?: string;
    "levelOne"?: boolean;
    "levelTwo"?: boolean;
    "levelThree"?: boolean;
    "levelFour"?: boolean;
    "levelFive"?: boolean;
    "levelSix"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface PortalSecurityLevel {
    "id"?: number;
    "captionIdentifier"?: string;
    "isDefaultFlag"?: boolean;
    "caption"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface PricingBreak {
    "id"?: number;
    "detailId"?: number;
    "amount"?: number;
    "quantityStart": number;
    "quantityEnd"?: number;
    "unlimited"?: boolean;
    "priceMethod": PricingBreak.PriceMethodEnum;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace PricingBreak {

export type PriceMethodEnum = 'FlatRateForRange' | 'PercentMarkupFromCost' | 'PercentMarkdownFromPrice' | 'PricePerUnit';
}
export interface PricingDetail {
    "id"?: number;
    "product"?: CatalogItemReference;
    "category"?: ProductCategoryReference;
    "subCategory"?: ProductSubCategoryReference;
    "startDate": Date;
    "endDate"?: Date;
    "noEndDate"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface PricingSchedule {
    "id"?: number;
    "name": string;
    "inactiveFlag"?: boolean;
    "defaultFlag"?: boolean;
    "currency"?: CurrencyReference;
    "companies"?: Array<number>;
    "setAllCompaniesFlag"?: boolean;
    "removeAllCompaniesFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface PricingScheduleReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Priority {
    "id"?: number;
    "name": string;
    "color": string;
    "sortOrder"?: number;
    "defaultFlag"?: boolean;
    "imageLink"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface PriorityReference {
    "id"?: number;
    "name"?: string;
    "sort"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ProductCategoryReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ProductComponent {
    "id"?: number;
    "sequenceNumber"?: number;
    "quantity": number;
    "catalogItem": CatalogItemReference;
    "hidePriceFlag"?: boolean;
    "hideItemIdentifierFlag"?: boolean;
    "hideDescriptionFlag"?: boolean;
    "hideQuantityFlag"?: boolean;
    "vendor"?: CompanyReference;
    "parentProductItem"?: ProductItemReference;
    "productItem"?: ProductItemReference;
    "price"?: number;
    "cost"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ProductItem {
    "id"?: number;
    "catalogItem": CatalogItemReference;
    "chargeToId": number;
    "chargeToType": ProductItem.ChargeToTypeEnum;
    "description"?: string;
    "sequenceNumber"?: number;
    "quantity"?: number;
    "price"?: number;
    "cost"?: number;
    "discount"?: number;
    "priceMethod"?: ProductItem.PriceMethodEnum;
    "billableOption": ProductItem.BillableOptionEnum;
    "agreement"?: AgreementReference;
    "locationId"?: number;
    "businessUnitId"?: number;
    "vendor"?: CompanyReference;
    "vendorSku"?: string;
    "taxableFlag"?: boolean;
    "dropshipFlag"?: boolean;
    "specialOrderFlag"?: boolean;
    "phaseProductFlag"?: boolean;
    "cancelledFlag"?: boolean;
    "quantityCancelled"?: number;
    "cancelledReason"?: string;
    "customerDescription"?: string;
    "internalNotes"?: string;
    "productSuppliedFlag"?: boolean;
    "subContractorShipToId"?: number;
    "subContractorAmountLimit"?: number;
    "recurring"?: ProductRecurring;
    "sla"?: SLAReference;
    "entityType"?: EntityTypeReference;
    "forecastDetailId"?: number;
    "cancelledBy"?: number;
    "cancelledDate"?: Date;
    "warehouse"?: string;
    "warehouseBin"?: string;
    "purchaseDate"?: Date;
    "integrationXRef"?: string;
    "listPrice"?: number;
    "serialNumberIds"?: Array<number>;
    "company"?: CompanyReference;
    "forecastStatus"?: OpportunityStatusReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "bypassForecastUpdate"?: boolean;
    "customFields"?: Array<CustomFieldValue>;
}

export namespace ProductItem {

export type ChargeToTypeEnum = 'Ticket' | 'Project' | 'Invoice' | 'Opportunity' | 'SalesOrder';

export type PriceMethodEnum = 'FlatRateForRange' | 'PercentMarkupFromCost' | 'PercentMarkdownFromPrice' | 'PricePerUnit';

export type BillableOptionEnum = 'Billable' | 'DoNotBill' | 'NoCharge';
}
export interface ProductItemReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ProductPickingShippingDetail {
    "id"?: number;
    "pickedQuantity": number;
    "shippedQuantity": number;
    "warehouse": WarehouseReference;
    "warehouseBin": WarehouseBinReference;
    "shipmentMethod"?: ShipmentMethodReference;
    "serialNumber"?: string;
    "serialNumberIds"?: Array<number>;
    "trackingNumber"?: string;
    "productItem"?: ProductItemReference;
    "lineNumber"?: number;
    "quantity"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ProductRecurring {
    "recurringRevenue": number;
    "recurringCost": number;
    "startDate": Date;
    "endDate": Date;
    "billCycleId": number;
    "cycles": number;
    "cycleType": ProductRecurring.CycleTypeEnum;
}

export namespace ProductRecurring {

export type CycleTypeEnum = 'CalendarYear' | 'ContractYear';
}
export interface ProductReference {
    "id"?: number;
    "description"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ProductSubCategoryReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ProductType {
    "id"?: number;
    "name": string;
    "inactiveFlag"?: boolean;
    "typeXref"?: ProductType.TypeXrefEnum;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace ProductType {

export type TypeXrefEnum = 'InventoryPart' | 'NonInventoryPart' | 'OtherCharge' | 'Service';
}
export interface ProductTypeExemption {
    "id"?: number;
    "productType": ProductTypeReference;

    /**
     * At least one level flag is required -- levelOneFlag, levelTwoFlag, levelThreeFlag, levelFourFlag, and/or levelFiveFlag
     */
    "levelOneFlag"?: boolean;

    /**
     * At least one level flag is required -- levelOneFlag, levelTwoFlag, levelThreeFlag, levelFourFlag, and/or levelFiveFlag
     */
    "levelTwoFlag"?: boolean;

    /**
     * At least one level flag is required -- levelOneFlag, levelTwoFlag, levelThreeFlag, levelFourFlag, and/or levelFiveFlag
     */
    "levelThreeFlag"?: boolean;

    /**
     * At least one level flag is required -- levelOneFlag, levelTwoFlag, levelThreeFlag, levelFourFlag, and/or levelFiveFlag
     */
    "levelFourFlag"?: boolean;

    /**
     * At least one level flag is required -- levelOneFlag, levelTwoFlag, levelThreeFlag, levelFourFlag, and/or levelFiveFlag
     */
    "levelFiveFlag"?: boolean;
    "taxCode"?: TaxCodeReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ProductTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Project {
    "id"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "actualEnd"?: Date;
    "actualHours"?: number;
    "actualStart"?: Date;
    "agreement"?: AgreementReference;
    "billExpenses"?: Project.BillExpensesEnum;
    "billingAmount"?: number;
    "billingAttention"?: string;
    "billingMethod": Project.BillingMethodEnum;
    "billingRateType"?: Project.BillingRateTypeEnum;
    "billingTerms"?: BillingTermsReference;
    "billProducts"?: Project.BillProductsEnum;
    "billProjectAfterClosedFlag"?: boolean;
    "billTime"?: Project.BillTimeEnum;
    "billToCompany"?: CompanyReference;
    "billToContact"?: ContactReference;
    "billToSite"?: SiteReference;
    "billUnapprovedTimeAndExpense"?: boolean;
    "board": ProjectBoardReference;
    "budgetAnalysis"?: Project.BudgetAnalysisEnum;
    "budgetFlag"?: boolean;
    "budgetHours"?: number;
    "businessUnitId"?: number;
    "company": CompanyReference;
    "contact"?: ContactReference;
    "customerPO"?: string;
    "description"?: string;
    "currency"?: CurrencyReference;
    "downpayment"?: number;
    "estimatedEnd": Date;
    "estimatedExpenseRevenue"?: number;
    "estimatedHours"?: number;
    "estimatedProductRevenue"?: number;
    "estimatedStart": Date;
    "estimatedTimeRevenue"?: number;
    "expenseApprover"?: MemberReference;
    "includeDependenciesFlag"?: boolean;
    "includeEstimatesFlag"?: boolean;
    "locationId"?: number;
    "manager"?: MemberReference;
    "name": string;
    "opportunity"?: OpportunityReference;
    "projectTemplateId"?: number;
    "restrictDownPaymentFlag"?: boolean;
    "scheduledEnd"?: Date;
    "scheduledHours"?: number;
    "scheduledStart"?: Date;
    "shipToCompany"?: CompanyReference;
    "shipToContact"?: ContactReference;
    "shipToSite"?: SiteReference;
    "site"?: SiteReference;
    "status"?: ProjectStatusReference;
    "timeApprover"?: MemberReference;
    "type"?: ProjectTypeReference;
    "doNotDisplayInPortalFlag"?: boolean;
    "billingStartDate"?: Date;
    "estimatedTimeCost"?: number;
    "estimatedExpenseCost"?: number;
    "estimatedProductCost"?: number;
    "taxCode"?: TaxCodeReference;
}

export namespace Project {

export type BillExpensesEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillingMethodEnum = 'ActualRates' | 'FixedFee' | 'NotToExceed' | 'OverrideRate';

export type BillingRateTypeEnum = 'WorkRole' | 'StaffMember';

export type BillProductsEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillTimeEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BudgetAnalysisEnum = 'ActualHours' | 'BillableHours';
}
export interface ProjectBoardReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ProjectContact {
    "id"?: number;
    "projectId"?: number;
    "contact": ContactReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

/**
 * A list of Projects that the member is the project manager
 */
export interface ProjectManager {
    "count"?: number;
    "reAssignToMember"?: MemberReference;
}

export interface ProjectNote {
    "id"?: number;
    "projectId"?: number;
    "text": string;
    "type"?: NoteTypeReference;
    "flagged"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ProjectPhase {
    "id"?: number;
    "projectId"?: number;
    "description": string;
    "board"?: ProjectBoardReference;
    "status"?: PhaseStatusReference;
    "agreement"?: AgreementReference;
    "opportunity"?: OpportunityReference;
    "parentPhase"?: ProjectPhaseReference;
    "wbsCode"?: string;
    "billTime"?: ProjectPhase.BillTimeEnum;
    "billExpenses"?: ProjectPhase.BillExpensesEnum;
    "billProducts"?: ProjectPhase.BillProductsEnum;
    "markAsMilestoneFlag"?: boolean;
    "notes"?: string;
    "deadlineDate"?: Date;
    "billSeparatelyFlag"?: boolean;

    /**
     * billingMethod is required if the phase billSeparatelyFlag is true
     */
    "billingMethod"?: ProjectPhase.BillingMethodEnum;
    "scheduledHours"?: number;
    "scheduledStart"?: string;
    "scheduledEnd"?: string;
    "actualHours"?: number;
    "actualStart"?: string;
    "actualEnd"?: string;
    "budgetHours"?: number;
    "locationId"?: number;
    "businessUnitId"?: number;
    "hourlyRate"?: number;
    "billingStartDate"?: Date;

    /**
     * This phase can only be billed after it has been closed
     */
    "billPhaseClosedFlag"?: boolean;

    /**
     * This phase can only be billed after the project has been closed
     */
    "billProjectClosedFlag"?: boolean;
    "downpayment"?: number;
    "poNumber"?: string;
    "poAmount"?: number;
    "estimatedTimeCost"?: number;
    "estimatedExpenseCost"?: number;
    "estimatedProductCost"?: number;
    "estimatedTimeRevenue"?: number;
    "estimatedExpenseRevenue"?: number;
    "estimatedProductRevenue"?: number;
    "currency"?: CurrencyReference;
    "billToCompany"?: CompanyReference;
    "billToContact"?: ContactReference;
    "billToSite"?: SiteReference;
    "shipToCompany"?: CompanyReference;
    "shipToContact"?: ContactReference;
    "shipToSite"?: SiteReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace ProjectPhase {

export type BillTimeEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillExpensesEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillProductsEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillingMethodEnum = 'ActualRates' | 'FixedFee' | 'NotToExceed' | 'OverrideRate';
}
export interface ProjectPhaseReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ProjectReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ProjectRoleReference {
    "id"?: number;
    "identifier"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ProjectSecurityRole {
    "id"?: number;
    "name": string;
    "managerRoleFlag"?: boolean;
    "defaultContactFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ProjectSecurityRoleSetting {
    "id"?: number;
    "addLevel"?: ProjectSecurityRoleSetting.AddLevelEnum;
    "editLevel"?: ProjectSecurityRoleSetting.EditLevelEnum;
    "deleteLevel"?: ProjectSecurityRoleSetting.DeleteLevelEnum;
    "inquireLevel"?: ProjectSecurityRoleSetting.InquireLevelEnum;
    "moduleIdentifier"?: string;
    "myFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace ProjectSecurityRoleSetting {

export type AddLevelEnum = 'All' | 'My' | 'None';

export type EditLevelEnum = 'All' | 'My' | 'None';

export type DeleteLevelEnum = 'All' | 'My' | 'None';

export type InquireLevelEnum = 'All' | 'My' | 'None';
}
export interface ProjectStatus {
    "id"?: number;
    "name": string;
    "defaultFlag"?: boolean;
    "inactiveFlag"?: boolean;
    "noTimeFlag"?: boolean;
    "closedFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

/**
 * Required when notifyType is set to: "Change Project Status"
 */
export interface ProjectStatusReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ProjectTeammember {
    "id"?: number;
    "projectId"?: number;
    "hours"?: number;
    "member": MemberReference;
    "projectRole": ProjectRoleReference;
    "workRole"?: WorkRoleReference;
    "startDate"?: Date;
    "endDate"?: Date;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ProjectType {
    "id"?: number;
    "name"?: string;
    "defaultFlag"?: boolean;
    "inactiveFlag"?: boolean;
    "integrationXref"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ProjectTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface PurchaseOrder {
    "id"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "businessUnitId"?: number;
    "cancelReason"?: string;
    "closedFlag"?: boolean;
    "customerCity"?: string;
    "customerCompany"?: CompanyReference;
    "customerContact"?: ContactReference;
    "customerCountry"?: CountryReference;
    "customerExtension"?: string;
    "customerName"?: string;
    "customerPhone"?: string;
    "customerSite"?: SiteReference;
    "customerSiteName"?: string;
    "customerState"?: string;
    "customerStreetLine1"?: string;
    "customerStreetLine2"?: string;
    "customerZip"?: string;
    "dateClosed"?: Date;
    "dropShipCustomerFlag"?: boolean;
    "enteredBy"?: string;
    "freightCost"?: number;
    "freightPackingSlip"?: string;
    "freightTaxTotal"?: number;
    "internalNotes"?: string;
    "locationId": number;
    "poDate"?: Date;
    "poNumber"?: string;
    "salesTax"?: number;
    "shipmentDate"?: Date;
    "shipmentMethod"?: ShipmentMethodReference;
    "shippingInstructions"?: string;
    "status": PurchaseOrderStatusReference;
    "subTotal"?: number;
    "taxCode"?: TaxCodeReference;
    "taxFreightFlag"?: boolean;
    "taxPoFlag"?: boolean;
    "terms": BillingTermsReference;
    "total"?: number;
    "trackingNumber"?: string;

    /**
     * Determines whether or not to update all of the shipment info for each associated line item when new shipment info is passed in
     */
    "updateShipmentInfo"?: boolean;

    /**
     * Determines whether or not to update vendor order number for each associated line item when new vendor order number is passed in
     */
    "updateVendorOrderNumber"?: boolean;
    "vendorCompany": CompanyReference;
    "vendorContact"?: ContactReference;
    "vendorInvoiceDate"?: Date;
    "vendorInvoiceNumber"?: string;
    "vendorOrderNumber"?: string;
    "vendorSite"?: SiteReference;
    "warehouse"?: WarehouseReference;
    "currency"?: CurrencyReference;
}

export interface PurchaseOrderLineItem {
    "id"?: number;
    "backorderedFlag"?: boolean;
    "canceledBy"?: string;
    "canceledFlag"?: boolean;
    "canceledReason"?: string;
    "closedFlag"?: boolean;
    "dateCanceled"?: Date;
    "dateCanceledUtc"?: Date;
    "description": string;
    "displayInternalNotesFlag"?: boolean;
    "expectedShipDate"?: Date;
    "internalNotes"?: string;
    "lineNumber": number;
    "packingSlip"?: string;
    "product": IvItemReference;
    "purchaseOrderId"?: number;
    "quantity": number;
    "receivedQuantity"?: number;
    "serialNumbers"?: string;
    "shipDate"?: Date;
    "shipmentMethod"?: ShipmentMethodReference;
    "tax"?: number;
    "trackingNumber"?: string;
    "unitCost"?: number;
    "unitOfMeasure": UnitOfMeasureReference;
    "vendorOrderNumber"?: string;
    "warehouse"?: WarehouseReference;
    "warehouseBin"?: WarehouseBinReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface PurchaseOrderReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface PurchaseOrderStatus {
    "id"?: number;
    "name": string;
    "defaultFlag"?: boolean;
    "closedFlag"?: boolean;
    "inactiveFlag"?: boolean;
    "defaultClosedFlag"?: boolean;
    "sortOrder"?: number;
    "emailTemplate"?: PurchaseOrderStatusEmailTemplateReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface PurchaseOrderStatusEmailTemplate {
    "id"?: number;
    "status"?: PurchaseOrderStatusReference;
    "useSenderFlag"?: boolean;
    "firstName"?: string;
    "lastName"?: string;
    "emailAddress"?: string;
    "subject": string;
    "body"?: string;
    "copySenderFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface PurchaseOrderStatusEmailTemplateReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface PurchaseOrderStatusNotification {
    "id"?: number;
    "notifyWho": NotificationRecipientReference;
    "status"?: PurchaseOrderStatusReference;

    /**
     * Purchase Order Status Notification member must be entered if the notify type is "Specific Member"
     */
    "member"?: MemberReference;

    /**
     * Purchase Order Status Notification email must be entered if the notify type is "Email Address"
     */
    "email"?: string;
    "workflowStep"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface PurchaseOrderStatusReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Purchasing {
    "id"?: number;
    "startingPurchaseOrderNum": number;
    "purchaseOrderPrefix"?: string;
    "purchaseOrderSuffix"?: string;
    "prefixSuffixType"?: Purchasing.PrefixSuffixTypeEnum;
    "disableCostUpdatesFlag"?: boolean;
    "disableNegativeInventoryFlag"?: boolean;
    "costingMethod": Purchasing.CostingMethodEnum;
    "autoClosePurchaseOrderFlag"?: boolean;
    "autoClosePurchaseOrderItemFlag"?: boolean;
    "autoApprovePurchaseOrderFlag"?: boolean;
    "taxPurchaseOrderFlag"?: boolean;
    "taxFreightFlag"?: boolean;
    "useVendorTaxCodeFlag"?: boolean;
    "numDecimalPlaces"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace Purchasing {

export type PrefixSuffixTypeEnum = 'Prefix' | 'Suffix';

export type CostingMethodEnum = 'FIFO' | 'LIFO' | 'AverageCosting';
}
export interface RMAAction {
    "id"?: number;
    "name": string;
    "defaultFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface RMADisposition {
    "id"?: number;
    "name": string;
    "defaultFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface RelationshipReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ReminderReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Report {
    "name"?: string;
}

export interface ReportCard {
    "id"?: number;
    "name": string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ReportCardDetail {
    "id"?: number;
    "kpi": KPIReference;
    "sortOrder"?: number;
    "reportCard"?: ReportCardReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ReportCardReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ReportDataResponse {
    "columnDefinitions"?: Array<JObject>;
    "rowValues"?: Array<JObject>;
}

export interface ReportingService {
    "id"?: number;
    "reportingUserName"?: string;

    /**
     * To blank out the password, enter an empty string here.
     */
    "reportingPassword"?: string;
    "reportingDomain"?: string;
    "reportingUrl"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface RequestPasswordRequest {
    "email": string;
}

export interface RmaStatus {
    "id"?: number;
    "name": string;
    "defaultFlag"?: boolean;
    "sortOrder"?: number;
    "closedFlag"?: boolean;
    "emailTemplate"?: RmaStatusEmailTemplateReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface RmaStatusEmailTemplate {
    "id"?: number;
    "status"?: RmaStatusReference;
    "useSenderFlag"?: boolean;
    "firstName"?: string;
    "lastName"?: string;
    "emailAddress"?: string;
    "subject": string;
    "body": string;
    "copySenderFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface RmaStatusEmailTemplateReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface RmaStatusNotification {
    "id"?: number;
    "notifyWho": NotificationRecipientReference;
    "status"?: RmaStatusReference;

    /**
     * RMA Status Notification member must be entered if the notify type is "Specific Member"
     */
    "member"?: MemberReference;

    /**
     * RMA Status Notification sendEmail must be entered if the notify type is "Email Address"
     */
    "email"?: string;
    "workflowStep"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface RmaStatusReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Role {
    "id"?: number;
    "name": string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface SLA {
    "id"?: number;
    "name": string;
    "basedOn": SLA.BasedOnEnum;

    /**
     * customCalendar is a required reference if basedOn SLA Hours Type is Custom
     */
    "customCalendar"?: CalendarReference;
    "defaultFlag"?: boolean;
    "applicationOrder"?: number;
    "hiImpactHiUrgency"?: PriorityReference;
    "hiImpactMedUrgency"?: PriorityReference;
    "hiImpactLowUrgency"?: PriorityReference;
    "medImpactHiUrgency"?: PriorityReference;
    "medImpactMedUrgency"?: PriorityReference;
    "medImpactLowUrgency"?: PriorityReference;
    "lowImpactHiUrgency"?: PriorityReference;
    "lowImpactMedUrgency"?: PriorityReference;
    "lowImpactLowUrgency"?: PriorityReference;
    "respondHours"?: number;
    "respondPercent"?: number;
    "planWithin"?: number;
    "planWithinPercent"?: number;
    "resolutionHours"?: number;
    "resolutionPercent"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace SLA {

export type BasedOnEnum = 'MyCalendar' | 'Customer' | 'AllHours' | 'Custom';
}
export interface SLAPriority {
    "id"?: number;
    "priority": PriorityReference;
    "respondHours"?: number;
    "respondPercent"?: number;
    "planWithin"?: number;
    "planWithinPercent"?: number;
    "resolutionHours"?: number;
    "resolutionPercent"?: number;
    "sla"?: SLAReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface SLAReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

/**
 * The List of Activities Assigned to the Member
 */
export interface SalesActivity {
    "count"?: number;
    "reAssignToMember"?: MemberReference;
}

export interface SalesProbability {
    "id"?: number;
    "probability": number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface SalesQuota {
    "id"?: number;
    "member": MemberReference;
    "forecastYear"?: number;
    "location": SystemLocationReference;
    "department"?: SystemDepartmentReference;
    "category"?: ProductCategoryReference;
    "subCategory"?: ProductSubCategoryReference;
    "januaryRevenue"?: number;
    "januaryMargin"?: number;
    "februaryRevenue"?: number;
    "februaryMargin"?: number;
    "marchRevenue"?: number;
    "marchMargin"?: number;
    "aprilRevenue"?: number;
    "aprilMargin"?: number;
    "mayRevenue"?: number;
    "mayMargin"?: number;
    "juneRevenue"?: number;
    "juneMargin"?: number;
    "julyRevenue"?: number;
    "julyMargin"?: number;
    "augustRevenue"?: number;
    "augustMargin"?: number;
    "septemberRevenue"?: number;
    "septemberMargin"?: number;
    "octoberRevenue"?: number;
    "octoberMargin"?: number;
    "novemberRevenue"?: number;
    "novemberMargin"?: number;
    "decemberRevenue"?: number;
    "decemberMargin"?: number;
    "currency"?: CurrencyReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface SalesTeam {
    "id"?: number;
    "salesTeamIdentifier": string;
    "salesTeamDescription": string;
    "salesTeamLocation": SystemLocationReference;
    "inactiveFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface SalesTeamMember {
    "id"?: number;
    "member": MemberReference;
    "location"?: SystemLocationReference;
    "department"?: SystemDepartmentReference;
    "allowAccessFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface SalesTeamReference {
    "id"?: number;
    "identifier"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ScheduleColor {
    "id"?: number;

    /**
     * A startPercent (0 or higher) is required if endPercent has value
     */
    "startPercent"?: number;

    /**
     * A endPercent is required if startPercent has value
     */
    "endPercent"?: number;

    /**
     * Must be a valid Hexadecimal Color Code
     */
    "color": string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ScheduleDetail {
    "id"?: number;
    "scheduleEntry"?: ScheduleEntryReference;
    "dateStart"?: Date;
    "dateEnd"?: Date;
    "member"?: MemberReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ScheduleEntry {
    "id"?: number;
    "objectId"?: number;
    "name"?: string;

    /**
     * Activity schedule requires a member
     */
    "member"?: MemberReference;
    "where"?: ServiceLocationReference;
    "dateStart"?: Date;
    "dateEnd"?: Date;
    "reminder"?: ReminderReference;
    "status"?: ScheduleStatusReference;
    "type": ScheduleTypeReference;
    "span"?: ScheduleSpanReference;
    "doneFlag"?: boolean;
    "acknowledgedFlag"?: boolean;
    "ownerFlag"?: boolean;
    "allowScheduleConflictsFlag"?: boolean;
    "addMemberToProjectFlag"?: boolean;
    "projectRoleId"?: number;
    "mobileGuid"?: Guid;
    "closeDate"?: Date;
    "hours"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ScheduleEntryReference {
    "id"?: number;
    "description"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ScheduleReminderTime {
    "id"?: number;

    /**
     * Time is calculated in minutes
     */
    "time"?: number;
    "name"?: string;
    "defaultFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ScheduleSpanReference {
    "id"?: number;
    "identifier"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ScheduleStatus {
    "id"?: number;
    "name": string;
    "defaultFlag"?: boolean;
    "showAsTentativeFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ScheduleStatusReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ScheduleStopwatch {

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "agreement"?: AgreementReference;
    "billableOption"?: ScheduleStopwatch.BillableOptionEnum;
    "businessUnitId"?: number;
    "dateEntered"?: Date;
    "endTime"?: Date;
    "id"?: number;
    "internalNotes"?: string;
    "locationId"?: number;
    "member": MemberReference;
    "mobileGuid"?: Guid;
    "notes"?: string;
    "scheduleId": number;
    "scheduleMobileGuid"?: Guid;
    "startTime"?: Date;
    "status": ScheduleStopwatch.StatusEnum;
    "totalPauseTime"?: number;
    "workRole"?: WorkRoleReference;
    "workType"?: WorkTypeReference;
}

export namespace ScheduleStopwatch {

export type BillableOptionEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type StatusEnum = 'Reset' | 'Running' | 'Paused' | 'Stopped';
}
export interface ScheduleType {
    "id"?: number;
    "name": string;
    "identifier": string;
    "chargeCode"?: ChargeCodeReference;
    "where"?: ServiceLocationReference;
    "systemFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ScheduleTypeReference {
    "id"?: number;
    "identifier"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface SecurityRole {
    "id"?: number;
    "name": string;
    "adminFlag"?: boolean;
    "inactiveFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface SecurityRoleReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface SecurityRoleSetting {
    "id"?: number;
    "addLevel"?: SecurityRoleSetting.AddLevelEnum;
    "editLevel"?: SecurityRoleSetting.EditLevelEnum;
    "deleteLevel"?: SecurityRoleSetting.DeleteLevelEnum;
    "inquireLevel"?: SecurityRoleSetting.InquireLevelEnum;
    "moduleFunctionName"?: string;
    "moduleFunctionDescription"?: string;
    "myAllFlag"?: boolean;
    "moduleFunctionIdentifier"?: string;
    "reportFlag"?: boolean;
    "restrictFlag"?: boolean;
    "customFlag"?: boolean;
    "moduleDescription"?: string;
    "moduleIdentifier"?: string;
    "moduleName"?: string;
    "sortOrder"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace SecurityRoleSetting {

export type AddLevelEnum = 'All' | 'My' | 'None';

export type EditLevelEnum = 'All' | 'My' | 'None';

export type DeleteLevelEnum = 'All' | 'My' | 'None';

export type InquireLevelEnum = 'All' | 'My' | 'None';
}
export interface Service {
    "id"?: number;
    "srNotify": Service.SrNotifyEnum;
    "scheduleSpan": Service.ScheduleSpanEnum;
    "hideDelimiterFlag"?: boolean;
    "allowCCFlag"?: boolean;
    "headerColor"?: string;
    "memberColor"?: string;
    "contactColor"?: string;
    "unknownColor"?: string;
    "calendarSetup"?: CalendarSetupReference;
    "headerColorDisableFlag"?: boolean;
    "memberColorDisableFlag"?: boolean;
    "contactColorDisableFlag"?: boolean;
    "unknownColorDisableFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace Service {

export type SrNotifyEnum = 'None' | 'All' | 'NewRequestsOnly' | 'ClosedRequestsOnly' | 'NewAndClosedRequests';

export type ScheduleSpanEnum = 'Standard' | 'OfficeHours' | 'Overnight';
}
export interface ServiceCodeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ServiceEmailTemplate {
    "id"?: number;
    "type": ServiceEmailTemplate.TypeEnum;
    "serviceSurvey"?: ServiceSurveyReference;
    "serviceBoard"?: BoardReference;
    "useSenderFlag"?: boolean;

    /**
     * From fields (first name, last name, email address) are required if useSenderFlag is false.
     */
    "firstName"?: string;

    /**
     * From fields (first name, last name, email address) are required if useSenderFlag is false.
     */
    "lastName"?: string;

    /**
     * From fields (first name, last name, email address) are required if useSenderFlag is false.
     */
    "emailAddress"?: string;
    "subject"?: string;
    "body"?: string;
    "copySenderFlag"?: boolean;
    "tasksFlag"?: boolean;
    "resourceRecordsFlag"?: boolean;
    "externalContactNotifications"?: boolean;
    "internalContactNotifications"?: boolean;

    /**
     * serviceStatus is required if the email template type is "Specific".
     */
    "serviceStatus"?: ServiceStatusReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace ServiceEmailTemplate {

export type TypeEnum = 'New' | 'Closed' | 'Other' | 'Specific' | 'RMA' | 'Invoice' | 'SalesOrder' | 'PurchaseOrder';
}
export interface ServiceEmailTemplateReference {
    "id"?: number;
    "identifier"?: string;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ServiceItemReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ServiceLocation {
    "id"?: number;
    "name": string;
    "where": ServiceLocation.WhereEnum;
    "defaultFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace ServiceLocation {

export type WhereEnum = 'OnSite' | 'Remote' | 'InHouse';
}
export interface ServiceLocationReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ServiceManger {
    "count"?: number;
    "reAssignToMember"?: MemberReference;
}

export interface ServiceNote {
    "id"?: number;
    "ticketId"?: number;
    "text"?: string;
    "detailDescriptionFlag"?: boolean;
    "internalAnalysisFlag"?: boolean;
    "resolutionFlag"?: boolean;
    "member"?: MemberReference;
    "contact"?: ContactReference;
    "customerUpdatedFlag"?: boolean;
    "processNotifications"?: boolean;
    "dateCreated"?: string;
    "createdBy"?: string;
    "internalFlag"?: boolean;
    "externalFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ServiceSignoff {
    "id"?: number;
    "name": string;
    "defaultFlag"?: boolean;
    "visibleLogoFlag"?: boolean;
    "companyInfoFlag"?: boolean;
    "billingTermsFlag"?: boolean;
    "summaryFlag"?: boolean;
    "discussionFlag"?: boolean;

    /**
     * On add/post, if this is set to true but no value is set for task, task is defaulted to ServiceTasks.All
     */
    "taskFlag"?: boolean;

    /**
     * On add/post, if this is set but no value is set for taskFlag, taskFlag is set to true
     */
    "task"?: ServiceSignoff.TaskEnum;
    "configurationsFlag"?: boolean;
    "internalNotesFlag"?: boolean;
    "resolutionFlag"?: boolean;

    /**
     * On add/post, if any time related flag is set to true, this is also set to true
     */
    "timeFlag"?: boolean;
    "timeMemberFlag"?: boolean;
    "timeDateFlag"?: boolean;
    "timeStartEndFlag"?: boolean;
    "timeBillFlag"?: boolean;
    "timeHoursFlag"?: boolean;
    "timeRateFlag"?: boolean;
    "timeExtendedAmountFlag"?: boolean;
    "timeWorkTypeFlag"?: boolean;
    "timeAgreementFlag"?: boolean;
    "timeNotesFlag"?: boolean;
    "timeManualFlag"?: boolean;
    "timeManualEntry"?: number;
    "timeTaxFlag"?: boolean;

    /**
     * On add/post, if any expense related flag is set to true, this is also set to true
     */
    "expenseFlag"?: boolean;
    "expenseDateFlag"?: boolean;
    "expenseMemberFlag"?: boolean;
    "expenseTypeFlag"?: boolean;
    "expenseBillFlag"?: boolean;
    "expenseAmountFlag"?: boolean;
    "expenseAgreementFlag"?: boolean;
    "expenseNotesFlag"?: boolean;
    "expenseTaxFlag"?: boolean;
    "expenseManualFlag"?: boolean;
    "expenseManualEntry"?: number;

    /**
     * On add/post, if any product related flag is set to true, this is also set to true
     */
    "productFlag"?: boolean;
    "productDescriptionFlag"?: boolean;
    "productBillFlag"?: boolean;
    "productQuantityFlag"?: boolean;
    "productPriceFlag"?: boolean;
    "productExtendedAmountFlag"?: boolean;
    "productAgreementFlag"?: boolean;
    "productManualFlag"?: boolean;
    "productManualEntry"?: number;
    "productTaxFlag"?: boolean;
    "technicianSignoffFlag"?: boolean;

    /**
     * On add/post, if customerSignoffText.Length > 0, this is set to true
     */
    "customerSignoffTextFlag"?: boolean;
    "customerSignoffText"?: string;
    "customerSignoffFieldsFlag"?: boolean;

    /**
     * On add/post, if billingMethodsText.Length > 0, this is set to true
     */
    "billingMethodsTextFlag"?: boolean;
    "billingMethodsText"?: string;
    "creditCardFieldsFlag"?: boolean;
    "defaultFFFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace ServiceSignoff {

export type TaskEnum = 'All' | 'Closed' | 'Open';
}
export interface ServiceSignoffReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ServiceSourceReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ServiceStatusReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ServiceSubTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ServiceSurvey {
    "id"?: number;
    "name": string;
    "inactiveFlag"?: boolean;
    "headerIncludeLogoFlag"?: boolean;
    "headerText"?: string;
    "headerTextVisibleFlag"?: boolean;
    "footerText"?: string;
    "footerTextVisibleFlag"?: boolean;
    "thankYouText"?: string;
    "notifyWho"?: GenericIdIdentifierReference;
    "notifyWhoVisibleFlag"?: boolean;
    "notifyMember"?: MemberReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ServiceSurveyQuestion {
    "id"?: number;
    "sequenceNumber"?: number;
    "type": ServiceSurveyQuestion.TypeEnum;
    "question": string;
    "options"?: Array<ServiceSurveyQuestionOption>;
    "includeFlag"?: boolean;
    "requiredFlag"?: boolean;
    "noAnswerPoints"?: number;
    "surveyId"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace ServiceSurveyQuestion {

export type TypeEnum = 'OpenEnded' | 'Selection';
}
export interface ServiceSurveyQuestionOption {
    "includeFlag"?: boolean;
    "caption": string;
    "points"?: number;
}

export interface ServiceSurveyReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ServiceTeam {
    "id"?: number;
    "name"?: string;
    "leader"?: MemberReference;
    "location"?: SystemLocationReference;
    "department"?: SystemDepartmentReference;
    "deleteNotifyFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "count"?: number;
    "reAssignToMember"?: MemberReference;
}

export interface ServiceTeamReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

/**
 * The Service (Ticket) Templates on which the Member is the assignedTo resource
 */
export interface ServiceTemplate {
    "id"?: number;
    "name": string;
    "board": BoardReference;
    "type"?: ServiceTypeReference;
    "item"?: ServiceItemReference;
    "subtype"?: ServiceSubTypeReference;
    "serviceLocation"?: ServiceLocationReference;
    "status": ServiceStatusReference;
    "source": ServiceSourceReference;
    "priority": PriorityReference;
    "team": ServiceTeamReference;
    "company"?: CompanyReference;
    "contact"?: ContactReference;
    "site"?: SiteReference;
    "assignedNotifyFlag"?: boolean;
    "location": SystemLocationReference;
    "department": SystemDepartmentReference;
    "summary": string;
    "problem"?: string;
    "hoursBudget"?: number;
    "internalAnalysis"?: string;
    "timeBillableFlag"?: boolean;
    "expenseBillableFlag"?: boolean;
    "purchaseOrderNumber"?: string;
    "reference"?: string;
    "billCompleteFlag"?: boolean;
    "billServiceSeparatelyFlag"?: boolean;
    "billingAmount"?: number;
    "billUnapprovedTimeAndExpensesFlag"?: boolean;
    "overrideFlag"?: boolean;
    "timeInvoiceFlag"?: boolean;
    "expenseInvoiceFlag"?: boolean;
    "productInvoiceFlag"?: boolean;
    "agreement"?: AgreementReference;
    "billingMethod": ServiceTemplate.BillingMethodEnum;
    "severity": ServiceTemplate.SeverityEnum;
    "impact": ServiceTemplate.ImpactEnum;
    "assignedBy": MemberReference;
    "scheduleDaysBefore"?: number;
    "serviceDaysBefore"?: number;
    "attachScheduleToNewServiceFlag"?: boolean;
    "templateFlag"?: boolean;
    "emailContactFlag"?: boolean;
    "emailResourceFlag"?: boolean;
    "emailCCFlag"?: boolean;
    "emailCC"?: string;
    "restrictDownpaymentFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "count"?: number;
    "reAssignToMember"?: MemberReference;
}

export namespace ServiceTemplate {

export type BillingMethodEnum = 'ActualRates' | 'FixedFee' | 'NotToExceed' | 'OverrideRate';

export type SeverityEnum = 'Low' | 'Medium' | 'High';

export type ImpactEnum = 'Low' | 'Medium' | 'High';
}
/**
 * Required when notifyType is set to: "Create a Service Ticket"
 */
export interface ServiceTemplateReference {
    "id"?: number;
    "name"?: string;
    "summary"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ServiceTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface SetupScreen {
    "id"?: number;
    "category"?: string;
    "name"?: string;
    "description"?: string;
    "moduleDescription"?: string;
    "moduleIdentifier"?: string;
    "moduleName"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Severity {
    "id"?: number;
    "name"?: string;
    "description": string;
    "defaultFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ShipmentMethod {
    "id"?: number;
    "name": string;
    "defaultFlag"?: boolean;
    "trackingUrl"?: string;
    "shippingType"?: ShipmentMethod.ShippingTypeEnum;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace ShipmentMethod {

export type ShippingTypeEnum = 'None' | 'FedExTwoDay' | 'FedExPriority' | 'FedExGround' | 'UpsNextDay' | 'UpsSecondDay' | 'UpsGround' | 'CourierService' | 'UspsPriority' | 'UspsExpress';
}
export interface ShipmentMethodReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface SicCodeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface SiteReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Skill {
    "id"?: number;
    "name": string;
    "category": SkillCategoryReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface SkillCategory {
    "id"?: number;
    "name": string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface SkillCategoryReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface SkillReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Source {
    "id"?: number;
    "name": string;
    "defaultFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "enteredBy"?: string;
    "dateEntered"?: Date;
}

export interface State {
    "id"?: number;
    "identifier": string;
    "name": string;
    "country"?: CountryReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface StateReference {
    "id"?: number;
    "identifier"?: string;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface StatusExternalIntegrationReference {
    "id"?: number;
    "identifier": string;
    "name": string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface StatusWorkflow {
    "count"?: number;
    "reAssignToMember"?: MemberReference;
}

export interface StructureReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface SubCategory {
    "id"?: number;
    "name": string;
    "inactiveFlag"?: boolean;
    "integrationXref"?: string;
    "category": ProductCategoryReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface SuccessResponse {
    "success"?: boolean;
    "message"?: string;
}

export interface Survey {
    "id"?: number;
    "name": string;
    "instructions"?: string;
    "inactiveFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface SurveyOption {
    "id"?: number;
    "caption": string;
    "points": number;
    "visibleflag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface SurveyQuestion {
    "id"?: number;
    "survey"?: SurveyReference;
    "fieldType": SurveyQuestion.FieldTypeEnum;
    "entryType": SurveyQuestion.EntryTypeEnum;
    "sequenceNumber": number;
    "question": string;
    "numberOfDecimals"?: number;
    "requiredFlag"?: boolean;
    "inactiveFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace SurveyQuestion {

export type FieldTypeEnum = 'Button' | 'Checkbox' | 'Currency' | 'Date' | 'Hyperlink' | 'IPAddress' | 'Number' | 'Password' | 'Percent' | 'Text' | 'TextArea';

export type EntryTypeEnum = 'EntryField' | 'List' | 'Option';
}
export interface SurveyQuestionReference {
    "id"?: number;
    "question"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface SurveyQuestionValue {
    "id"?: number;
    "survey"?: SurveyReference;
    "question"?: SurveyQuestionReference;
    "value": string;
    "defaultFlag"?: boolean;
    "pointValue"?: number;
    "inactiveFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface SurveyReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface SurveyResult {
    "id"?: number;
    "ticketId": number;
    "emailAddress"?: string;
    "footerResponse"?: string;
    "contactMeFlag"?: boolean;
    "contact"?: ContactReference;
    "results"?: Array<SurveyResultDetail>;
    "totalPoints"?: number;
    "company"?: CompanyReference;
    "surveyId"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface SurveyResultDetail {
    "questionId": number;

    /**
     * If question type is Selection, this should be the option array index
     */
    "answer"?: string;
}

export interface SystemDepartmentReference {
    "id"?: number;
    "identifier"?: string;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface SystemLocationReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface SystemMenuEntryReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Task {
    "id"?: number;
    "ticketId"?: number;
    "notes"?: string;
    "closedFlag"?: boolean;
    "priority"?: number;
    "schedule"?: ScheduleEntryReference;
    "code"?: ServiceCodeReference;
    "resolution"?: string;
    "childScheduleAction"?: Task.ChildScheduleActionEnum;
    "childTicketId"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace Task {

export type ChildScheduleActionEnum = 'Transfer' | 'Delete' | 'Done';
}
export interface TaxCode {
    "id"?: number;
    "identifier": string;
    "description": string;
    "invoiceCaption": string;
    "country"?: CountryReference;
    "effectiveDate": Date;
    "defaultFlag"?: boolean;
    "displayOnInvoiceFlag"?: boolean;
    "canadaCalculateGSTFlag"?: boolean;
    "cancelDate"?: Date;
    "levelOneRate"?: number;
    "levelOneRateType"?: TaxCode.LevelOneRateTypeEnum;
    "levelOneTaxableMax"?: number;
    "levelOneCaption"?: string;
    "levelOneTaxCodeXref"?: string;
    "levelOneAgencyXref"?: string;
    "levelOneServicesFlag"?: boolean;
    "levelOneExpensesFlag"?: boolean;
    "levelOneProductsFlag"?: boolean;
    "levelOneApplySingleUnitFlag"?: boolean;
    "levelOneApplySingleUnitMin"?: number;
    "levelOneApplySingleUnitMax"?: number;
    "levelTwoRate"?: number;
    "levelTwoRateType"?: TaxCode.LevelTwoRateTypeEnum;
    "levelTwoTaxableMax"?: number;
    "levelTwoCaption"?: string;
    "levelTwoTaxCodeXref"?: string;
    "levelTwoAgencyXref"?: string;
    "levelTwoServicesFlag"?: boolean;
    "levelTwoExpensesFlag"?: boolean;
    "levelTwoProductsFlag"?: boolean;
    "levelTwoApplySingleUnitFlag"?: boolean;
    "levelTwoApplySingleUnitMin"?: number;
    "levelTwoApplySingleUnitMax"?: number;
    "levelThreeRate"?: number;
    "levelThreeRateType"?: TaxCode.LevelThreeRateTypeEnum;
    "levelThreeTaxableMax"?: number;
    "levelThreeCaption"?: string;
    "levelThreeTaxCodeXref"?: string;
    "levelThreeAgencyXref"?: string;
    "levelThreeServicesFlag"?: boolean;
    "levelThreeExpensesFlag"?: boolean;
    "levelThreeProductsFlag"?: boolean;
    "levelThreeApplySingleUnitFlag"?: boolean;
    "levelThreeApplySingleUnitMin"?: number;
    "levelThreeApplySingleUnitMax"?: number;
    "levelFourRate"?: number;
    "levelFourRateType"?: TaxCode.LevelFourRateTypeEnum;
    "levelFourTaxableMax"?: number;
    "levelFourCaption"?: string;
    "levelFourTaxCodeXref"?: string;
    "levelFourAgencyXref"?: string;
    "levelFourServicesFlag"?: boolean;
    "levelFourExpensesFlag"?: boolean;
    "levelFourProductsFlag"?: boolean;
    "levelFourApplySingleUnitFlag"?: boolean;
    "levelFourApplySingleUnitMin"?: number;
    "levelFourApplySingleUnitMax"?: number;
    "levelFiveRate"?: number;
    "levelFiveRateType"?: TaxCode.LevelFiveRateTypeEnum;
    "levelFiveTaxableMax"?: number;
    "levelFiveCaption"?: string;
    "levelFiveTaxCodeXref"?: string;
    "levelFiveAgencyXref"?: string;
    "levelFiveServicesFlag"?: boolean;
    "levelFiveExpensesFlag"?: boolean;
    "levelFiveProductsFlag"?: boolean;
    "levelFiveApplySingleUnitFlag"?: boolean;
    "levelFiveApplySingleUnitMin"?: number;
    "levelFiveApplySingleUnitMax"?: number;
    "workRoleIds"?: Array<number>;
    "addAllWorkRoles"?: boolean;
    "removeAllWorkRoles"?: boolean;
    "expenseTypeIds"?: Array<number>;
    "addAllExpenseTypes"?: boolean;
    "removeAllExpenseTypes"?: boolean;
    "productTypeIds"?: Array<number>;
    "addAllProductTypes"?: boolean;
    "removeAllProductTypes"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace TaxCode {

export type LevelOneRateTypeEnum = 'Amount' | 'Percent';

export type LevelTwoRateTypeEnum = 'Amount' | 'Percent';

export type LevelThreeRateTypeEnum = 'Amount' | 'Percent';

export type LevelFourRateTypeEnum = 'Amount' | 'Percent';

export type LevelFiveRateTypeEnum = 'Amount' | 'Percent';
}
/**
 * New companies will be created with the default tax code unless otherwise specified.
 */
export interface TaxCodeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface TaxCodeXRef {
    "id"?: number;
    "description": string;
    "defaultFlag"?: boolean;
    "levelOne"?: TaxCodeXRef.LevelOneEnum;
    "levelTwo"?: TaxCodeXRef.LevelTwoEnum;
    "levelThree"?: TaxCodeXRef.LevelThreeEnum;
    "levelFour"?: TaxCodeXRef.LevelFourEnum;
    "levelFive"?: TaxCodeXRef.LevelFiveEnum;
    "taxCode"?: TaxCodeReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace TaxCodeXRef {

export type LevelOneEnum = 'NonTaxable' | 'Taxable';

export type LevelTwoEnum = 'NonTaxable' | 'Taxable';

export type LevelThreeEnum = 'NonTaxable' | 'Taxable';

export type LevelFourEnum = 'NonTaxable' | 'Taxable';

export type LevelFiveEnum = 'NonTaxable' | 'Taxable';
}
export interface TaxIntegration {
    "taxIntegrationType"?: TaxIntegration.TaxIntegrationTypeEnum;
    "id"?: number;
    "accountNumber"?: string;
    "licenseKey"?: string;
    "serviceUrl"?: string;
    "companyCode"?: string;
    "timeTaxCode"?: string;
    "expenseTaxCode"?: string;
    "productTaxCode"?: string;
    "invoiceAmountTaxCode"?: string;
    "enabledFlag"?: boolean;
    "commitTransactionsFlag"?: boolean;
    "salesInvoiceFlag"?: boolean;
    "freightTaxCode"?: string;
    "accountingIntegrationFlag"?: boolean;
    "taxLineFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace TaxIntegration {

export type TaxIntegrationTypeEnum = 'Avalara';
}
export interface Team {
    "id"?: number;
    "type": Team.TypeEnum;
    "member"?: MemberReference;
    "salesTeam"?: SalesTeamReference;
    "commissionPercent"?: number;
    "referralFlag"?: boolean;
    "opportunityId"?: number;
    "responsibleFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace Team {

export type TypeEnum = 'Individual' | 'Team';
}
export interface TeamMember {
    "id"?: number;
    "board"?: BoardReference;
    "team": ServiceTeamReference;
    "member": MemberReference;
    "teamLeaderFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface TeamRole {
    "id"?: number;
    "name": string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface TeamRoleReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Ticket {
    "id"?: number;
    "summary": string;
    "recordType"?: Ticket.RecordTypeEnum;
    "board"?: BoardReference;
    "status"?: ServiceStatusReference;
    "project"?: ProjectReference;
    "phase"?: ProjectPhaseReference;
    "wbsCode"?: string;
    "company": CompanyReference;
    "site"?: SiteReference;
    "siteName"?: string;
    "addressLine1"?: string;
    "addressLine2"?: string;
    "city"?: string;
    "stateIdentifier"?: string;
    "zip"?: string;
    "country"?: CountryReference;
    "contact"?: ContactReference;
    "contactName"?: string;
    "contactPhoneNumber"?: string;
    "contactPhoneExtension"?: string;
    "contactEmailAddress"?: string;
    "type"?: ServiceTypeReference;
    "subType"?: ServiceSubTypeReference;
    "item"?: ServiceItemReference;
    "team"?: ServiceTeamReference;
    "owner"?: MemberReference;
    "priority"?: PriorityReference;
    "serviceLocation"?: ServiceLocationReference;
    "source"?: ServiceSourceReference;
    "requiredDate"?: Date;
    "budgetHours"?: number;
    "opportunity"?: OpportunityReference;
    "agreement"?: AgreementReference;
    "severity"?: Ticket.SeverityEnum;
    "impact"?: Ticket.ImpactEnum;
    "externalXRef"?: string;
    "poNumber"?: string;
    "knowledgeBaseCategoryId"?: number;
    "knowledgeBaseSubCategoryId"?: number;
    "allowAllClientsPortalView"?: boolean;
    "customerUpdatedFlag"?: boolean;
    "automaticEmailContactFlag"?: boolean;
    "automaticEmailResourceFlag"?: boolean;
    "automaticEmailCcFlag"?: boolean;
    "automaticEmailCc"?: string;

    /**
     * Only available for POST, will not be returned in the response
     */
    "initialDescription"?: string;

    /**
     * Only available for POST, will not be returned in the response
     */
    "initialInternalAnalysis"?: string;

    /**
     * Only available for POST, will not be returned in the response
     */
    "initialResolution"?: string;
    "contactEmailLookup"?: string;

    /**
     * Can be set to false to skip notification processing when adding or updating a ticket (Defaults to True)
     */
    "processNotifications"?: boolean;
    "skipCallback"?: boolean;
    "closedDate"?: string;
    "closedBy"?: string;
    "closedFlag"?: boolean;
    "dateEntered"?: string;
    "enteredBy"?: string;
    "actualHours"?: number;
    "approved"?: boolean;
    "subBillingMethod"?: Ticket.SubBillingMethodEnum;
    "subBillingAmount"?: number;
    "subDateAccepted"?: string;
    "dateResolved"?: string;
    "dateResplan"?: string;
    "dateResponded"?: string;
    "resolveMinutes"?: number;
    "resPlanMinutes"?: number;
    "respondMinutes"?: number;
    "isInSla"?: boolean;
    "knowledgeBaseLinkId"?: number;
    "resources"?: string;
    "parentTicketId"?: number;
    "hasChildTicket"?: boolean;
    "knowledgeBaseLinkType"?: Ticket.KnowledgeBaseLinkTypeEnum;
    "billTime"?: Ticket.BillTimeEnum;
    "billExpenses"?: Ticket.BillExpensesEnum;
    "billProducts"?: Ticket.BillProductsEnum;
    "predecessorType"?: Ticket.PredecessorTypeEnum;
    "predecessorId"?: number;
    "predecessorClosedFlag"?: boolean;
    "lagDays"?: number;
    "lagNonworkingDaysFlag"?: boolean;
    "estimatedStartDate"?: Date;
    "duration"?: number;
    "locationId"?: number;
    "businessUnitId"?: number;
    "mobileGuid"?: Guid;
    "sla"?: SLAReference;
    "currency"?: CurrencyReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "customFields"?: Array<CustomFieldValue>;
}

export namespace Ticket {

export type RecordTypeEnum = 'ServiceTicket' | 'ProjectTicket' | 'ProjectIssue';

export type SeverityEnum = 'Low' | 'Medium' | 'High';

export type ImpactEnum = 'Low' | 'Medium' | 'High';

export type SubBillingMethodEnum = 'ActualRates' | 'FixedFee' | 'NotToExceed' | 'OverrideRate';

export type KnowledgeBaseLinkTypeEnum = 'ServiceTicket' | 'ProjectTicket' | 'ProjectIssue' | 'KnowledgeBaseArticle' | 'Time' | 'Activity';

export type BillTimeEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillExpensesEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillProductsEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type PredecessorTypeEnum = 'Ticket' | 'Phase';
}
export interface TicketMerge {
    "mergeTicketIds": Array<number>;
    "status": ServiceStatusReference;
}

export interface TicketReference {
    "id"?: number;
    "summary"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface TicketStopwatch {

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "agreement"?: AgreementReference;
    "billableOption"?: TicketStopwatch.BillableOptionEnum;
    "businessUnitId"?: number;
    "dateEntered"?: Date;
    "endTime"?: Date;
    "id"?: number;
    "internalNotes"?: string;
    "locationId"?: number;
    "member": MemberReference;
    "mobileGuid"?: Guid;
    "notes"?: string;
    "serviceStatus"?: ServiceStatusReference;
    "startTime"?: Date;
    "status": TicketStopwatch.StatusEnum;
    "ticket": TicketReference;
    "ticketMobileGuid"?: Guid;
    "totalPauseTime"?: number;
    "workRole"?: WorkRoleReference;
    "workType"?: WorkTypeReference;
    "showNotesInDiscussionFlag"?: boolean;
    "showNotesInInternalFlag"?: boolean;
    "showNotesInResolutionFlag"?: boolean;
    "emailNotesToContactFlag"?: boolean;
    "emailNotesToResourcesFlag"?: boolean;
}

export namespace TicketStopwatch {

export type BillableOptionEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type StatusEnum = 'Reset' | 'Running' | 'Paused' | 'Stopped';
}
export interface TicketSync {
    "id"?: number;
    "name": string;
    "vendorType": TicketSync.VendorTypeEnum;
    "integratorLogin": IntegratorLoginReference;
    "company": CompanyReference;
    "url": string;
    "userName"?: string;
    "password"?: string;
    "psg"?: string;
    "problemDescription"?: boolean;
    "internalAnalysis"?: boolean;
    "resolution"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace TicketSync {

export type VendorTypeEnum = 'Zenith' | 'Kaseya';
}
export interface TimeAccrual {
    "id"?: number;
    "location"?: SystemLocationReference;

    /**
     * if vacationFlag is set to false, system will clear out or ingore the values of vacationAvailableType, vacationCarryoverAllowedFlag, vacationCarryoverLimit
     */
    "vacationFlag"?: boolean;
    "vacationAvailableType"?: TimeAccrual.VacationAvailableTypeEnum;
    "vacationCarryoverAllowedFlag"?: boolean;
    "vacationCarryoverLimit"?: number;

    /**
     * if sickFlag is set to false, system will clear out or ignore the values of sickAvailableType, sickCarryoverAllowedFlag, sickCarryoverLimit
     */
    "sickFlag"?: boolean;
    "sickAvailableType"?: TimeAccrual.SickAvailableTypeEnum;
    "sickCarryoverAllowedFlag"?: boolean;
    "sickCarryoverLimit"?: number;

    /**
     * if ptoFlag is set to false, system will clear out or ignore the values of ptoAvailableType, ptoCarryoverAllowedFlag, ptoCarryoverLimit
     */
    "ptoFlag"?: boolean;
    "ptoAvailableType"?: TimeAccrual.PtoAvailableTypeEnum;
    "ptoCarryoverAllowedFlag"?: boolean;
    "ptoCarryoverLimit"?: number;

    /**
     * if holidayFlag is set to false, system will clear out or ignore the values of holidayAvailableType, holidayCarryoverAllowedFlag, holidayCarryoverLimit
     */
    "holidayFlag"?: boolean;
    "holidayAvailableType"?: TimeAccrual.HolidayAvailableTypeEnum;
    "holidayCarryoverAllowedFlag"?: boolean;
    "holidayCarryoverLimit"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace TimeAccrual {

export type VacationAvailableTypeEnum = 'AnniversaryYear' | 'CalendarYear';

export type SickAvailableTypeEnum = 'AnniversaryYear' | 'CalendarYear';

export type PtoAvailableTypeEnum = 'AnniversaryYear' | 'CalendarYear';

export type HolidayAvailableTypeEnum = 'AnniversaryYear' | 'CalendarYear';
}
export interface TimeAccrualDetail {
    "id"?: number;

    /**
     * Available types are: Holiday, PTO, Sick and Vacation.
     */
    "accrualType": TimeAccrualDetail.AccrualTypeEnum;
    "startYear": number;
    "endYear": number;
    "hours": number;
    "timeAccrual"?: TimeAccrualReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace TimeAccrualDetail {

export type AccrualTypeEnum = 'Holiday' | 'PTO' | 'Sick' | 'Vacation';
}
export interface TimeAccrualReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface TimeEntry {
    "id"?: number;

    /**
     * If chargeToId is not specified, we asume you enter time against the company specified
     */
    "company"?: CompanyReference;

    /**
     * If chargeToId is not specified, we asume you enter time against the company specified
     */
    "chargeToId"?: number;

    /**
     * If chargeToId is not specified, we asume you enter time against the company specified
     */
    "chargeToType"?: TimeEntry.ChargeToTypeEnum;
    "member"?: MemberReference;
    "locationId"?: number;
    "businessUnitId"?: number;
    "workType"?: WorkTypeReference;
    "workRole"?: WorkRoleReference;
    "agreement"?: AgreementReference;
    "timeStart": Date;
    "timeEnd"?: Date;
    "hoursDeduct"?: number;
    "actualHours"?: number;
    "billableOption"?: TimeEntry.BillableOptionEnum;
    "notes"?: string;
    "internalNotes"?: string;
    "addToDetailDescriptionFlag"?: boolean;
    "addToInternalAnalysisFlag"?: boolean;
    "addToResolutionFlag"?: boolean;

    /**
     * This is an action flag. To update this value use the /service/tickets endpoint automaticEmailResourceFlag field
     */
    "emailResourceFlag"?: boolean;

    /**
     * This is an action flag. To update this value use the /service/tickets endpoint automaticEmailContactFlag field
     */
    "emailContactFlag"?: boolean;

    /**
     * This is an action flag. To update this value use the /service/tickets endpoint automaticEmailCcFlag field
     */
    "emailCcFlag"?: boolean;

    /**
     * To update this value use the /service/tickets endpoint automaticEmailCc field
     */
    "emailCc"?: string;
    "hoursBilled"?: number;
    "enteredBy"?: string;
    "dateEntered"?: Date;
    "invoice"?: InvoiceReference;
    "mobileGuid"?: Guid;

    /**
     * This field may only be Updated, it is defaulted on Create
     */
    "hourlyRate"?: number;
    "timeSheet"?: TimeSheetReference;
    "status"?: TimeEntry.StatusEnum;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "customFields"?: Array<CustomFieldValue>;
}

export namespace TimeEntry {

export type ChargeToTypeEnum = 'ServiceTicket' | 'ProjectTicket' | 'ChargeCode' | 'Activity';

export type BillableOptionEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type StatusEnum = 'Open' | 'Rejected' | 'PendingApproval' | 'ErrorsCorrected' | 'PendingProjectApproval' | 'ApprovedByTierOne' | 'RejectBySecondTier' | 'ApprovedByTierTwo' | 'ReadyToBill' | 'Billed' | 'WrittenOff' | 'BilledAgreement';
}
export interface TimeEntryReference {
    "id"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface TimeExpense {
    "id"?: number;
    "tier1ApprovalFlag"?: boolean;
    "tier2ApprovalFlag"?: boolean;
    "disableTimeEntryFlag"?: boolean;
    "requireTimeNoteFlag"?: boolean;
    "requireExpenseNoteFlag"?: boolean;
    "roundingFactor"?: number;
    "invoiceStart"?: number;
    "internalCompany": CompanyReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface TimePeriod {
    "id"?: number;
    "timePeriodSetup": TimePeriodSetupReference;
    "period"?: number;
    "startDate"?: string;
    "endDate"?: string;
    "deadlineDate"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface TimePeriodSetup {
    "id"?: number;
    "periodApplyTo": TimePeriodSetup.PeriodApplyToEnum;
    "year": number;
    "numberFuturePeriods": number;
    "type": TimePeriodSetup.TypeEnum;
    "description"?: string;
    "firstPeriodEndDate": string;

    /**
     * Only needed when type is monthly
     */
    "monthlyPeriodEnds"?: number;

    /**
     * Only needed when type is semi-monthly
     */
    "semiMonthlyFirstPeriod"?: number;

    /**
     * Only needed when type is semi-monthly
     */
    "semiMonthlySecondPeriod"?: number;
    "semiMonthlyLastDayFlag"?: boolean;

    /**
     * Only needed when type is monthly
     */
    "lastDayFlag"?: boolean;
    "daysPastEndDate": number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace TimePeriodSetup {

export type PeriodApplyToEnum = 'Time' | 'Expense' | 'Both';

export type TypeEnum = 'Weekly' | 'BiWeekly' | 'SemiMonthly' | 'Monthly';
}
export interface TimePeriodSetupDefaults {
}

export interface TimePeriodSetupReference {
    "id"?: number;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface TimeSheet {
    "id"?: number;
    "member"?: MemberReference;
    "year"?: number;
    "period"?: number;
    "dateStart"?: Date;
    "dateEnd"?: Date;
    "status"?: TimeSheet.StatusEnum;
    "hours"?: number;
    "deadline"?: Date;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace TimeSheet {

export type StatusEnum = 'Open' | 'Rejected' | 'PendingApproval' | 'ErrorsCorrected' | 'PendingProjectApproval' | 'ApprovedByTierOne' | 'RejectBySecondTier' | 'ApprovedByTierTwo' | 'ReadyToBill' | 'Billed' | 'WrittenOff' | 'BilledAgreement';
}
export interface TimeSheetReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface TimeZone {
    "id"?: number;
    "name"?: string;

    /**
     * The hours offset (+/-)
     */
    "offset"?: number;
    "startDate"?: Date;
    "endDate"?: Date;
    "daylightSavingsFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

/**
 * The system level time zone to which this setup is associated
 */
export interface TimeZoneReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface TimeZoneSetup {
    "id"?: number;
    "name": string;

    /**
     * The system level time zone to which this setup is associated
     */
    "timeZone": TimeZoneReference;

    /**
     * The hours offset from UTC (+/-)
     */
    "offset"?: number;

    /**
     * Identifies the default system time zone setup
     */
    "defaultFlag"?: boolean;
    "daylightSavingsFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

/**
 * The specified system time zone for the Company
 */
export interface TimeZoneSetupReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface TodayPageCategory {
    "id"?: number;
    "name": string;
    "sortOrder": number;
    "location"?: SystemLocationReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Token {
    "publicKey"?: string;
    "privateKey"?: string;
    "expiration"?: string;
}

export interface Track {
    "id"?: number;
    "trackId"?: number;
    "name": string;
    "startDate"?: string;
    "endDate"?: string;
    "actionTaken"?: number;
    "actionRemaining"?: number;
    "startedBy"?: string;
    "company"?: CompanyReference;
    "contact"?: ContactReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
    "inactiveFlag"?: boolean;
    "notifyActionIds"?: Array<number>;
}

export interface TrackAction {
    "id"?: number;
    "notifyType": TrackAction.NotifyTypeEnum;
    "serviceTemplate"?: ServiceTemplateReference;
    "specificMemberTo"?: MemberReference;
    "emailRecipient"?: string;
    "specificMemberFrom"?: MemberReference;
    "emailFrom"?: string;
    "subject"?: string;
    "notes"?: string;
    "activityType"?: ActivityTypeReference;
    "activityStatus"?: ActivityStatusReference;
    "companyStatus"?: CompanyStatusReference;
    "track"?: TrackReference;
    "group"?: GroupReference;
    "ccContact"?: ContactReference;
    "bccContact"?: ContactReference;
    "daysToExecute"?: number;
    "notifyWho"?: NotificationRecipientReference;
    "notifyFrom"?: NotificationRecipientReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace TrackAction {

export type NotifyTypeEnum = 'AddToGroup' | 'ChangeCompanyStatus' | 'CreateActivity' | 'CreateServiceTicket' | 'SendEmail';
}
/**
 * Required when notifyType is set to: "Attach Track"
 */
export interface TrackReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Type {
    "id"?: number;
    "name": string;
    "inactiveFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface UnitOfMeasure {
    "id"?: number;
    "name": string;
    "inactiveFlag"?: boolean;
    "defaultFlag"?: boolean;
    "uomScheduleXref"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface UnitOfMeasureReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface UnpostedExpense {
    "id"?: number;
    "locationId"?: number;
    "departmentId"?: number;
    "company"?: CompanyReference;
    "accountNumber"?: string;
    "creditAccount"?: string;
    "expenseDetailId"?: number;
    "expenseType"?: ExpenseTypeReference;
    "classification"?: UnpostedExpense.ClassificationEnum;
    "glType"?: UnpostedExpense.GlTypeEnum;
    "member"?: MemberReference;
    "dateExpense"?: Date;
    "chargeCode"?: ChargeCodeReference;
    "chargeDescription"?: string;
    "inPolicy"?: boolean;
    "paymentMethod"?: PaymentMethodReference;
    "currency"?: CurrencyReference;
    "total"?: number;
    "billableAmount"?: number;
    "nonBillableAmount"?: number;
    "agreement"?: AgreementReference;
    "agreementAmountCovered"?: number;
    "ticket"?: TicketReference;
    "project"?: ProjectReference;
    "projectPhase"?: ProjectPhaseReference;
    "taxCode"?: TaxCodeReference;

    /**
     * Used to determine if Avalara tax is enabled.
     */
    "avalaraTaxFlag"?: boolean;
    "itemTaxableFlag"?: boolean;
    "salesTaxAmount"?: number;

    /**
     * Set to true if transaction is taxable at the state level.
     */
    "stateTaxFlag"?: boolean;
    "stateTaxXref"?: string;
    "stateTaxAmount"?: number;

    /**
     * Set to true if transaction is taxable at the county level.
     */
    "countyTaxFlag"?: boolean;
    "countyTaxXref"?: string;
    "countyTaxAmount"?: number;

    /**
     * Set to true if transaction is taxable at the city level.
     */
    "cityTaxFlag"?: boolean;
    "cityTaxXref"?: string;
    "cityTaxAmount"?: number;

    /**
     * Set to true if transaction is taxable at the country level.
     */
    "countryTaxFlag"?: boolean;
    "countryTaxXref"?: string;
    "countryTaxAmount"?: number;

    /**
     * Set to true if transaction is taxable at the composite level.
     */
    "compositeTaxFlag"?: boolean;
    "compositeTaxXref"?: string;
    "compositeTaxAmount"?: number;
    "dateClosed"?: Date;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace UnpostedExpense {

export type ClassificationEnum = 'NonReimbursable' | 'Reimbursable' | 'Personal';

export type GlTypeEnum = 'AP' | 'AR' | 'EE' | 'EI' | 'EO' | 'IA' | 'IT' | 'P' | 'PF' | 'R' | 'RA' | 'RD' | 'RE' | 'RP' | 'ST' | 'SD' | 'ET' | 'RM' | 'FT' | 'PT';
}
export interface UnpostedInvoice {
    "id"?: number;
    "billingLogId"?: number;
    "locationId"?: number;
    "departmentId"?: number;
    "company"?: CompanyReference;
    "accountNumber"?: string;
    "billToCompany"?: CompanyReference;
    "billToSite"?: SiteReference;
    "shipToCompany"?: CompanyReference;
    "shipToSite"?: SiteReference;
    "invoiceNumber"?: string;
    "invoiceDate"?: Date;
    "invoiceType"?: UnpostedInvoice.InvoiceTypeEnum;
    "description"?: string;
    "billingTerms"?: BillingTermsReference;
    "dueDays"?: string;
    "dueDate"?: Date;
    "currency"?: CurrencyReference;
    "subTotal"?: number;
    "total"?: number;
    "invoiceTaxableFlag"?: boolean;
    "taxCode"?: TaxCodeReference;

    /**
     * Used to determine if Avalara tax is enabled.
     */
    "avalaraTaxFlag"?: boolean;
    "itemTaxableFlag"?: boolean;
    "salesTaxAmount"?: number;

    /**
     * Set to true if transaction is taxable at the state level.
     */
    "stateTaxFlag"?: boolean;
    "stateTaxXref"?: string;
    "stateTaxAmount"?: number;

    /**
     * Set to true if transaction is taxable at the county level.
     */
    "countyTaxFlag"?: boolean;
    "countyTaxXref"?: string;
    "countyTaxAmount"?: number;

    /**
     * Set to true if transaction is taxable at the city level.
     */
    "cityTaxFlag"?: boolean;
    "cityTaxXref"?: string;
    "cityTaxAmount"?: number;

    /**
     * Set to true if transaction is taxable at the country level.
     */
    "countryTaxFlag"?: boolean;
    "countryTaxXref"?: string;
    "countryTaxAmount"?: number;

    /**
     * Set to true if transaction is taxable at the composite level.
     */
    "compositeTaxFlag"?: boolean;
    "compositeTaxXref"?: string;
    "compositeTaxAmount"?: number;
    "createdBy"?: string;
    "dateClosed"?: Date;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace UnpostedInvoice {

export type InvoiceTypeEnum = 'Agreement' | 'CreditMemo' | 'DownPayment' | 'Miscellaneous' | 'Progress' | 'Standard';
}
export interface UnpostedProcurement {
    "id"?: number;
    "description"?: string;
    "locationId"?: number;
    "departmentId"?: number;
    "procurementType"?: UnpostedProcurement.ProcurementTypeEnum;
    "purchaseOrder"?: PurchaseOrderReference;
    "purchaseDate"?: Date;
    "trackingNumber"?: string;
    "billingTerms"?: BillingTermsReference;
    "currency"?: CurrencyReference;
    "total"?: number;
    "taxCode"?: TaxCodeReference;

    /**
     * Used to determine if Avalara tax is enabled.
     */
    "avalaraTaxFlag"?: boolean;
    "itemTaxableFlag"?: boolean;
    "purchaseOrderTaxableFlag"?: boolean;

    /**
     * Set to true if transaction is taxable at the state level.
     */
    "stateTaxFlag"?: boolean;
    "stateTaxXref"?: string;
    "stateTaxAmount"?: number;

    /**
     * Set to true if transaction is taxable at the county level.
     */
    "countyTaxFlag"?: boolean;
    "countyTaxXref"?: string;
    "countyTaxAmount"?: number;

    /**
     * Set to true if transaction is taxable at the city level.
     */
    "cityTaxFlag"?: boolean;
    "cityTaxXref"?: string;
    "cityTaxAmount"?: number;

    /**
     * Set to true if transaction is taxable at the country level.
     */
    "countryTaxFlag"?: boolean;
    "countryTaxXref"?: string;
    "countryTaxAmount"?: number;

    /**
     * Set to true if transaction is taxable at the composite level.
     */
    "compositeTaxFlag"?: boolean;
    "compositeTaxXref"?: string;
    "compositeTaxAmount"?: number;
    "taxTotal"?: number;
    "customer"?: CompanyReference;
    "vendor"?: CompanyReference;
    "vendorAccountNumber"?: string;
    "vendorInvoiceNumber"?: string;
    "vendorInvoiceDate"?: Date;
    "taxFreightFlag"?: boolean;
    "freightTaxTotal"?: number;
    "freightCost"?: number;
    "dateClosed"?: Date;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace UnpostedProcurement {

export type ProcurementTypeEnum = 'Purchase' | 'Adjustment' | 'Transfer';
}
export interface UserDefinedField {

    /**
     * ID of the custom user defined field
     */
    "id"?: number;

    /**
     * Id of the Pod where the custom field will be placed
     */
    "podId": number;

    /**
     * Field caption
     */
    "caption": string;

    /**
     * Must be between 1 and 50.  This defines the order in which the custom fields will appear
     */
    "sequenceNumber": number;

    /**
     * Help text to accompany the custom field
     */
    "helpText"?: string;
    "fieldTypeIdentifier": UserDefinedField.FieldTypeIdentifierEnum;

    /**
     * Only valid for Number or percent
     */
    "numberDecimals"?: number;
    "entryTypeIdentifier"?: UserDefinedField.EntryTypeIdentifierEnum;
    "requiredFlag"?: boolean;
    "displayOnScreenFlag"?: boolean;
    "readOnlyFlag"?: boolean;

    /**
     * Denotes that this custom field is included on a list view
     */
    "listViewFlag"?: boolean;

    /**
     * Only available with Button Field Type. Required when entryTypeIdentifier is button
     */
    "buttonUrl"?: string;
    "options"?: Array<UserDefinedFieldOption>;
    "businessUnitIds"?: Array<number>;
    "locationIds"?: Array<number>;
    "addAllBusinessUnits"?: boolean;
    "removeAllBusinessUnits"?: boolean;
    "addAllLocations"?: boolean;
    "removeAllLocations"?: boolean;

    /**
     * Date in UTC the custom field was created
     */
    "dateCreated"?: Date;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace UserDefinedField {

export type FieldTypeIdentifierEnum = 'Button' | 'Checkbox' | 'Date' | 'Hyperlink' | 'Number' | 'Percent' | 'Text' | 'TextArea';

export type EntryTypeIdentifierEnum = 'EntryField' | 'List' | 'Option';
}
export interface UserDefinedFieldOption {
    "id"?: number;
    "optionValue": string;
    "defaultFlag"?: boolean;
    "inactiveFlag"?: boolean;
    "sortOrder"?: number;
}

/**
 * If your trigger is for custom fields, this will populate with the custom field associated with the option
 */
export interface UserDefinedFieldReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface ValidatePortalRequest {
    "email": string;
    "password": string;
}

export interface ValidatePortalResponse {
    "success"?: boolean;
    "contactId"?: number;
}

export interface ValidationError {
    "code"?: string;
    "message"?: string;
    "resource"?: string;
    "field"?: string;
    "details"?: string;
}

export interface Warehouse {
    "id"?: number;
    "name": string;
    "company"?: CompanyReference;
    "location": SystemLocationReference;
    "department"?: SystemDepartmentReference;
    "manager"?: MemberReference;
    "site"?: SiteReference;
    "locationXref"?: string;
    "locationDefaultFlag"?: boolean;
    "overallDefaultFlag"?: boolean;
    "inactiveFlag"?: boolean;
    "currency"?: CurrencyReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface WarehouseBin {
    "id"?: number;
    "name": string;
    "warehouse": WarehouseReference;
    "location"?: SystemLocationReference;
    "department"?: SystemDepartmentReference;
    "minQuantity"?: number;
    "maxQuantity"?: number;
    "overflowBin"?: WarehouseBinReference;
    "manager"?: MemberReference;
    "length"?: number;
    "width"?: number;
    "height"?: number;
    "weight"?: number;
    "defaultFlag"?: boolean;
    "inactiveFlag"?: boolean;
    "transferBin"?: WarehouseBinReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface WarehouseBinReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface WarehouseReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface WorkRole {
    "id"?: number;
    "name": string;
    "hourlyRate"?: number;
    "integrationXref"?: string;
    "inactiveFlag"?: boolean;
    "addAllLocations"?: boolean;
    "removeAllLocations"?: boolean;

    /**
     * Used only on create to add the work role to all agreement and agreement type exclusion lists
     */
    "addAllAgreementExclusions"?: boolean;
    "locationIds"?: Array<number>;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface WorkRoleExemption {
    "id"?: number;
    "workRole": WorkRoleReference;

    /**
     * At least one level flag is required -- levelOneFlag, levelTwoFlag, levelThreeFlag, levelFourFlag, and/or levelFiveFlag
     */
    "levelOneFlag"?: boolean;

    /**
     * At least one level flag is required -- levelOneFlag, levelTwoFlag, levelThreeFlag, levelFourFlag, and/or levelFiveFlag
     */
    "levelTwoFlag"?: boolean;

    /**
     * At least one level flag is required -- levelOneFlag, levelTwoFlag, levelThreeFlag, levelFourFlag, and/or levelFiveFlag
     */
    "levelThreeFlag"?: boolean;

    /**
     * At least one level flag is required -- levelOneFlag, levelTwoFlag, levelThreeFlag, levelFourFlag, and/or levelFiveFlag
     */
    "levelFourFlag"?: boolean;

    /**
     * At least one level flag is required -- levelOneFlag, levelTwoFlag, levelThreeFlag, levelFourFlag, and/or levelFiveFlag
     */
    "levelFiveFlag"?: boolean;
    "taxCode"?: TaxCodeReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface WorkRoleLocation {
    "id"?: number;
    "location": SystemLocationReference;
    "hourlyRate"?: number;
    "workRole"?: WorkRoleReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface WorkRoleReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface WorkType {
    "id"?: number;
    "name": string;
    "billTime": WorkType.BillTimeEnum;
    "rateType": WorkType.RateTypeEnum;
    "rate": number;
    "hoursMin"?: number;
    "hoursMax"?: number;
    "roundBillHoursTo"?: number;
    "externalIntegrationXRef"?: ExternalWorkTypeIntegrationReference;
    "accrualType"?: WorkType.AccrualTypeEnum;
    "inactiveFlag"?: boolean;
    "overallDefaultFlag"?: boolean;
    "activityDefaultFlag"?: boolean;
    "utilizationFlag"?: boolean;
    "costMultiplier"?: number;
    "integrationXRef"?: string;

    /**
     * Used only on create to add the work type to all agreement and agreement type exclusion lists
     */
    "addAllAgreementExclusions"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace WorkType {

export type BillTimeEnum = 'Billable' | 'DoNotBill' | 'NoCharge';

export type RateTypeEnum = 'AdjAmount' | 'Custom' | 'Multiplier';

export type AccrualTypeEnum = 'Holiday' | 'PTO' | 'Sick' | 'Vacation';
}
export interface WorkTypeExternalIntegrationReference {
    "id"?: number;
    "identifier"?: string;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface WorkTypeReference {
    "id"?: number;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface Workflow {
    "id"?: number;
    "name": string;
    "tableType": WorkflowTableTypeReference;

    /**
     * If a department is set, a location that contains it must be set
     */
    "location"?: SystemLocationReference;

    /**
     * Must belong to the specified location
     */
    "department"?: SystemDepartmentReference;

    /**
     * Batches can not be turned on until after the workflow is created and it has atleast one event associated with it
     */
    "activateFlag"?: boolean;
    "batchInterval"?: number;

    /**
     * If not specified, defaults to Minutes. Months is not supported as month length varies
     */
    "batchFrequencyUnit"?: Workflow.BatchFrequencyUnitEnum;
    "batchLastRan"?: Date;

    /**
     * If activateFlag is true, batchSchedule is required
     */
    "batchSchedule"?: Workflow.BatchScheduleEnum;
    "board"?: BoardReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace Workflow {

export type BatchFrequencyUnitEnum = 'Minutes' | 'Hours' | 'Days';

export type BatchScheduleEnum = 'AnyTime' | 'MyCompanyOfficeHours' | 'SlaHours';
}
export interface WorkflowAction {
    "id"?: number;
    "notifyType": NotifyTypeReference;

    /**
     * Required when notifyType is set to: "Create Activity", "Send Email", "Add Follower", "Assign Resource", "Close Survey"
     */
    "notifyWho"?: NotificationRecipientReference;

    /**
     * Required when notifyWho is set to: "Specific Member", "
     */
    "specificMemberTo"?: MemberReference;

    /**
     * Required when notifyWho is set to: "Email Address"
     */
    "emailRecipient"?: string;

    /**
     * Required when notifyType is set to: "Create Activity", "Send Email", "Assign Resource"
     */
    "notifyFrom"?: NotificationRecipientReference;

    /**
     * Required when notifyFrom is set to: "Specific Member"
     */
    "specificMemberFrom"?: MemberReference;

    /**
     * Required when notifyFrom is set to: "Email Address"
     */
    "emailFrom"?: string;
    "ccContact"?: ContactReference;
    "bccContact"?: ContactReference;

    /**
     * Required when notifyType is set to: "Create Activity", "Send Email", "Assign Resource"
     */
    "subject"?: string;
    "notes"?: string;

    /**
     * Required when notifyType is set to: "Create Activity"
     */
    "activityStatus"?: ActivityStatusReference;

    /**
     * Required when notifyType is set to: "Create Activity"
     */
    "activityType"?: ActivityTypeReference;

    /**
     * Required when notifyType is set to: "Attach Track"
     */
    "attachedTrack"?: TrackReference;
    "daysToExecute"?: number;

    /**
     * Required when notifyType is set to: "Change Board"
     */
    "board"?: BoardReference;

    /**
     * Required when notifyType is set to: "Change Board", "Change Ticket Status"
     */
    "boardStatus"?: ServiceStatusReference;
    "serviceType"?: ServiceTypeReference;

    /**
     * Required when notifyType is set to: "Add to Group"
     */
    "group"?: GroupReference;

    /**
     * Required when notifyType is set to: "Create a Service Ticket"
     */
    "serviceTemplate"?: ServiceTemplateReference;
    "invoiceMinDays"?: number;

    /**
     * Required when notifyType is set to: "Run Connectwise Automate Script"
     */
    "automateScript"?: AutomateScriptReference;

    /**
     * Required when notifyType is set to: "Run Connectwise Automate Script"
     */
    "scriptSuccessStatus"?: ServiceStatusReference;

    /**
     * Required when notifyType is set to: "Run Connectwise Automate Script"
     */
    "scriptFailStatus"?: ServiceStatusReference;
    "detailNotesFlag"?: boolean;
    "internalNotesFlag"?: boolean;
    "auditNotesFlag"?: boolean;

    /**
     * Required when notifyType is set to: "Change Ticket Priority"
     */
    "servicePriority"?: PriorityReference;
    "updateOwnerFlag"?: boolean;

    /**
     * Required when notifyType is set to: "Change Sales Order Status"
     */
    "salesOrderStatus"?: OrderStatusReference;

    /**
     * Required when notifyType is set to: "Change Project Status"
     */
    "projectStatus"?: ProjectStatusReference;

    /**
     * Required when notifyType is set to: "Change Company Status"
     */
    "companyStatus"?: CompanyStatusReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface WorkflowActionAutomateParameter {
    "id"?: number;
    "name": string;
    "value"?: string;
}

export interface WorkflowEvent {
    "id"?: number;
    "name"?: string;
    "eventCondition": string;

    /**
     * Required when exectionTimes is set to MultipleTimes or Continuously
     */
    "frequencyUnit"?: WorkflowEvent.FrequencyUnitEnum;

    /**
     * Required when exectionTimes is set to MultipleTimes or Continuously
     */
    "frequencyOfExecution"?: number;

    /**
     * Required when exectionTimes is set to MultipleTimes
     */
    "maxNumberOfExecution"?: number;

    /**
     * Defaults to Once when not specified
     */
    "executionTime"?: WorkflowEvent.ExecutionTimeEnum;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export namespace WorkflowEvent {

export type FrequencyUnitEnum = 'Minutes' | 'Hours' | 'Days' | 'Months';

export type ExecutionTimeEnum = 'Once' | 'MultipleTimes' | 'Continuously';
}
export interface WorkflowNotifyType {
    "id"?: number;
    "identifier"?: string;
    "name"?: string;

    /**
     * If the current action is available because it is already set up. Pertains to integrations such as Automate
     */
    "isSetupFlag"?: boolean;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface WorkflowTableType {
    "id"?: number;
    "identifier"?: string;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface WorkflowTableTypeReference {
    "id"?: number;
    "identifier"?: string;
    "name"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface WorkflowTrigger {
    "id"?: number;
    "name"?: string;
    "description"?: string;
    "hasOptionsFlag"?: boolean;
    "hasOperatorFlag"?: boolean;
    "customField"?: UserDefinedFieldReference;
    "expectedType"?: string;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}

export interface WorkflowTriggerOption {
    "value"?: string;
    "name"?: string;

    /**
     * If your trigger is for custom fields, this will populate with the custom field associated with the option
     */
    "customField"?: UserDefinedFieldReference;

    /**
     * Metadata of the entity
     */
    "info"?: Metadata;
}


//export namespace  {
    'use strict';

    export class AccountingBatchesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Batches Count
         * @param conditions
         */
        public financeAccountingBatchesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/accounting/batches/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Batches
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeAccountingBatchesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AccountingBatch>> {
            const localVarPath = this.basePath + '/finance/accounting/batches';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Batch By Id
         * @param id
         */
        public financeAccountingBatchesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/accounting/batches/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAccountingBatchesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Re-export the payload data from an existing batch (RecreateBatch in SOAP)
         * @param id
         * @param batchExportParameters
         */
        public financeAccountingBatchesIdExportPost (params: {  id: number; batchExportParameters: ExportAccountingBatchRequest; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<GLExport> {
            const localVarPath = this.basePath + '/finance/accounting/batches/{id}/export'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAccountingBatchesIdExportPost');
            }
            // verify required parameter 'batchExportParameters' is set
            if (params.batchExportParameters == null) {
                throw new Error('Missing required parameter batchExportParameters when calling financeAccountingBatchesIdExportPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.batchExportParameters),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Batch By Id
         * @param id
         */
        public financeAccountingBatchesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AccountingBatch> {
            const localVarPath = this.basePath + '/finance/accounting/batches/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAccountingBatchesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Creates the Accounting Batch and updates GL Records (UpdateBatch in SOAP)
         * @param accountingBatchParameters
         */
        public financeAccountingBatchesPost (params: {  accountingBatchParameters: CreateAccountingBatchRequest; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<GLExport> {
            const localVarPath = this.basePath + '/finance/accounting/batches';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'accountingBatchParameters' is set
            if (params.accountingBatchParameters == null) {
                throw new Error('Missing required parameter accountingBatchParameters when calling financeAccountingBatchesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.accountingBatchParameters),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Exports accouting batch payload based on parameters (CreateBatch in SOAP)
         * @param batchExportParameters
         */
        public financeAccountingExportPost (params: {  batchExportParameters: ExportAccountingBatchRequest; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<GLExport> {
            const localVarPath = this.basePath + '/finance/accounting/export';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'batchExportParameters' is set
            if (params.batchExportParameters == null) {
                throw new Error('Missing required parameter batchExportParameters when calling financeAccountingExportPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.batchExportParameters),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AccountingPackagesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Accounting Packages Count
         * @param conditions
         */
        public systemAccountingPackagesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/accountingPackages/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Accounting Packages
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemAccountingPackagesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AccountingPackage>> {
            const localVarPath = this.basePath + '/system/accountingPackages';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Accounting Package By Id
         * @param id
         */
        public systemAccountingPackagesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AccountingPackage> {
            const localVarPath = this.basePath + '/system/accountingPackages/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemAccountingPackagesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AccountingUnpostedExpensesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Unposted Expenses Count
         * @param conditions
         */
        public financeAccountingUnpostedexpensesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/accounting/unpostedexpenses/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Unposted Expenses
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeAccountingUnpostedexpensesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<UnpostedExpense>> {
            const localVarPath = this.basePath + '/finance/accounting/unpostedexpenses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Unposted Expense By Id
         * @param id
         */
        public financeAccountingUnpostedexpensesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<UnpostedExpense> {
            const localVarPath = this.basePath + '/finance/accounting/unpostedexpenses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAccountingUnpostedexpensesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AccountingUnpostedProcurementsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Unposted Procurements Count
         * @param conditions
         */
        public financeAccountingUnpostedprocurementCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/accounting/unpostedprocurement/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Unposted Procurements
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeAccountingUnpostedprocurementGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<UnpostedProcurement>> {
            const localVarPath = this.basePath + '/finance/accounting/unpostedprocurement';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Unposted Procurement By Id
         * @param id
         */
        public financeAccountingUnpostedprocurementIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<UnpostedProcurement> {
            const localVarPath = this.basePath + '/finance/accounting/unpostedprocurement/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAccountingUnpostedprocurementIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AccountingUnpostedinvoicesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Unposted Invoices Count
         * @param conditions
         */
        public financeAccountingUnpostedinvoicesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/accounting/unpostedinvoices/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Unposted Invoices
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeAccountingUnpostedinvoicesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<UnpostedInvoice>> {
            const localVarPath = this.basePath + '/finance/accounting/unpostedinvoices';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Unposted Invoice By Id
         * @param id
         */
        public financeAccountingUnpostedinvoicesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<UnpostedInvoice> {
            const localVarPath = this.basePath + '/finance/accounting/unpostedinvoices/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAccountingUnpostedinvoicesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ActivitiesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Activities Count
         * @param conditions
         * @param customFieldConditions
         */
        public salesActivitiesCountGet (params: {  conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/sales/activities/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.customFieldConditions !== undefined) {
                queryParameters['customFieldConditions'] = params.customFieldConditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Activities
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public salesActivitiesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Activity>> {
            const localVarPath = this.basePath + '/sales/activities';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Activity By Id
         * @param id
         */
        public salesActivitiesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/sales/activities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesActivitiesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Activity By Id
         * @param id
         */
        public salesActivitiesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Activity> {
            const localVarPath = this.basePath + '/sales/activities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesActivitiesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Activity
         * @param id
         * @param operations
         */
        public salesActivitiesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Activity> {
            const localVarPath = this.basePath + '/sales/activities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesActivitiesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling salesActivitiesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Activity
         * @param id
         * @param activity
         */
        public salesActivitiesIdPut (params: {  id: number; activity: Activity; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Activity> {
            const localVarPath = this.basePath + '/sales/activities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesActivitiesIdPut');
            }
            // verify required parameter 'activity' is set
            if (params.activity == null) {
                throw new Error('Missing required parameter activity when calling salesActivitiesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.activity),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Activity
         * @param activity
         */
        public salesActivitiesPost (params: {  activity: Activity; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Activity> {
            const localVarPath = this.basePath + '/sales/activities';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'activity' is set
            if (params.activity == null) {
                throw new Error('Missing required parameter activity when calling salesActivitiesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.activity),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ActivityStatusesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Activity Statuses Count
         * @param conditions
         */
        public salesActivitiesStatusesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/sales/activities/statuses/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Activity Statuses
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public salesActivitiesStatusesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ActivityStatus>> {
            const localVarPath = this.basePath + '/sales/activities/statuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Activity Status By Id
         * @param id
         */
        public salesActivitiesStatusesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/sales/activities/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesActivitiesStatusesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Activity Status By Id
         * @param id
         */
        public salesActivitiesStatusesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityStatus> {
            const localVarPath = this.basePath + '/sales/activities/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesActivitiesStatusesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Activity Status
         * @param id
         * @param operations
         */
        public salesActivitiesStatusesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityStatus> {
            const localVarPath = this.basePath + '/sales/activities/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesActivitiesStatusesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling salesActivitiesStatusesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Activity Status
         * @param id
         * @param activityStatus
         */
        public salesActivitiesStatusesIdPut (params: {  id: number; activityStatus: ActivityStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityStatus> {
            const localVarPath = this.basePath + '/sales/activities/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesActivitiesStatusesIdPut');
            }
            // verify required parameter 'activityStatus' is set
            if (params.activityStatus == null) {
                throw new Error('Missing required parameter activityStatus when calling salesActivitiesStatusesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.activityStatus),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Activity Status
         * @param activityStatus
         */
        public salesActivitiesStatusesPost (params: {  activityStatus: ActivityStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityStatus> {
            const localVarPath = this.basePath + '/sales/activities/statuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'activityStatus' is set
            if (params.activityStatus == null) {
                throw new Error('Missing required parameter activityStatus when calling salesActivitiesStatusesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.activityStatus),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ActivityStopwatchesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Activity Stopwatches Count
         * @param conditions
         */
        public timeActivitystopwatchesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/time/activitystopwatches/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Activity Stopwatches
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public timeActivitystopwatchesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ActivityStopwatch>> {
            const localVarPath = this.basePath + '/time/activitystopwatches';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Activity Stopwatch By Id
         * @param id
         */
        public timeActivitystopwatchesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/time/activitystopwatches/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeActivitystopwatchesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Activity Stopwatch By Id
         * @param id
         */
        public timeActivitystopwatchesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityStopwatch> {
            const localVarPath = this.basePath + '/time/activitystopwatches/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeActivitystopwatchesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Activity Stopwatch
         * @param id
         * @param operations
         */
        public timeActivitystopwatchesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityStopwatch> {
            const localVarPath = this.basePath + '/time/activitystopwatches/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeActivitystopwatchesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling timeActivitystopwatchesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Activity Stopwatch
         * @param id
         * @param activityStopwatch
         */
        public timeActivitystopwatchesIdPut (params: {  id: number; activityStopwatch: ActivityStopwatch; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityStopwatch> {
            const localVarPath = this.basePath + '/time/activitystopwatches/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeActivitystopwatchesIdPut');
            }
            // verify required parameter 'activityStopwatch' is set
            if (params.activityStopwatch == null) {
                throw new Error('Missing required parameter activityStopwatch when calling timeActivitystopwatchesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.activityStopwatch),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Activity Stopwatch
         * @param activityStopwatch
         */
        public timeActivitystopwatchesPost (params: {  activityStopwatch: ActivityStopwatch; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityStopwatch> {
            const localVarPath = this.basePath + '/time/activitystopwatches';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'activityStopwatch' is set
            if (params.activityStopwatch == null) {
                throw new Error('Missing required parameter activityStopwatch when calling timeActivitystopwatchesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.activityStopwatch),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ActivityTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Activity Types Count
         * @param conditions
         */
        public salesActivitiesTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/sales/activities/types/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Activity Types
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public salesActivitiesTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ActivityType>> {
            const localVarPath = this.basePath + '/sales/activities/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Activity Type By Id
         * @param id
         */
        public salesActivitiesTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/sales/activities/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesActivitiesTypesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Activity Type By Id
         * @param id
         */
        public salesActivitiesTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityType> {
            const localVarPath = this.basePath + '/sales/activities/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesActivitiesTypesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Activity Type
         * @param id
         * @param operations
         */
        public salesActivitiesTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityType> {
            const localVarPath = this.basePath + '/sales/activities/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesActivitiesTypesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling salesActivitiesTypesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Activity Type
         * @param id
         * @param activityType
         */
        public salesActivitiesTypesIdPut (params: {  id: number; activityType: ActivityType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityType> {
            const localVarPath = this.basePath + '/sales/activities/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesActivitiesTypesIdPut');
            }
            // verify required parameter 'activityType' is set
            if (params.activityType == null) {
                throw new Error('Missing required parameter activityType when calling salesActivitiesTypesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.activityType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Activity Type
         * @param activityType
         */
        public salesActivitiesTypesPost (params: {  activityType: ActivityType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityType> {
            const localVarPath = this.basePath + '/sales/activities/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'activityType' is set
            if (params.activityType == null) {
                throw new Error('Missing required parameter activityType when calling salesActivitiesTypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.activityType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AddressFormatsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Address Formats Count
         * @param conditions
         */
        public companyAddressFormatsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/addressFormats/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Address Formats
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyAddressFormatsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AddressFormat>> {
            const localVarPath = this.basePath + '/company/addressFormats';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Address Format By Id
         * @param id
         */
        public companyAddressFormatsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/addressFormats/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyAddressFormatsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Address Format By Id
         * @param id
         */
        public companyAddressFormatsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AddressFormat> {
            const localVarPath = this.basePath + '/company/addressFormats/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyAddressFormatsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Address Format
         * @param id
         * @param operations
         */
        public companyAddressFormatsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AddressFormat> {
            const localVarPath = this.basePath + '/company/addressFormats/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyAddressFormatsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyAddressFormatsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Address Format
         * @param id
         * @param addressFormat
         */
        public companyAddressFormatsIdPut (params: {  id: number; addressFormat: AddressFormat; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AddressFormat> {
            const localVarPath = this.basePath + '/company/addressFormats/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyAddressFormatsIdPut');
            }
            // verify required parameter 'addressFormat' is set
            if (params.addressFormat == null) {
                throw new Error('Missing required parameter addressFormat when calling companyAddressFormatsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.addressFormat),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Address Format
         * @param addressFormat
         */
        public companyAddressFormatsPost (params: {  addressFormat: AddressFormat; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AddressFormat> {
            const localVarPath = this.basePath + '/company/addressFormats';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'addressFormat' is set
            if (params.addressFormat == null) {
                throw new Error('Missing required parameter addressFormat when calling companyAddressFormatsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.addressFormat),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AdjustmentDetailsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Adjustment Detail Count
         * @param id
         * @param conditions
         */
        public procurementAdjustmentsIdDetailsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/adjustments/{id}/details/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementAdjustmentsIdDetailsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Adjustment Detail By Id
         * @param id
         * @param detailId
         */
        public procurementAdjustmentsIdDetailsDetailIdDelete (params: {  id: number; detailId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/adjustments/{id}/details/{detailId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'detailId' + '}', String(params.detailId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementAdjustmentsIdDetailsDetailIdDelete');
            }
            // verify required parameter 'detailId' is set
            if (params.detailId == null) {
                throw new Error('Missing required parameter detailId when calling procurementAdjustmentsIdDetailsDetailIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Adjustment Detail By Id
         * @param id
         * @param detailId
         */
        public procurementAdjustmentsIdDetailsDetailIdGet (params: {  id: number; detailId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AdjustmentDetail> {
            const localVarPath = this.basePath + '/procurement/adjustments/{id}/details/{detailId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'detailId' + '}', String(params.detailId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementAdjustmentsIdDetailsDetailIdGet');
            }
            // verify required parameter 'detailId' is set
            if (params.detailId == null) {
                throw new Error('Missing required parameter detailId when calling procurementAdjustmentsIdDetailsDetailIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Adjustment Detail
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementAdjustmentsIdDetailsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AdjustmentDetail>> {
            const localVarPath = this.basePath + '/procurement/adjustments/{id}/details'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementAdjustmentsIdDetailsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Adjustment Detail
         * @param id
         * @param adjustmentDetail
         */
        public procurementAdjustmentsIdDetailsPost (params: {  id: number; adjustmentDetail: AdjustmentDetail; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AdjustmentDetail> {
            const localVarPath = this.basePath + '/procurement/adjustments/{id}/details'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementAdjustmentsIdDetailsPost');
            }
            // verify required parameter 'adjustmentDetail' is set
            if (params.adjustmentDetail == null) {
                throw new Error('Missing required parameter adjustmentDetail when calling procurementAdjustmentsIdDetailsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.adjustmentDetail),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AdjustmentTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Adjustment Types Count
         * @param conditions
         */
        public procurementAdjustmentsTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/adjustments/types/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Adjustment Types
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementAdjustmentsTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AdjustmentType>> {
            const localVarPath = this.basePath + '/procurement/adjustments/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Adjustment Types By Id
         * @param id
         */
        public procurementAdjustmentsTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/adjustments/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementAdjustmentsTypesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Adjustment Types By Id
         * @param id
         */
        public procurementAdjustmentsTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AdjustmentType> {
            const localVarPath = this.basePath + '/procurement/adjustments/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementAdjustmentsTypesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Adjustment Types
         * @param id
         * @param operations
         */
        public procurementAdjustmentsTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AdjustmentType> {
            const localVarPath = this.basePath + '/procurement/adjustments/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementAdjustmentsTypesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementAdjustmentsTypesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Adjustment Types
         * @param id
         * @param adjustmentTypes
         */
        public procurementAdjustmentsTypesIdPut (params: {  id: number; adjustmentTypes: AdjustmentType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AdjustmentType> {
            const localVarPath = this.basePath + '/procurement/adjustments/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementAdjustmentsTypesIdPut');
            }
            // verify required parameter 'adjustmentTypes' is set
            if (params.adjustmentTypes == null) {
                throw new Error('Missing required parameter adjustmentTypes when calling procurementAdjustmentsTypesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.adjustmentTypes),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Adjustment Types
         * @param adjustmentTypes
         */
        public procurementAdjustmentsTypesPost (params: {  adjustmentTypes: AdjustmentType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AdjustmentType> {
            const localVarPath = this.basePath + '/procurement/adjustments/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'adjustmentTypes' is set
            if (params.adjustmentTypes == null) {
                throw new Error('Missing required parameter adjustmentTypes when calling procurementAdjustmentsTypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.adjustmentTypes),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AdjustmentsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Adjustment Count
         * @param conditions
         */
        public procurementAdjustmentsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/adjustments/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Adjustment
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementAdjustmentsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Adjustment>> {
            const localVarPath = this.basePath + '/procurement/adjustments';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Adjustment By Id
         * @param id
         */
        public procurementAdjustmentsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/adjustments/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementAdjustmentsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Adjustment By Id
         * @param id
         */
        public procurementAdjustmentsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Adjustment> {
            const localVarPath = this.basePath + '/procurement/adjustments/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementAdjustmentsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Adjustment
         * @param id
         * @param operations
         */
        public procurementAdjustmentsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Adjustment> {
            const localVarPath = this.basePath + '/procurement/adjustments/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementAdjustmentsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementAdjustmentsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Adjustment
         * @param id
         * @param adjustment
         */
        public procurementAdjustmentsIdPut (params: {  id: number; adjustment: Adjustment; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Adjustment> {
            const localVarPath = this.basePath + '/procurement/adjustments/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementAdjustmentsIdPut');
            }
            // verify required parameter 'adjustment' is set
            if (params.adjustment == null) {
                throw new Error('Missing required parameter adjustment when calling procurementAdjustmentsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.adjustment),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Adjustment
         * @param adjustment
         */
        public procurementAdjustmentsPost (params: {  adjustment: Adjustment; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Adjustment> {
            const localVarPath = this.basePath + '/procurement/adjustments';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'adjustment' is set
            if (params.adjustment == null) {
                throw new Error('Missing required parameter adjustment when calling procurementAdjustmentsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.adjustment),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AgreementAdditionsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Delete Addition By Id
         * @param id
         * @param additionId
         */
        public financeAgreementsIdAdditionsAdditionIdDelete (params: {  id: number; additionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/additions/{additionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'additionId' + '}', String(params.additionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdAdditionsAdditionIdDelete');
            }
            // verify required parameter 'additionId' is set
            if (params.additionId == null) {
                throw new Error('Missing required parameter additionId when calling financeAgreementsIdAdditionsAdditionIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Addition By Id
         * @param id
         * @param additionId
         */
        public financeAgreementsIdAdditionsAdditionIdGet (params: {  id: number; additionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Addition> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/additions/{additionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'additionId' + '}', String(params.additionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdAdditionsAdditionIdGet');
            }
            // verify required parameter 'additionId' is set
            if (params.additionId == null) {
                throw new Error('Missing required parameter additionId when calling financeAgreementsIdAdditionsAdditionIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Addition
         * @param id
         * @param additionId
         * @param operations
         */
        public financeAgreementsIdAdditionsAdditionIdPatch (params: {  id: number; additionId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Addition> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/additions/{additionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'additionId' + '}', String(params.additionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdAdditionsAdditionIdPatch');
            }
            // verify required parameter 'additionId' is set
            if (params.additionId == null) {
                throw new Error('Missing required parameter additionId when calling financeAgreementsIdAdditionsAdditionIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeAgreementsIdAdditionsAdditionIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Addition
         * @param id
         * @param additionId
         * @param addition
         */
        public financeAgreementsIdAdditionsAdditionIdPut (params: {  id: number; additionId: number; addition: Addition; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Addition> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/additions/{additionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'additionId' + '}', String(params.additionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdAdditionsAdditionIdPut');
            }
            // verify required parameter 'additionId' is set
            if (params.additionId == null) {
                throw new Error('Missing required parameter additionId when calling financeAgreementsIdAdditionsAdditionIdPut');
            }
            // verify required parameter 'addition' is set
            if (params.addition == null) {
                throw new Error('Missing required parameter addition when calling financeAgreementsIdAdditionsAdditionIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.addition),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Additions Count
         * @param id
         * @param conditions
         * @param customFieldConditions
         */
        public financeAgreementsIdAdditionsCountGet (params: {  id: number; conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/additions/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdAdditionsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.customFieldConditions !== undefined) {
                queryParameters['customFieldConditions'] = params.customFieldConditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Additions
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeAgreementsIdAdditionsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Addition>> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/additions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdAdditionsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Addition
         * @param id
         * @param addition
         */
        public financeAgreementsIdAdditionsPost (params: {  id: number; addition: Addition; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Addition> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/additions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdAdditionsPost');
            }
            // verify required parameter 'addition' is set
            if (params.addition == null) {
                throw new Error('Missing required parameter addition when calling financeAgreementsIdAdditionsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.addition),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AgreementAdjustmentsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Delete Adjustment By Id
         * @param id
         * @param adjustmentId
         */
        public financeAgreementsIdAdjustmentsAdjustmentIdDelete (params: {  id: number; adjustmentId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/adjustments/{adjustmentId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'adjustmentId' + '}', String(params.adjustmentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdAdjustmentsAdjustmentIdDelete');
            }
            // verify required parameter 'adjustmentId' is set
            if (params.adjustmentId == null) {
                throw new Error('Missing required parameter adjustmentId when calling financeAgreementsIdAdjustmentsAdjustmentIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Adjustment By Id
         * @param id
         * @param adjustmentId
         */
        public financeAgreementsIdAdjustmentsAdjustmentIdGet (params: {  id: number; adjustmentId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Adjustment> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/adjustments/{adjustmentId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'adjustmentId' + '}', String(params.adjustmentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdAdjustmentsAdjustmentIdGet');
            }
            // verify required parameter 'adjustmentId' is set
            if (params.adjustmentId == null) {
                throw new Error('Missing required parameter adjustmentId when calling financeAgreementsIdAdjustmentsAdjustmentIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Adjustment
         * @param id
         * @param adjustmentId
         * @param operations
         */
        public financeAgreementsIdAdjustmentsAdjustmentIdPatch (params: {  id: number; adjustmentId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Adjustment> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/adjustments/{adjustmentId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'adjustmentId' + '}', String(params.adjustmentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdAdjustmentsAdjustmentIdPatch');
            }
            // verify required parameter 'adjustmentId' is set
            if (params.adjustmentId == null) {
                throw new Error('Missing required parameter adjustmentId when calling financeAgreementsIdAdjustmentsAdjustmentIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeAgreementsIdAdjustmentsAdjustmentIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Adjustment
         * @param id
         * @param adjustmentId
         * @param adjustment
         */
        public financeAgreementsIdAdjustmentsAdjustmentIdPut (params: {  id: number; adjustmentId: number; adjustment: Adjustment; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Adjustment> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/adjustments/{adjustmentId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'adjustmentId' + '}', String(params.adjustmentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdAdjustmentsAdjustmentIdPut');
            }
            // verify required parameter 'adjustmentId' is set
            if (params.adjustmentId == null) {
                throw new Error('Missing required parameter adjustmentId when calling financeAgreementsIdAdjustmentsAdjustmentIdPut');
            }
            // verify required parameter 'adjustment' is set
            if (params.adjustment == null) {
                throw new Error('Missing required parameter adjustment when calling financeAgreementsIdAdjustmentsAdjustmentIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.adjustment),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Adjustments Count
         * @param id
         * @param conditions
         * @param customFieldConditions
         */
        public financeAgreementsIdAdjustmentsCountGet (params: {  id: number; conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/adjustments/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdAdjustmentsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.customFieldConditions !== undefined) {
                queryParameters['customFieldConditions'] = params.customFieldConditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Adjustments
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeAgreementsIdAdjustmentsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Adjustment>> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/adjustments'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdAdjustmentsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Adjustment
         * @param id
         * @param adjustment
         */
        public financeAgreementsIdAdjustmentsPost (params: {  id: number; adjustment: Adjustment; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Adjustment> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/adjustments'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdAdjustmentsPost');
            }
            // verify required parameter 'adjustment' is set
            if (params.adjustment == null) {
                throw new Error('Missing required parameter adjustment when calling financeAgreementsIdAdjustmentsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.adjustment),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AgreementBatchSetupsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Batch Setup Count
         * @param conditions
         */
        public financeBatchSetupsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/batchSetups/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Batch Setup
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeBatchSetupsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AgreementBatchSetup>> {
            const localVarPath = this.basePath + '/finance/batchSetups';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Batch Setup By Id
         * @param id
         */
        public financeBatchSetupsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementBatchSetup> {
            const localVarPath = this.basePath + '/finance/batchSetups/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeBatchSetupsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Batch Setup
         * @param id
         * @param operations
         */
        public financeBatchSetupsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementBatchSetup> {
            const localVarPath = this.basePath + '/finance/batchSetups/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeBatchSetupsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeBatchSetupsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Batch Setup
         * @param id
         * @param batchSetup
         */
        public financeBatchSetupsIdPut (params: {  id: number; batchSetup: AgreementBatchSetup; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementBatchSetup> {
            const localVarPath = this.basePath + '/finance/batchSetups/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeBatchSetupsIdPut');
            }
            // verify required parameter 'batchSetup' is set
            if (params.batchSetup == null) {
                throw new Error('Missing required parameter batchSetup when calling financeBatchSetupsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.batchSetup),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AgreementBoardDefaultsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Delete Board Default By Id
         * @param id
         * @param boardDefaultId
         */
        public financeAgreementsIdBoardDefaultsBoardDefaultIdDelete (params: {  id: number; boardDefaultId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/boardDefaults/{boardDefaultId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'boardDefaultId' + '}', String(params.boardDefaultId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdBoardDefaultsBoardDefaultIdDelete');
            }
            // verify required parameter 'boardDefaultId' is set
            if (params.boardDefaultId == null) {
                throw new Error('Missing required parameter boardDefaultId when calling financeAgreementsIdBoardDefaultsBoardDefaultIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Board Default By Id
         * @param id
         * @param boardDefaultId
         */
        public financeAgreementsIdBoardDefaultsBoardDefaultIdGet (params: {  id: number; boardDefaultId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardDefault> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/boardDefaults/{boardDefaultId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'boardDefaultId' + '}', String(params.boardDefaultId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdBoardDefaultsBoardDefaultIdGet');
            }
            // verify required parameter 'boardDefaultId' is set
            if (params.boardDefaultId == null) {
                throw new Error('Missing required parameter boardDefaultId when calling financeAgreementsIdBoardDefaultsBoardDefaultIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Board Default
         * @param id
         * @param boardDefaultId
         * @param operations
         */
        public financeAgreementsIdBoardDefaultsBoardDefaultIdPatch (params: {  id: number; boardDefaultId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardDefault> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/boardDefaults/{boardDefaultId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'boardDefaultId' + '}', String(params.boardDefaultId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdBoardDefaultsBoardDefaultIdPatch');
            }
            // verify required parameter 'boardDefaultId' is set
            if (params.boardDefaultId == null) {
                throw new Error('Missing required parameter boardDefaultId when calling financeAgreementsIdBoardDefaultsBoardDefaultIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeAgreementsIdBoardDefaultsBoardDefaultIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Board Default
         * @param id
         * @param boardDefaultId
         * @param boardDefault
         */
        public financeAgreementsIdBoardDefaultsBoardDefaultIdPut (params: {  id: number; boardDefaultId: number; boardDefault: BoardDefault; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardDefault> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/boardDefaults/{boardDefaultId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'boardDefaultId' + '}', String(params.boardDefaultId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdBoardDefaultsBoardDefaultIdPut');
            }
            // verify required parameter 'boardDefaultId' is set
            if (params.boardDefaultId == null) {
                throw new Error('Missing required parameter boardDefaultId when calling financeAgreementsIdBoardDefaultsBoardDefaultIdPut');
            }
            // verify required parameter 'boardDefault' is set
            if (params.boardDefault == null) {
                throw new Error('Missing required parameter boardDefault when calling financeAgreementsIdBoardDefaultsBoardDefaultIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.boardDefault),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Board Defaults Count
         * @param id
         * @param conditions
         */
        public financeAgreementsIdBoardDefaultsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/boardDefaults/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdBoardDefaultsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Board Defaults
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeAgreementsIdBoardDefaultsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<BoardDefault>> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/boardDefaults'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdBoardDefaultsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Board Default
         * @param id
         * @param boardDefault
         */
        public financeAgreementsIdBoardDefaultsPost (params: {  id: number; boardDefault: BoardDefault; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardDefault> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/boardDefaults'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdBoardDefaultsPost');
            }
            // verify required parameter 'boardDefault' is set
            if (params.boardDefault == null) {
                throw new Error('Missing required parameter boardDefault when calling financeAgreementsIdBoardDefaultsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.boardDefault),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AgreementSitesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Sites Count
         * @param id
         * @param conditions
         */
        public financeAgreementsIdSitesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/sites/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdSitesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Sites
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeAgreementsIdSitesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AgreementSite>> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/sites'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdSitesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Site
         * @param id
         * @param site
         */
        public financeAgreementsIdSitesPost (params: {  id: number; site: AgreementSite; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementSite> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/sites'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdSitesPost');
            }
            // verify required parameter 'site' is set
            if (params.site == null) {
                throw new Error('Missing required parameter site when calling financeAgreementsIdSitesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.site),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Site By Id
         * @param id
         * @param siteId
         */
        public financeAgreementsIdSitesSiteIdDelete (params: {  id: number; siteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/sites/{siteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'siteId' + '}', String(params.siteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdSitesSiteIdDelete');
            }
            // verify required parameter 'siteId' is set
            if (params.siteId == null) {
                throw new Error('Missing required parameter siteId when calling financeAgreementsIdSitesSiteIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Site By Id
         * @param id
         * @param siteId
         */
        public financeAgreementsIdSitesSiteIdGet (params: {  id: number; siteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementSite> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/sites/{siteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'siteId' + '}', String(params.siteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdSitesSiteIdGet');
            }
            // verify required parameter 'siteId' is set
            if (params.siteId == null) {
                throw new Error('Missing required parameter siteId when calling financeAgreementsIdSitesSiteIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Site
         * @param id
         * @param siteId
         * @param operations
         */
        public financeAgreementsIdSitesSiteIdPatch (params: {  id: number; siteId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementSite> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/sites/{siteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'siteId' + '}', String(params.siteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdSitesSiteIdPatch');
            }
            // verify required parameter 'siteId' is set
            if (params.siteId == null) {
                throw new Error('Missing required parameter siteId when calling financeAgreementsIdSitesSiteIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeAgreementsIdSitesSiteIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Site
         * @param id
         * @param siteId
         * @param site
         */
        public financeAgreementsIdSitesSiteIdPut (params: {  id: number; siteId: number; site: AgreementSite; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementSite> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/sites/{siteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'siteId' + '}', String(params.siteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdSitesSiteIdPut');
            }
            // verify required parameter 'siteId' is set
            if (params.siteId == null) {
                throw new Error('Missing required parameter siteId when calling financeAgreementsIdSitesSiteIdPut');
            }
            // verify required parameter 'site' is set
            if (params.site == null) {
                throw new Error('Missing required parameter site when calling financeAgreementsIdSitesSiteIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.site),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AgreementTypeBoardDefaultsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Delete Agreement Type Board Default By Id
         * @param id
         * @param boardDefaultId
         */
        public financeAgreementTypesIdBoardDefaultsBoardDefaultIdDelete (params: {  id: number; boardDefaultId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/agreementTypes/{id}/boardDefaults/{boardDefaultId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'boardDefaultId' + '}', String(params.boardDefaultId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementTypesIdBoardDefaultsBoardDefaultIdDelete');
            }
            // verify required parameter 'boardDefaultId' is set
            if (params.boardDefaultId == null) {
                throw new Error('Missing required parameter boardDefaultId when calling financeAgreementTypesIdBoardDefaultsBoardDefaultIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Agreement Type Board Default By Id
         * @param id
         * @param boardDefaultId
         */
        public financeAgreementTypesIdBoardDefaultsBoardDefaultIdGet (params: {  id: number; boardDefaultId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementTypeBoardDefault> {
            const localVarPath = this.basePath + '/finance/agreementTypes/{id}/boardDefaults/{boardDefaultId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'boardDefaultId' + '}', String(params.boardDefaultId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementTypesIdBoardDefaultsBoardDefaultIdGet');
            }
            // verify required parameter 'boardDefaultId' is set
            if (params.boardDefaultId == null) {
                throw new Error('Missing required parameter boardDefaultId when calling financeAgreementTypesIdBoardDefaultsBoardDefaultIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Agreement Type Board Default
         * @param id
         * @param boardDefaultId
         * @param operations
         */
        public financeAgreementTypesIdBoardDefaultsBoardDefaultIdPatch (params: {  id: number; boardDefaultId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementTypeBoardDefault> {
            const localVarPath = this.basePath + '/finance/agreementTypes/{id}/boardDefaults/{boardDefaultId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'boardDefaultId' + '}', String(params.boardDefaultId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementTypesIdBoardDefaultsBoardDefaultIdPatch');
            }
            // verify required parameter 'boardDefaultId' is set
            if (params.boardDefaultId == null) {
                throw new Error('Missing required parameter boardDefaultId when calling financeAgreementTypesIdBoardDefaultsBoardDefaultIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeAgreementTypesIdBoardDefaultsBoardDefaultIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Agreement Type Board Default
         * @param id
         * @param boardDefaultId
         * @param boardDefault
         */
        public financeAgreementTypesIdBoardDefaultsBoardDefaultIdPut (params: {  id: number; boardDefaultId: number; boardDefault: AgreementTypeBoardDefault; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementTypeBoardDefault> {
            const localVarPath = this.basePath + '/finance/agreementTypes/{id}/boardDefaults/{boardDefaultId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'boardDefaultId' + '}', String(params.boardDefaultId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementTypesIdBoardDefaultsBoardDefaultIdPut');
            }
            // verify required parameter 'boardDefaultId' is set
            if (params.boardDefaultId == null) {
                throw new Error('Missing required parameter boardDefaultId when calling financeAgreementTypesIdBoardDefaultsBoardDefaultIdPut');
            }
            // verify required parameter 'boardDefault' is set
            if (params.boardDefault == null) {
                throw new Error('Missing required parameter boardDefault when calling financeAgreementTypesIdBoardDefaultsBoardDefaultIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.boardDefault),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Agreement Type Board Defaults Count
         * @param id
         * @param conditions
         */
        public financeAgreementTypesIdBoardDefaultsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/agreementTypes/{id}/boardDefaults/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementTypesIdBoardDefaultsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Agreement Type Board Defaults
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeAgreementTypesIdBoardDefaultsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AgreementTypeBoardDefault>> {
            const localVarPath = this.basePath + '/finance/agreementTypes/{id}/boardDefaults'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementTypesIdBoardDefaultsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Agreement Type Board Default
         * @param id
         * @param boardDefault
         */
        public financeAgreementTypesIdBoardDefaultsPost (params: {  id: number; boardDefault: AgreementTypeBoardDefault; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementTypeBoardDefault> {
            const localVarPath = this.basePath + '/finance/agreementTypes/{id}/boardDefaults'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementTypesIdBoardDefaultsPost');
            }
            // verify required parameter 'boardDefault' is set
            if (params.boardDefault == null) {
                throw new Error('Missing required parameter boardDefault when calling financeAgreementTypesIdBoardDefaultsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.boardDefault),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AgreementTypeWorkRoleExclusionsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Work Role Exclusions Count
         * @param id
         * @param conditions
         */
        public financeAgreementTypesIdWorkRoleExclusionsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/agreementTypes/{id}/workRoleExclusions/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementTypesIdWorkRoleExclusionsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Work Role Exclusions
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeAgreementTypesIdWorkRoleExclusionsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AgreementTypeWorkRoleExclusion>> {
            const localVarPath = this.basePath + '/finance/agreementTypes/{id}/workRoleExclusions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementTypesIdWorkRoleExclusionsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Work Role Exclusion
         * @param id
         * @param workRoleExclusion
         */
        public financeAgreementTypesIdWorkRoleExclusionsPost (params: {  id: number; workRoleExclusion: AgreementTypeWorkRoleExclusion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementTypeWorkRoleExclusion> {
            const localVarPath = this.basePath + '/finance/agreementTypes/{id}/workRoleExclusions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementTypesIdWorkRoleExclusionsPost');
            }
            // verify required parameter 'workRoleExclusion' is set
            if (params.workRoleExclusion == null) {
                throw new Error('Missing required parameter workRoleExclusion when calling financeAgreementTypesIdWorkRoleExclusionsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.workRoleExclusion),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Work Role Exclusion By Id
         * @param id
         * @param workRoleExclusionId
         */
        public financeAgreementTypesIdWorkRoleExclusionsWorkRoleExclusionIdDelete (params: {  id: number; workRoleExclusionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/agreementTypes/{id}/workRoleExclusions/{workRoleExclusionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'workRoleExclusionId' + '}', String(params.workRoleExclusionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementTypesIdWorkRoleExclusionsWorkRoleExclusionIdDelete');
            }
            // verify required parameter 'workRoleExclusionId' is set
            if (params.workRoleExclusionId == null) {
                throw new Error('Missing required parameter workRoleExclusionId when calling financeAgreementTypesIdWorkRoleExclusionsWorkRoleExclusionIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Work Role Exclusion By Id
         * @param id
         * @param workRoleExclusionId
         */
        public financeAgreementTypesIdWorkRoleExclusionsWorkRoleExclusionIdGet (params: {  id: number; workRoleExclusionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementTypeWorkRoleExclusion> {
            const localVarPath = this.basePath + '/finance/agreementTypes/{id}/workRoleExclusions/{workRoleExclusionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'workRoleExclusionId' + '}', String(params.workRoleExclusionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementTypesIdWorkRoleExclusionsWorkRoleExclusionIdGet');
            }
            // verify required parameter 'workRoleExclusionId' is set
            if (params.workRoleExclusionId == null) {
                throw new Error('Missing required parameter workRoleExclusionId when calling financeAgreementTypesIdWorkRoleExclusionsWorkRoleExclusionIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AgreementTypeWorkRolesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Work Roles Count
         * @param id
         * @param conditions
         */
        public financeAgreementTypesIdWorkrolesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/agreementTypes/{id}/workroles/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementTypesIdWorkrolesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Work Roles
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeAgreementTypesIdWorkrolesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AgreementTypeWorkRole>> {
            const localVarPath = this.basePath + '/finance/agreementTypes/{id}/workroles'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementTypesIdWorkrolesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Work Role
         * @param id
         * @param workRole
         */
        public financeAgreementTypesIdWorkrolesPost (params: {  id: number; workRole: AgreementTypeWorkRole; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementTypeWorkRole> {
            const localVarPath = this.basePath + '/finance/agreementTypes/{id}/workroles'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementTypesIdWorkrolesPost');
            }
            // verify required parameter 'workRole' is set
            if (params.workRole == null) {
                throw new Error('Missing required parameter workRole when calling financeAgreementTypesIdWorkrolesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.workRole),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Work Role By Id
         * @param id
         * @param workRoleId
         */
        public financeAgreementTypesIdWorkrolesWorkRoleIdDelete (params: {  id: number; workRoleId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/agreementTypes/{id}/workroles/{workRoleId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'workRoleId' + '}', String(params.workRoleId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementTypesIdWorkrolesWorkRoleIdDelete');
            }
            // verify required parameter 'workRoleId' is set
            if (params.workRoleId == null) {
                throw new Error('Missing required parameter workRoleId when calling financeAgreementTypesIdWorkrolesWorkRoleIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Work Role By Id
         * @param id
         * @param workRoleId
         */
        public financeAgreementTypesIdWorkrolesWorkRoleIdGet (params: {  id: number; workRoleId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementTypeWorkRole> {
            const localVarPath = this.basePath + '/finance/agreementTypes/{id}/workroles/{workRoleId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'workRoleId' + '}', String(params.workRoleId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementTypesIdWorkrolesWorkRoleIdGet');
            }
            // verify required parameter 'workRoleId' is set
            if (params.workRoleId == null) {
                throw new Error('Missing required parameter workRoleId when calling financeAgreementTypesIdWorkrolesWorkRoleIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Work Role
         * @param id
         * @param workRoleId
         * @param operations
         */
        public financeAgreementTypesIdWorkrolesWorkRoleIdPatch (params: {  id: number; workRoleId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementTypeWorkRole> {
            const localVarPath = this.basePath + '/finance/agreementTypes/{id}/workroles/{workRoleId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'workRoleId' + '}', String(params.workRoleId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementTypesIdWorkrolesWorkRoleIdPatch');
            }
            // verify required parameter 'workRoleId' is set
            if (params.workRoleId == null) {
                throw new Error('Missing required parameter workRoleId when calling financeAgreementTypesIdWorkrolesWorkRoleIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeAgreementTypesIdWorkrolesWorkRoleIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Work Role
         * @param id
         * @param workRoleId
         * @param workRole
         */
        public financeAgreementTypesIdWorkrolesWorkRoleIdPut (params: {  id: number; workRoleId: number; workRole: AgreementTypeWorkRole; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementTypeWorkRole> {
            const localVarPath = this.basePath + '/finance/agreementTypes/{id}/workroles/{workRoleId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'workRoleId' + '}', String(params.workRoleId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementTypesIdWorkrolesWorkRoleIdPut');
            }
            // verify required parameter 'workRoleId' is set
            if (params.workRoleId == null) {
                throw new Error('Missing required parameter workRoleId when calling financeAgreementTypesIdWorkrolesWorkRoleIdPut');
            }
            // verify required parameter 'workRole' is set
            if (params.workRole == null) {
                throw new Error('Missing required parameter workRole when calling financeAgreementTypesIdWorkrolesWorkRoleIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.workRole),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AgreementTypeWorkTypeExclusionsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Work Type Exclusions Count
         * @param id
         * @param conditions
         */
        public financeAgreementTypesIdWorkTypeExclusionsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/agreementTypes/{id}/workTypeExclusions/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementTypesIdWorkTypeExclusionsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Work Type Exclusions
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeAgreementTypesIdWorkTypeExclusionsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AgreementTypeWorkTypeExclusion>> {
            const localVarPath = this.basePath + '/finance/agreementTypes/{id}/workTypeExclusions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementTypesIdWorkTypeExclusionsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Work Type Exclusion
         * @param id
         * @param workTypeExclusion
         */
        public financeAgreementTypesIdWorkTypeExclusionsPost (params: {  id: number; workTypeExclusion: AgreementTypeWorkTypeExclusion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementTypeWorkTypeExclusion> {
            const localVarPath = this.basePath + '/finance/agreementTypes/{id}/workTypeExclusions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementTypesIdWorkTypeExclusionsPost');
            }
            // verify required parameter 'workTypeExclusion' is set
            if (params.workTypeExclusion == null) {
                throw new Error('Missing required parameter workTypeExclusion when calling financeAgreementTypesIdWorkTypeExclusionsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.workTypeExclusion),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Work Type Exclusion By Id
         * @param id
         * @param workTypeExclusionId
         */
        public financeAgreementTypesIdWorkTypeExclusionsWorkTypeExclusionIdDelete (params: {  id: number; workTypeExclusionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/agreementTypes/{id}/workTypeExclusions/{workTypeExclusionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'workTypeExclusionId' + '}', String(params.workTypeExclusionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementTypesIdWorkTypeExclusionsWorkTypeExclusionIdDelete');
            }
            // verify required parameter 'workTypeExclusionId' is set
            if (params.workTypeExclusionId == null) {
                throw new Error('Missing required parameter workTypeExclusionId when calling financeAgreementTypesIdWorkTypeExclusionsWorkTypeExclusionIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Work Type Exclusion By Id
         * @param id
         * @param workTypeExclusionId
         */
        public financeAgreementTypesIdWorkTypeExclusionsWorkTypeExclusionIdGet (params: {  id: number; workTypeExclusionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementTypeWorkTypeExclusion> {
            const localVarPath = this.basePath + '/finance/agreementTypes/{id}/workTypeExclusions/{workTypeExclusionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'workTypeExclusionId' + '}', String(params.workTypeExclusionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementTypesIdWorkTypeExclusionsWorkTypeExclusionIdGet');
            }
            // verify required parameter 'workTypeExclusionId' is set
            if (params.workTypeExclusionId == null) {
                throw new Error('Missing required parameter workTypeExclusionId when calling financeAgreementTypesIdWorkTypeExclusionsWorkTypeExclusionIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AgreementTypeWorkTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Work Types Count
         * @param id
         * @param conditions
         */
        public financeAgreementTypesIdWorktypesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/agreementTypes/{id}/worktypes/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementTypesIdWorktypesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Work Types
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeAgreementTypesIdWorktypesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AgreementTypeWorkType>> {
            const localVarPath = this.basePath + '/finance/agreementTypes/{id}/worktypes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementTypesIdWorktypesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Work Type
         * @param id
         * @param workType
         */
        public financeAgreementTypesIdWorktypesPost (params: {  id: number; workType: AgreementTypeWorkType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementTypeWorkType> {
            const localVarPath = this.basePath + '/finance/agreementTypes/{id}/worktypes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementTypesIdWorktypesPost');
            }
            // verify required parameter 'workType' is set
            if (params.workType == null) {
                throw new Error('Missing required parameter workType when calling financeAgreementTypesIdWorktypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.workType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Work Type By Id
         * @param id
         * @param worktypeId
         */
        public financeAgreementTypesIdWorktypesWorktypeIdDelete (params: {  id: number; worktypeId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/agreementTypes/{id}/worktypes/{worktypeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'worktypeId' + '}', String(params.worktypeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementTypesIdWorktypesWorktypeIdDelete');
            }
            // verify required parameter 'worktypeId' is set
            if (params.worktypeId == null) {
                throw new Error('Missing required parameter worktypeId when calling financeAgreementTypesIdWorktypesWorktypeIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Work Type By Id
         * @param id
         * @param worktypeId
         */
        public financeAgreementTypesIdWorktypesWorktypeIdGet (params: {  id: number; worktypeId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementTypeWorkType> {
            const localVarPath = this.basePath + '/finance/agreementTypes/{id}/worktypes/{worktypeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'worktypeId' + '}', String(params.worktypeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementTypesIdWorktypesWorktypeIdGet');
            }
            // verify required parameter 'worktypeId' is set
            if (params.worktypeId == null) {
                throw new Error('Missing required parameter worktypeId when calling financeAgreementTypesIdWorktypesWorktypeIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Work Type
         * @param id
         * @param worktypeId
         * @param operations
         */
        public financeAgreementTypesIdWorktypesWorktypeIdPatch (params: {  id: number; worktypeId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementTypeWorkType> {
            const localVarPath = this.basePath + '/finance/agreementTypes/{id}/worktypes/{worktypeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'worktypeId' + '}', String(params.worktypeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementTypesIdWorktypesWorktypeIdPatch');
            }
            // verify required parameter 'worktypeId' is set
            if (params.worktypeId == null) {
                throw new Error('Missing required parameter worktypeId when calling financeAgreementTypesIdWorktypesWorktypeIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeAgreementTypesIdWorktypesWorktypeIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Work Type
         * @param id
         * @param worktypeId
         * @param workType
         */
        public financeAgreementTypesIdWorktypesWorktypeIdPut (params: {  id: number; worktypeId: number; workType: AgreementTypeWorkType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementTypeWorkType> {
            const localVarPath = this.basePath + '/finance/agreementTypes/{id}/worktypes/{worktypeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'worktypeId' + '}', String(params.worktypeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementTypesIdWorktypesWorktypeIdPut');
            }
            // verify required parameter 'worktypeId' is set
            if (params.worktypeId == null) {
                throw new Error('Missing required parameter worktypeId when calling financeAgreementTypesIdWorktypesWorktypeIdPut');
            }
            // verify required parameter 'workType' is set
            if (params.workType == null) {
                throw new Error('Missing required parameter workType when calling financeAgreementTypesIdWorktypesWorktypeIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.workType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AgreementTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Agreement Types Count
         * @param conditions
         */
        public financeAgreementsTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/agreements/types/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Agreement Types
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeAgreementsTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AgreementType>> {
            const localVarPath = this.basePath + '/finance/agreements/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Agreement Type By Id
         * @param id
         */
        public financeAgreementsTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/agreements/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsTypesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Agreement Type By Id
         * @param id
         */
        public financeAgreementsTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementType> {
            const localVarPath = this.basePath + '/finance/agreements/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsTypesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Agreement Type
         * @param id
         * @param operations
         */
        public financeAgreementsTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementType> {
            const localVarPath = this.basePath + '/finance/agreements/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsTypesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeAgreementsTypesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Agreement Type
         * @param id
         * @param agreementType
         */
        public financeAgreementsTypesIdPut (params: {  id: number; agreementType: AgreementType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementType> {
            const localVarPath = this.basePath + '/finance/agreements/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsTypesIdPut');
            }
            // verify required parameter 'agreementType' is set
            if (params.agreementType == null) {
                throw new Error('Missing required parameter agreementType when calling financeAgreementsTypesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.agreementType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Agreement Type
         * @param agreementType
         */
        public financeAgreementsTypesPost (params: {  agreementType: AgreementType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementType> {
            const localVarPath = this.basePath + '/finance/agreements/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'agreementType' is set
            if (params.agreementType == null) {
                throw new Error('Missing required parameter agreementType when calling financeAgreementsTypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.agreementType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AgreementWorkRoleExclusionsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Work Role Exclusions Count
         * @param id
         * @param conditions
         */
        public financeAgreementsIdWorkRoleExclusionsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/workRoleExclusions/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorkRoleExclusionsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Work Role Exclusions
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeAgreementsIdWorkRoleExclusionsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AgreementWorkRoleExclusion>> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/workRoleExclusions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorkRoleExclusionsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Work Role Exclusion
         * @param id
         * @param workRoleExclusion
         */
        public financeAgreementsIdWorkRoleExclusionsPost (params: {  id: number; workRoleExclusion: AgreementWorkRoleExclusion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementWorkRoleExclusion> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/workRoleExclusions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorkRoleExclusionsPost');
            }
            // verify required parameter 'workRoleExclusion' is set
            if (params.workRoleExclusion == null) {
                throw new Error('Missing required parameter workRoleExclusion when calling financeAgreementsIdWorkRoleExclusionsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.workRoleExclusion),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Work Role Exclusion By Id
         * @param id
         * @param workRoleExclusionId
         */
        public financeAgreementsIdWorkRoleExclusionsWorkRoleExclusionIdDelete (params: {  id: number; workRoleExclusionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/workRoleExclusions/{workRoleExclusionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'workRoleExclusionId' + '}', String(params.workRoleExclusionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorkRoleExclusionsWorkRoleExclusionIdDelete');
            }
            // verify required parameter 'workRoleExclusionId' is set
            if (params.workRoleExclusionId == null) {
                throw new Error('Missing required parameter workRoleExclusionId when calling financeAgreementsIdWorkRoleExclusionsWorkRoleExclusionIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AgreementWorkRolesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Work Roles Count
         * @param id
         * @param conditions
         */
        public financeAgreementsIdWorkrolesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/workroles/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorkrolesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Work Roles
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeAgreementsIdWorkrolesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AgreementWorkRole>> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/workroles'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorkrolesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Work Role
         * @param id
         * @param workRole
         */
        public financeAgreementsIdWorkrolesPost (params: {  id: number; workRole: AgreementWorkRole; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementWorkRole> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/workroles'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorkrolesPost');
            }
            // verify required parameter 'workRole' is set
            if (params.workRole == null) {
                throw new Error('Missing required parameter workRole when calling financeAgreementsIdWorkrolesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.workRole),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Work Role By Id
         * @param id
         * @param workRoleId
         */
        public financeAgreementsIdWorkrolesWorkRoleIdDelete (params: {  id: number; workRoleId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/workroles/{workRoleId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'workRoleId' + '}', String(params.workRoleId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorkrolesWorkRoleIdDelete');
            }
            // verify required parameter 'workRoleId' is set
            if (params.workRoleId == null) {
                throw new Error('Missing required parameter workRoleId when calling financeAgreementsIdWorkrolesWorkRoleIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Work Role By Id
         * @param id
         * @param workRoleId
         */
        public financeAgreementsIdWorkrolesWorkRoleIdGet (params: {  id: number; workRoleId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementWorkRole> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/workroles/{workRoleId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'workRoleId' + '}', String(params.workRoleId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorkrolesWorkRoleIdGet');
            }
            // verify required parameter 'workRoleId' is set
            if (params.workRoleId == null) {
                throw new Error('Missing required parameter workRoleId when calling financeAgreementsIdWorkrolesWorkRoleIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Work Role
         * @param id
         * @param workRoleId
         * @param operations
         */
        public financeAgreementsIdWorkrolesWorkRoleIdPatch (params: {  id: number; workRoleId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementWorkRole> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/workroles/{workRoleId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'workRoleId' + '}', String(params.workRoleId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorkrolesWorkRoleIdPatch');
            }
            // verify required parameter 'workRoleId' is set
            if (params.workRoleId == null) {
                throw new Error('Missing required parameter workRoleId when calling financeAgreementsIdWorkrolesWorkRoleIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeAgreementsIdWorkrolesWorkRoleIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Work Role
         * @param id
         * @param workRoleId
         * @param workRole
         */
        public financeAgreementsIdWorkrolesWorkRoleIdPut (params: {  id: number; workRoleId: number; workRole: AgreementWorkRole; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementWorkRole> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/workroles/{workRoleId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'workRoleId' + '}', String(params.workRoleId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorkrolesWorkRoleIdPut');
            }
            // verify required parameter 'workRoleId' is set
            if (params.workRoleId == null) {
                throw new Error('Missing required parameter workRoleId when calling financeAgreementsIdWorkrolesWorkRoleIdPut');
            }
            // verify required parameter 'workRole' is set
            if (params.workRole == null) {
                throw new Error('Missing required parameter workRole when calling financeAgreementsIdWorkrolesWorkRoleIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.workRole),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AgreementWorkTypeExclusionsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Work Type Exclusions Count
         * @param id
         * @param conditions
         */
        public financeAgreementsIdWorkTypeExclusionsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/workTypeExclusions/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorkTypeExclusionsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Work Type Exclusions
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeAgreementsIdWorkTypeExclusionsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AgreementWorkTypeExclusion>> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/workTypeExclusions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorkTypeExclusionsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Work Type Exclusion
         * @param id
         * @param workTypeExclusion
         */
        public financeAgreementsIdWorkTypeExclusionsPost (params: {  id: number; workTypeExclusion: AgreementWorkTypeExclusion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementWorkTypeExclusion> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/workTypeExclusions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorkTypeExclusionsPost');
            }
            // verify required parameter 'workTypeExclusion' is set
            if (params.workTypeExclusion == null) {
                throw new Error('Missing required parameter workTypeExclusion when calling financeAgreementsIdWorkTypeExclusionsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.workTypeExclusion),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Work Type Exclusion By Id
         * @param id
         * @param workTypeExclusionId
         */
        public financeAgreementsIdWorkTypeExclusionsWorkTypeExclusionIdDelete (params: {  id: number; workTypeExclusionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/workTypeExclusions/{workTypeExclusionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'workTypeExclusionId' + '}', String(params.workTypeExclusionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorkTypeExclusionsWorkTypeExclusionIdDelete');
            }
            // verify required parameter 'workTypeExclusionId' is set
            if (params.workTypeExclusionId == null) {
                throw new Error('Missing required parameter workTypeExclusionId when calling financeAgreementsIdWorkTypeExclusionsWorkTypeExclusionIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AgreementWorkTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Work Types Count
         * @param id
         * @param conditions
         */
        public financeAgreementsIdWorktypesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/worktypes/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorktypesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Work Types
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeAgreementsIdWorktypesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AgreementWorkType>> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/worktypes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorktypesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Work Type
         * @param id
         * @param workType
         */
        public financeAgreementsIdWorktypesPost (params: {  id: number; workType: AgreementWorkType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementWorkType> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/worktypes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorktypesPost');
            }
            // verify required parameter 'workType' is set
            if (params.workType == null) {
                throw new Error('Missing required parameter workType when calling financeAgreementsIdWorktypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.workType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Work Type By Id
         * @param id
         * @param worktypeId
         */
        public financeAgreementsIdWorktypesWorktypeIdDelete (params: {  id: number; worktypeId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/worktypes/{worktypeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'worktypeId' + '}', String(params.worktypeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorktypesWorktypeIdDelete');
            }
            // verify required parameter 'worktypeId' is set
            if (params.worktypeId == null) {
                throw new Error('Missing required parameter worktypeId when calling financeAgreementsIdWorktypesWorktypeIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Work Type By Id
         * @param id
         * @param worktypeId
         */
        public financeAgreementsIdWorktypesWorktypeIdGet (params: {  id: number; worktypeId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementWorkType> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/worktypes/{worktypeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'worktypeId' + '}', String(params.worktypeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorktypesWorktypeIdGet');
            }
            // verify required parameter 'worktypeId' is set
            if (params.worktypeId == null) {
                throw new Error('Missing required parameter worktypeId when calling financeAgreementsIdWorktypesWorktypeIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Work Type
         * @param id
         * @param worktypeId
         * @param operations
         */
        public financeAgreementsIdWorktypesWorktypeIdPatch (params: {  id: number; worktypeId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementWorkType> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/worktypes/{worktypeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'worktypeId' + '}', String(params.worktypeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorktypesWorktypeIdPatch');
            }
            // verify required parameter 'worktypeId' is set
            if (params.worktypeId == null) {
                throw new Error('Missing required parameter worktypeId when calling financeAgreementsIdWorktypesWorktypeIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeAgreementsIdWorktypesWorktypeIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Work Type
         * @param id
         * @param worktypeId
         * @param workType
         */
        public financeAgreementsIdWorktypesWorktypeIdPut (params: {  id: number; worktypeId: number; workType: AgreementWorkType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementWorkType> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/worktypes/{worktypeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'worktypeId' + '}', String(params.worktypeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdWorktypesWorktypeIdPut');
            }
            // verify required parameter 'worktypeId' is set
            if (params.worktypeId == null) {
                throw new Error('Missing required parameter worktypeId when calling financeAgreementsIdWorktypesWorktypeIdPut');
            }
            // verify required parameter 'workType' is set
            if (params.workType == null) {
                throw new Error('Missing required parameter workType when calling financeAgreementsIdWorktypesWorktypeIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.workType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AgreementsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Agreements Count
         * @param conditions
         * @param customFieldConditions
         */
        public financeAgreementsCountGet (params: {  conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/agreements/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.customFieldConditions !== undefined) {
                queryParameters['customFieldConditions'] = params.customFieldConditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Agreements
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeAgreementsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Agreement>> {
            const localVarPath = this.basePath + '/finance/agreements';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Configuration Association
         * @param id
         * @param configurationId
         */
        public financeAgreementsIdConfigurationsConfigurationIdDelete (params: {  id: number; configurationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/configurations/{configurationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'configurationId' + '}', String(params.configurationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdConfigurationsConfigurationIdDelete');
            }
            // verify required parameter 'configurationId' is set
            if (params.configurationId == null) {
                throw new Error('Missing required parameter configurationId when calling financeAgreementsIdConfigurationsConfigurationIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Configuration Association
         * @param id
         * @param configurationId
         */
        public financeAgreementsIdConfigurationsConfigurationIdGet (params: {  id: number; configurationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationReference> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/configurations/{configurationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'configurationId' + '}', String(params.configurationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdConfigurationsConfigurationIdGet');
            }
            // verify required parameter 'configurationId' is set
            if (params.configurationId == null) {
                throw new Error('Missing required parameter configurationId when calling financeAgreementsIdConfigurationsConfigurationIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Agreement Configurations Count
         * @param id
         */
        public financeAgreementsIdConfigurationsCountGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/configurations/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdConfigurationsCountGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Agreement Configurations
         * @param id
         * @param page
         * @param pageSize
         */
        public financeAgreementsIdConfigurationsGet (params: {  id: number; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ConfigurationReference>> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/configurations'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdConfigurationsGet');
            }
            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Configuration Association
         * @param id
         * @param configuration
         */
        public financeAgreementsIdConfigurationsPost (params: {  id: number; configuration: ConfigurationReference; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationReference> {
            const localVarPath = this.basePath + '/finance/agreements/{id}/configurations'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdConfigurationsPost');
            }
            // verify required parameter 'configuration' is set
            if (params.configuration == null) {
                throw new Error('Missing required parameter configuration when calling financeAgreementsIdConfigurationsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.configuration),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Agreement By Id
         * @param id
         */
        public financeAgreementsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/agreements/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Agreement By Id
         * @param id
         */
        public financeAgreementsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Agreement> {
            const localVarPath = this.basePath + '/finance/agreements/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Agreement
         * @param id
         * @param operations
         */
        public financeAgreementsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Agreement> {
            const localVarPath = this.basePath + '/finance/agreements/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeAgreementsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Agreement
         * @param id
         * @param agreement
         */
        public financeAgreementsIdPut (params: {  id: number; agreement: Agreement; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Agreement> {
            const localVarPath = this.basePath + '/finance/agreements/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeAgreementsIdPut');
            }
            // verify required parameter 'agreement' is set
            if (params.agreement == null) {
                throw new Error('Missing required parameter agreement when calling financeAgreementsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.agreement),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Agreement
         * @param agreement
         */
        public financeAgreementsPost (params: {  agreement: Agreement; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Agreement> {
            const localVarPath = this.basePath + '/finance/agreements';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'agreement' is set
            if (params.agreement == null) {
                throw new Error('Missing required parameter agreement when calling financeAgreementsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.agreement),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AuditTrailApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Members Count
         * @param type
         * @param id
         * @param deviceIdentifier
         */
        public systemAudittrailCountGet (params: {  type?: string; id?: number; deviceIdentifier?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/audittrail/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.type !== undefined) {
                queryParameters['type'] = params.type;
            }

            if (params.id !== undefined) {
                queryParameters['id'] = params.id;
            }

            if (params.deviceIdentifier !== undefined) {
                queryParameters['deviceIdentifier'] = params.deviceIdentifier;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Audit Trail
         * @param type
         * @param id
         * @param deviceIdentifier
         * @param page
         * @param pageSize
         */
        public systemAudittrailGet (params: {  type?: string; id?: number; deviceIdentifier?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AuditTrailEntry>> {
            const localVarPath = this.basePath + '/system/audittrail';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.type !== undefined) {
                queryParameters['type'] = params.type;
            }

            if (params.id !== undefined) {
                queryParameters['id'] = params.id;
            }

            if (params.deviceIdentifier !== undefined) {
                queryParameters['deviceIdentifier'] = params.deviceIdentifier;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AuthAnvilsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Auth Anvil Count
         * @param conditions
         */
        public systemAuthAnvilsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/authAnvils/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Auth Anvils
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemAuthAnvilsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AuthAnvil>> {
            const localVarPath = this.basePath + '/system/authAnvils';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Auth Anvil By Id
         * @param id
         */
        public systemAuthAnvilsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AuthAnvil> {
            const localVarPath = this.basePath + '/system/authAnvils/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemAuthAnvilsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Auth Anvil
         * @param id
         * @param operations
         */
        public systemAuthAnvilsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AuthAnvil> {
            const localVarPath = this.basePath + '/system/authAnvils/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemAuthAnvilsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemAuthAnvilsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Auth Anvil
         * @param id
         * @param authAnvil
         */
        public systemAuthAnvilsIdPut (params: {  id: number; authAnvil: AuthAnvil; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AuthAnvil> {
            const localVarPath = this.basePath + '/system/authAnvils/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemAuthAnvilsIdPut');
            }
            // verify required parameter 'authAnvil' is set
            if (params.authAnvil == null) {
                throw new Error('Missing required parameter authAnvil when calling systemAuthAnvilsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.authAnvil),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Validate Auth Anvil Url Connectivity
         */
        public systemAuthAnvilsTestConnectionGet (params: {  }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SuccessResponse> {
            const localVarPath = this.basePath + '/system/authAnvils/testConnection';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BatchApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Process Batch Requests
         * @param request
         */
        public systemBatchPost (params: {  request: BatchRequest; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BatchResponse> {
            const localVarPath = this.basePath + '/system/batch';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'request' is set
            if (params.request == null) {
                throw new Error('Missing required parameter request when calling systemBatchPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.request),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BillingCyclesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Billing Cycles Count
         * @param conditions
         */
        public financeBillingCyclesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/billingCycles/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Billing Cycles
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeBillingCyclesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<BillingCycle>> {
            const localVarPath = this.basePath + '/finance/billingCycles';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Billing Cycle By Id
         * @param id
         */
        public financeBillingCyclesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BillingCycle> {
            const localVarPath = this.basePath + '/finance/billingCycles/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeBillingCyclesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BillingSetupRoutingsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Billing Setup Routings Count
         * @param id
         * @param conditions
         */
        public financeBillingSetupsIdRoutingsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/billingSetups/{id}/routings/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeBillingSetupsIdRoutingsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Billing Setup Routings
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeBillingSetupsIdRoutingsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<BillingSetupRouting>> {
            const localVarPath = this.basePath + '/finance/billingSetups/{id}/routings'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeBillingSetupsIdRoutingsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Billing Setup Routing
         * @param id
         * @param billingSetupRouting
         */
        public financeBillingSetupsIdRoutingsPost (params: {  id: number; billingSetupRouting: BillingSetupRouting; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BillingSetupRouting> {
            const localVarPath = this.basePath + '/finance/billingSetups/{id}/routings'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeBillingSetupsIdRoutingsPost');
            }
            // verify required parameter 'billingSetupRouting' is set
            if (params.billingSetupRouting == null) {
                throw new Error('Missing required parameter billingSetupRouting when calling financeBillingSetupsIdRoutingsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.billingSetupRouting),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Billing Setup Routing By Id
         * @param id
         * @param routingId
         */
        public financeBillingSetupsIdRoutingsRoutingIdDelete (params: {  id: number; routingId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/billingSetups/{id}/routings/{routingId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'routingId' + '}', String(params.routingId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeBillingSetupsIdRoutingsRoutingIdDelete');
            }
            // verify required parameter 'routingId' is set
            if (params.routingId == null) {
                throw new Error('Missing required parameter routingId when calling financeBillingSetupsIdRoutingsRoutingIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Billing Setup Routing By Id
         * @param id
         * @param routingId
         */
        public financeBillingSetupsIdRoutingsRoutingIdGet (params: {  id: number; routingId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BillingSetupRouting> {
            const localVarPath = this.basePath + '/finance/billingSetups/{id}/routings/{routingId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'routingId' + '}', String(params.routingId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeBillingSetupsIdRoutingsRoutingIdGet');
            }
            // verify required parameter 'routingId' is set
            if (params.routingId == null) {
                throw new Error('Missing required parameter routingId when calling financeBillingSetupsIdRoutingsRoutingIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Billing Setup Routing
         * @param id
         * @param routingId
         * @param operations
         */
        public financeBillingSetupsIdRoutingsRoutingIdPatch (params: {  id: number; routingId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BillingSetupRouting> {
            const localVarPath = this.basePath + '/finance/billingSetups/{id}/routings/{routingId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'routingId' + '}', String(params.routingId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeBillingSetupsIdRoutingsRoutingIdPatch');
            }
            // verify required parameter 'routingId' is set
            if (params.routingId == null) {
                throw new Error('Missing required parameter routingId when calling financeBillingSetupsIdRoutingsRoutingIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeBillingSetupsIdRoutingsRoutingIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Billing Setup Routing
         * @param id
         * @param routingId
         * @param billingSetupRouting
         */
        public financeBillingSetupsIdRoutingsRoutingIdPut (params: {  id: number; routingId: number; billingSetupRouting: BillingSetupRouting; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BillingSetupRouting> {
            const localVarPath = this.basePath + '/finance/billingSetups/{id}/routings/{routingId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'routingId' + '}', String(params.routingId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeBillingSetupsIdRoutingsRoutingIdPut');
            }
            // verify required parameter 'routingId' is set
            if (params.routingId == null) {
                throw new Error('Missing required parameter routingId when calling financeBillingSetupsIdRoutingsRoutingIdPut');
            }
            // verify required parameter 'billingSetupRouting' is set
            if (params.billingSetupRouting == null) {
                throw new Error('Missing required parameter billingSetupRouting when calling financeBillingSetupsIdRoutingsRoutingIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.billingSetupRouting),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BillingSetupsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Billing Setups Count
         * @param conditions
         */
        public financeBillingSetupsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/billingSetups/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Billing Setups
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeBillingSetupsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<BillingSetup>> {
            const localVarPath = this.basePath + '/finance/billingSetups';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Billing Setup By Id
         * @param id
         */
        public financeBillingSetupsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/billingSetups/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeBillingSetupsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Billing Setup By Id
         * @param id
         */
        public financeBillingSetupsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BillingSetup> {
            const localVarPath = this.basePath + '/finance/billingSetups/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeBillingSetupsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Billing Setup
         * @param id
         * @param operations
         */
        public financeBillingSetupsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BillingSetup> {
            const localVarPath = this.basePath + '/finance/billingSetups/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeBillingSetupsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeBillingSetupsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Billing Setup
         * @param id
         * @param billingSetup
         */
        public financeBillingSetupsIdPut (params: {  id: number; billingSetup: BillingSetup; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BillingSetup> {
            const localVarPath = this.basePath + '/finance/billingSetups/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeBillingSetupsIdPut');
            }
            // verify required parameter 'billingSetup' is set
            if (params.billingSetup == null) {
                throw new Error('Missing required parameter billingSetup when calling financeBillingSetupsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.billingSetup),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Billing Setup
         * @param billingSetup
         */
        public financeBillingSetupsPost (params: {  billingSetup: BillingSetup; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BillingSetup> {
            const localVarPath = this.basePath + '/finance/billingSetups';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'billingSetup' is set
            if (params.billingSetup == null) {
                throw new Error('Missing required parameter billingSetup when calling financeBillingSetupsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.billingSetup),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BillingStatusesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Billing Statuses Count
         * @param conditions
         */
        public systemBillingStatusesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/billingStatuses/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Billing Statuses
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemBillingStatusesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<BillingStatus>> {
            const localVarPath = this.basePath + '/system/billingStatuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Billing Status By Id
         * @param id
         */
        public systemBillingStatusesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BillingStatus> {
            const localVarPath = this.basePath + '/system/billingStatuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemBillingStatusesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BillingTermsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Billing Terms Count
         * @param conditions
         */
        public financeBillingTermsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/billingTerms/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Billing Terms
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeBillingTermsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<BillingTerm>> {
            const localVarPath = this.basePath + '/finance/billingTerms';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Billing Term By Id
         * @param id
         */
        public financeBillingTermsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BillingTerm> {
            const localVarPath = this.basePath + '/finance/billingTerms/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeBillingTermsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BoardAutoAssignResourcesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Delete Board Auto Assign Resource By Id
         * @param id
         * @param autoAssignResourceId
         */
        public serviceBoardsIdAutoAssignResourcesAutoAssignResourceIdDelete (params: {  id: number; autoAssignResourceId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/boards/{id}/autoAssignResources/{autoAssignResourceId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'autoAssignResourceId' + '}', String(params.autoAssignResourceId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdAutoAssignResourcesAutoAssignResourceIdDelete');
            }
            // verify required parameter 'autoAssignResourceId' is set
            if (params.autoAssignResourceId == null) {
                throw new Error('Missing required parameter autoAssignResourceId when calling serviceBoardsIdAutoAssignResourcesAutoAssignResourceIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Board Auto Assign Resource By Id
         * @param id
         * @param autoAssignResourceId
         */
        public serviceBoardsIdAutoAssignResourcesAutoAssignResourceIdGet (params: {  id: number; autoAssignResourceId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardAutoAssignResource> {
            const localVarPath = this.basePath + '/service/boards/{id}/autoAssignResources/{autoAssignResourceId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'autoAssignResourceId' + '}', String(params.autoAssignResourceId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdAutoAssignResourcesAutoAssignResourceIdGet');
            }
            // verify required parameter 'autoAssignResourceId' is set
            if (params.autoAssignResourceId == null) {
                throw new Error('Missing required parameter autoAssignResourceId when calling serviceBoardsIdAutoAssignResourcesAutoAssignResourceIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Board Auto Assign Resource
         * @param id
         * @param autoAssignResourceId
         * @param operations
         */
        public serviceBoardsIdAutoAssignResourcesAutoAssignResourceIdPatch (params: {  id: number; autoAssignResourceId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardAutoAssignResource> {
            const localVarPath = this.basePath + '/service/boards/{id}/autoAssignResources/{autoAssignResourceId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'autoAssignResourceId' + '}', String(params.autoAssignResourceId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdAutoAssignResourcesAutoAssignResourceIdPatch');
            }
            // verify required parameter 'autoAssignResourceId' is set
            if (params.autoAssignResourceId == null) {
                throw new Error('Missing required parameter autoAssignResourceId when calling serviceBoardsIdAutoAssignResourcesAutoAssignResourceIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceBoardsIdAutoAssignResourcesAutoAssignResourceIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Board Auto Assign Resource
         * @param id
         * @param autoAssignResourceId
         * @param boardAutoAssignResource
         */
        public serviceBoardsIdAutoAssignResourcesAutoAssignResourceIdPut (params: {  id: number; autoAssignResourceId: number; boardAutoAssignResource: BoardAutoAssignResource; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardAutoAssignResource> {
            const localVarPath = this.basePath + '/service/boards/{id}/autoAssignResources/{autoAssignResourceId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'autoAssignResourceId' + '}', String(params.autoAssignResourceId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdAutoAssignResourcesAutoAssignResourceIdPut');
            }
            // verify required parameter 'autoAssignResourceId' is set
            if (params.autoAssignResourceId == null) {
                throw new Error('Missing required parameter autoAssignResourceId when calling serviceBoardsIdAutoAssignResourcesAutoAssignResourceIdPut');
            }
            // verify required parameter 'boardAutoAssignResource' is set
            if (params.boardAutoAssignResource == null) {
                throw new Error('Missing required parameter boardAutoAssignResource when calling serviceBoardsIdAutoAssignResourcesAutoAssignResourceIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.boardAutoAssignResource),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Board Auto Assign Resources Count
         * @param id
         * @param conditions
         */
        public serviceBoardsIdAutoAssignResourcesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/boards/{id}/autoAssignResources/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdAutoAssignResourcesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Board Auto Assign Resources
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceBoardsIdAutoAssignResourcesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<BoardAutoAssignResource>> {
            const localVarPath = this.basePath + '/service/boards/{id}/autoAssignResources'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdAutoAssignResourcesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Board Auto Assign Resource
         * @param id
         * @param boardAutoAssignResource
         */
        public serviceBoardsIdAutoAssignResourcesPost (params: {  id: number; boardAutoAssignResource: BoardAutoAssignResource; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardAutoAssignResource> {
            const localVarPath = this.basePath + '/service/boards/{id}/autoAssignResources'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdAutoAssignResourcesPost');
            }
            // verify required parameter 'boardAutoAssignResource' is set
            if (params.boardAutoAssignResource == null) {
                throw new Error('Missing required parameter boardAutoAssignResource when calling serviceBoardsIdAutoAssignResourcesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.boardAutoAssignResource),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BoardAutoTemplatesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Delete Auto Template By Id
         * @param id
         * @param autoTemplateId
         */
        public serviceBoardsIdAutoTemplatesAutoTemplateIdDelete (params: {  id: number; autoTemplateId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/boards/{id}/autoTemplates/{autoTemplateId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'autoTemplateId' + '}', String(params.autoTemplateId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdAutoTemplatesAutoTemplateIdDelete');
            }
            // verify required parameter 'autoTemplateId' is set
            if (params.autoTemplateId == null) {
                throw new Error('Missing required parameter autoTemplateId when calling serviceBoardsIdAutoTemplatesAutoTemplateIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Auto Template By Id
         * @param id
         * @param autoTemplateId
         */
        public serviceBoardsIdAutoTemplatesAutoTemplateIdGet (params: {  id: number; autoTemplateId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardAutoTemplate> {
            const localVarPath = this.basePath + '/service/boards/{id}/autoTemplates/{autoTemplateId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'autoTemplateId' + '}', String(params.autoTemplateId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdAutoTemplatesAutoTemplateIdGet');
            }
            // verify required parameter 'autoTemplateId' is set
            if (params.autoTemplateId == null) {
                throw new Error('Missing required parameter autoTemplateId when calling serviceBoardsIdAutoTemplatesAutoTemplateIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Auto Template
         * @param id
         * @param autoTemplateId
         * @param operations
         */
        public serviceBoardsIdAutoTemplatesAutoTemplateIdPatch (params: {  id: number; autoTemplateId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardAutoTemplate> {
            const localVarPath = this.basePath + '/service/boards/{id}/autoTemplates/{autoTemplateId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'autoTemplateId' + '}', String(params.autoTemplateId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdAutoTemplatesAutoTemplateIdPatch');
            }
            // verify required parameter 'autoTemplateId' is set
            if (params.autoTemplateId == null) {
                throw new Error('Missing required parameter autoTemplateId when calling serviceBoardsIdAutoTemplatesAutoTemplateIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceBoardsIdAutoTemplatesAutoTemplateIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Auto Template
         * @param id
         * @param autoTemplateId
         * @param boardAutoTemplate
         */
        public serviceBoardsIdAutoTemplatesAutoTemplateIdPut (params: {  id: number; autoTemplateId: number; boardAutoTemplate: BoardAutoTemplate; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardAutoTemplate> {
            const localVarPath = this.basePath + '/service/boards/{id}/autoTemplates/{autoTemplateId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'autoTemplateId' + '}', String(params.autoTemplateId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdAutoTemplatesAutoTemplateIdPut');
            }
            // verify required parameter 'autoTemplateId' is set
            if (params.autoTemplateId == null) {
                throw new Error('Missing required parameter autoTemplateId when calling serviceBoardsIdAutoTemplatesAutoTemplateIdPut');
            }
            // verify required parameter 'boardAutoTemplate' is set
            if (params.boardAutoTemplate == null) {
                throw new Error('Missing required parameter boardAutoTemplate when calling serviceBoardsIdAutoTemplatesAutoTemplateIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.boardAutoTemplate),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Auto Templates Count
         * @param id
         * @param conditions
         */
        public serviceBoardsIdAutoTemplatesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/boards/{id}/autoTemplates/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdAutoTemplatesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Auto Templates
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceBoardsIdAutoTemplatesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<BoardAutoTemplate>> {
            const localVarPath = this.basePath + '/service/boards/{id}/autoTemplates'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdAutoTemplatesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Auto Templates
         * @param id
         * @param boardAutoTemplate
         */
        public serviceBoardsIdAutoTemplatesPost (params: {  id: number; boardAutoTemplate: BoardAutoTemplate; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardAutoTemplate> {
            const localVarPath = this.basePath + '/service/boards/{id}/autoTemplates'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdAutoTemplatesPost');
            }
            // verify required parameter 'boardAutoTemplate' is set
            if (params.boardAutoTemplate == null) {
                throw new Error('Missing required parameter boardAutoTemplate when calling serviceBoardsIdAutoTemplatesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.boardAutoTemplate),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BoardExcludedMembersApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Excluded Members Count
         * @param id
         * @param conditions
         */
        public serviceBoardsIdExcludedMembersCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/boards/{id}/excludedMembers/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdExcludedMembersCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Excluded Member By Id
         * @param id
         * @param excludedMemberId
         */
        public serviceBoardsIdExcludedMembersExcludedMemberIdDelete (params: {  id: number; excludedMemberId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/boards/{id}/excludedMembers/{excludedMemberId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'excludedMemberId' + '}', String(params.excludedMemberId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdExcludedMembersExcludedMemberIdDelete');
            }
            // verify required parameter 'excludedMemberId' is set
            if (params.excludedMemberId == null) {
                throw new Error('Missing required parameter excludedMemberId when calling serviceBoardsIdExcludedMembersExcludedMemberIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Excluded Member By Id
         * @param id
         * @param excludedMemberId
         */
        public serviceBoardsIdExcludedMembersExcludedMemberIdGet (params: {  id: number; excludedMemberId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardExcludedMember> {
            const localVarPath = this.basePath + '/service/boards/{id}/excludedMembers/{excludedMemberId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'excludedMemberId' + '}', String(params.excludedMemberId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdExcludedMembersExcludedMemberIdGet');
            }
            // verify required parameter 'excludedMemberId' is set
            if (params.excludedMemberId == null) {
                throw new Error('Missing required parameter excludedMemberId when calling serviceBoardsIdExcludedMembersExcludedMemberIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Excluded Members
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceBoardsIdExcludedMembersGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<BoardExcludedMember>> {
            const localVarPath = this.basePath + '/service/boards/{id}/excludedMembers'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdExcludedMembersGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Excluded Member
         * @param id
         * @param boardExcludedMember
         */
        public serviceBoardsIdExcludedMembersPost (params: {  id: number; boardExcludedMember: BoardExcludedMember; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardExcludedMember> {
            const localVarPath = this.basePath + '/service/boards/{id}/excludedMembers'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdExcludedMembersPost');
            }
            // verify required parameter 'boardExcludedMember' is set
            if (params.boardExcludedMember == null) {
                throw new Error('Missing required parameter boardExcludedMember when calling serviceBoardsIdExcludedMembersPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.boardExcludedMember),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BoardItemAssociationsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Board Item Association By Id
         * @param boardId
         * @param itemId
         * @param associationId
         */
        public serviceBoardsBoardIdItemsItemIdAssociationsAssociationIdGet (params: {  boardId: number; itemId: number; associationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardItemAssociation> {
            const localVarPath = this.basePath + '/service/boards/{boardId}/items/{itemId}/associations/{associationId}'
                .replace('{' + 'boardId' + '}', String(params.boardId))
                .replace('{' + 'itemId' + '}', String(params.itemId))
                .replace('{' + 'associationId' + '}', String(params.associationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'boardId' is set
            if (params.boardId == null) {
                throw new Error('Missing required parameter boardId when calling serviceBoardsBoardIdItemsItemIdAssociationsAssociationIdGet');
            }
            // verify required parameter 'itemId' is set
            if (params.itemId == null) {
                throw new Error('Missing required parameter itemId when calling serviceBoardsBoardIdItemsItemIdAssociationsAssociationIdGet');
            }
            // verify required parameter 'associationId' is set
            if (params.associationId == null) {
                throw new Error('Missing required parameter associationId when calling serviceBoardsBoardIdItemsItemIdAssociationsAssociationIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Board Item Association Count
         * @param boardId
         * @param itemId
         * @param conditions
         */
        public serviceBoardsBoardIdItemsItemIdAssociationsCountGet (params: {  boardId: number; itemId: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/boards/{boardId}/items/{itemId}/associations/count'
                .replace('{' + 'boardId' + '}', String(params.boardId))
                .replace('{' + 'itemId' + '}', String(params.itemId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'boardId' is set
            if (params.boardId == null) {
                throw new Error('Missing required parameter boardId when calling serviceBoardsBoardIdItemsItemIdAssociationsCountGet');
            }
            // verify required parameter 'itemId' is set
            if (params.itemId == null) {
                throw new Error('Missing required parameter itemId when calling serviceBoardsBoardIdItemsItemIdAssociationsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Board Item Association
         * @param boardId
         * @param itemId
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceBoardsBoardIdItemsItemIdAssociationsGet (params: {  boardId: number; itemId: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<BoardItemAssociation>> {
            const localVarPath = this.basePath + '/service/boards/{boardId}/items/{itemId}/associations'
                .replace('{' + 'boardId' + '}', String(params.boardId))
                .replace('{' + 'itemId' + '}', String(params.itemId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'boardId' is set
            if (params.boardId == null) {
                throw new Error('Missing required parameter boardId when calling serviceBoardsBoardIdItemsItemIdAssociationsGet');
            }
            // verify required parameter 'itemId' is set
            if (params.itemId == null) {
                throw new Error('Missing required parameter itemId when calling serviceBoardsBoardIdItemsItemIdAssociationsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Board Item Association
         * @param boardId
         * @param itemId
         * @param id
         * @param itemAssociation
         */
        public serviceBoardsBoardIdItemsItemIdAssociationsIdPut (params: {  boardId: number; itemId: number; id: number; itemAssociation: BoardItemAssociation; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardItemAssociation> {
            const localVarPath = this.basePath + '/service/boards/{boardId}/items/{itemId}/associations/{id}'
                .replace('{' + 'boardId' + '}', String(params.boardId))
                .replace('{' + 'itemId' + '}', String(params.itemId))
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'boardId' is set
            if (params.boardId == null) {
                throw new Error('Missing required parameter boardId when calling serviceBoardsBoardIdItemsItemIdAssociationsIdPut');
            }
            // verify required parameter 'itemId' is set
            if (params.itemId == null) {
                throw new Error('Missing required parameter itemId when calling serviceBoardsBoardIdItemsItemIdAssociationsIdPut');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsBoardIdItemsItemIdAssociationsIdPut');
            }
            // verify required parameter 'itemAssociation' is set
            if (params.itemAssociation == null) {
                throw new Error('Missing required parameter itemAssociation when calling serviceBoardsBoardIdItemsItemIdAssociationsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.itemAssociation),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Board Item Association
         * @param boardId The recid of the Service/Project Board
         * @param itemId
         * @param typeId
         * @param operations
         */
        public serviceBoardsBoardIdItemsItemIdAssociationsTypeIdPatch (params: {  boardId: number; itemId: number; typeId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardItemAssociation> {
            const localVarPath = this.basePath + '/service/boards/{boardId}/items/{itemId}/associations/{typeId}'
                .replace('{' + 'boardId' + '}', String(params.boardId))
                .replace('{' + 'itemId' + '}', String(params.itemId))
                .replace('{' + 'typeId' + '}', String(params.typeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'boardId' is set
            if (params.boardId == null) {
                throw new Error('Missing required parameter boardId when calling serviceBoardsBoardIdItemsItemIdAssociationsTypeIdPatch');
            }
            // verify required parameter 'itemId' is set
            if (params.itemId == null) {
                throw new Error('Missing required parameter itemId when calling serviceBoardsBoardIdItemsItemIdAssociationsTypeIdPatch');
            }
            // verify required parameter 'typeId' is set
            if (params.typeId == null) {
                throw new Error('Missing required parameter typeId when calling serviceBoardsBoardIdItemsItemIdAssociationsTypeIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceBoardsBoardIdItemsItemIdAssociationsTypeIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BoardItemsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Items Count
         * @param id
         * @param conditions
         */
        public serviceBoardsIdItemsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/boards/{id}/items/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdItemsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Items
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceBoardsIdItemsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<BoardItem>> {
            const localVarPath = this.basePath + '/service/boards/{id}/items'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdItemsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Item By Id
         * @param id
         * @param itemId
         */
        public serviceBoardsIdItemsItemIdDelete (params: {  id: number; itemId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/boards/{id}/items/{itemId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'itemId' + '}', String(params.itemId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdItemsItemIdDelete');
            }
            // verify required parameter 'itemId' is set
            if (params.itemId == null) {
                throw new Error('Missing required parameter itemId when calling serviceBoardsIdItemsItemIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Item By Id
         * @param id
         * @param itemId
         */
        public serviceBoardsIdItemsItemIdGet (params: {  id: number; itemId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardItem> {
            const localVarPath = this.basePath + '/service/boards/{id}/items/{itemId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'itemId' + '}', String(params.itemId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdItemsItemIdGet');
            }
            // verify required parameter 'itemId' is set
            if (params.itemId == null) {
                throw new Error('Missing required parameter itemId when calling serviceBoardsIdItemsItemIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Item
         * @param id
         * @param itemId
         * @param operations
         */
        public serviceBoardsIdItemsItemIdPatch (params: {  id: number; itemId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardItem> {
            const localVarPath = this.basePath + '/service/boards/{id}/items/{itemId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'itemId' + '}', String(params.itemId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdItemsItemIdPatch');
            }
            // verify required parameter 'itemId' is set
            if (params.itemId == null) {
                throw new Error('Missing required parameter itemId when calling serviceBoardsIdItemsItemIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceBoardsIdItemsItemIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Item
         * @param id
         * @param itemId
         * @param boardItem
         */
        public serviceBoardsIdItemsItemIdPut (params: {  id: number; itemId: number; boardItem: BoardItem; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardItem> {
            const localVarPath = this.basePath + '/service/boards/{id}/items/{itemId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'itemId' + '}', String(params.itemId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdItemsItemIdPut');
            }
            // verify required parameter 'itemId' is set
            if (params.itemId == null) {
                throw new Error('Missing required parameter itemId when calling serviceBoardsIdItemsItemIdPut');
            }
            // verify required parameter 'boardItem' is set
            if (params.boardItem == null) {
                throw new Error('Missing required parameter boardItem when calling serviceBoardsIdItemsItemIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.boardItem),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Item
         * @param id
         * @param boardItem
         */
        public serviceBoardsIdItemsPost (params: {  id: number; boardItem: BoardItem; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardItem> {
            const localVarPath = this.basePath + '/service/boards/{id}/items'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdItemsPost');
            }
            // verify required parameter 'boardItem' is set
            if (params.boardItem == null) {
                throw new Error('Missing required parameter boardItem when calling serviceBoardsIdItemsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.boardItem),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BoardNotificationsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Board Notifications Count
         * @param id
         * @param conditions
         */
        public serviceBoardsIdNotificationsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/boards/{id}/notifications/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdNotificationsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Board Notifications
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceBoardsIdNotificationsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<BoardNotification>> {
            const localVarPath = this.basePath + '/service/boards/{id}/notifications'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdNotificationsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Board Notification By Id
         * @param id
         * @param notificationId
         */
        public serviceBoardsIdNotificationsNotificationIdDelete (params: {  id: number; notificationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/boards/{id}/notifications/{notificationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'notificationId' + '}', String(params.notificationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdNotificationsNotificationIdDelete');
            }
            // verify required parameter 'notificationId' is set
            if (params.notificationId == null) {
                throw new Error('Missing required parameter notificationId when calling serviceBoardsIdNotificationsNotificationIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Board Notification By Id
         * @param id
         * @param notificationId
         */
        public serviceBoardsIdNotificationsNotificationIdGet (params: {  id: number; notificationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardNotification> {
            const localVarPath = this.basePath + '/service/boards/{id}/notifications/{notificationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'notificationId' + '}', String(params.notificationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdNotificationsNotificationIdGet');
            }
            // verify required parameter 'notificationId' is set
            if (params.notificationId == null) {
                throw new Error('Missing required parameter notificationId when calling serviceBoardsIdNotificationsNotificationIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Board Notification
         * @param id
         * @param notificationId
         * @param operations
         */
        public serviceBoardsIdNotificationsNotificationIdPatch (params: {  id: number; notificationId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardNotification> {
            const localVarPath = this.basePath + '/service/boards/{id}/notifications/{notificationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'notificationId' + '}', String(params.notificationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdNotificationsNotificationIdPatch');
            }
            // verify required parameter 'notificationId' is set
            if (params.notificationId == null) {
                throw new Error('Missing required parameter notificationId when calling serviceBoardsIdNotificationsNotificationIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceBoardsIdNotificationsNotificationIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Board Notification
         * @param id
         * @param notificationId
         * @param boardNotification
         */
        public serviceBoardsIdNotificationsNotificationIdPut (params: {  id: number; notificationId: number; boardNotification: BoardNotification; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardNotification> {
            const localVarPath = this.basePath + '/service/boards/{id}/notifications/{notificationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'notificationId' + '}', String(params.notificationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdNotificationsNotificationIdPut');
            }
            // verify required parameter 'notificationId' is set
            if (params.notificationId == null) {
                throw new Error('Missing required parameter notificationId when calling serviceBoardsIdNotificationsNotificationIdPut');
            }
            // verify required parameter 'boardNotification' is set
            if (params.boardNotification == null) {
                throw new Error('Missing required parameter boardNotification when calling serviceBoardsIdNotificationsNotificationIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.boardNotification),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Board Notification
         * @param id
         * @param boardNotification
         */
        public serviceBoardsIdNotificationsPost (params: {  id: number; boardNotification: BoardNotification; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardNotification> {
            const localVarPath = this.basePath + '/service/boards/{id}/notifications'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdNotificationsPost');
            }
            // verify required parameter 'boardNotification' is set
            if (params.boardNotification == null) {
                throw new Error('Missing required parameter boardNotification when calling serviceBoardsIdNotificationsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.boardNotification),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BoardStatusNotificationsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Board Status Notifications Count
         * @param boardId
         * @param statusId
         * @param conditions
         */
        public serviceBoardsBoardIdStatusesStatusIdNotificationsCountGet (params: {  boardId: number; statusId: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/boards/{boardId}/statuses/{statusId}/notifications/count'
                .replace('{' + 'boardId' + '}', String(params.boardId))
                .replace('{' + 'statusId' + '}', String(params.statusId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'boardId' is set
            if (params.boardId == null) {
                throw new Error('Missing required parameter boardId when calling serviceBoardsBoardIdStatusesStatusIdNotificationsCountGet');
            }
            // verify required parameter 'statusId' is set
            if (params.statusId == null) {
                throw new Error('Missing required parameter statusId when calling serviceBoardsBoardIdStatusesStatusIdNotificationsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Board Status Notifications
         * @param boardId
         * @param statusId
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceBoardsBoardIdStatusesStatusIdNotificationsGet (params: {  boardId: number; statusId: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<BoardStatusNotification>> {
            const localVarPath = this.basePath + '/service/boards/{boardId}/statuses/{statusId}/notifications'
                .replace('{' + 'boardId' + '}', String(params.boardId))
                .replace('{' + 'statusId' + '}', String(params.statusId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'boardId' is set
            if (params.boardId == null) {
                throw new Error('Missing required parameter boardId when calling serviceBoardsBoardIdStatusesStatusIdNotificationsGet');
            }
            // verify required parameter 'statusId' is set
            if (params.statusId == null) {
                throw new Error('Missing required parameter statusId when calling serviceBoardsBoardIdStatusesStatusIdNotificationsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Board Status Notification By Id
         * @param boardId
         * @param statusId
         * @param id
         */
        public serviceBoardsBoardIdStatusesStatusIdNotificationsIdDelete (params: {  boardId: number; statusId: number; id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/boards/{boardId}/statuses/{statusId}/notifications/{id}'
                .replace('{' + 'boardId' + '}', String(params.boardId))
                .replace('{' + 'statusId' + '}', String(params.statusId))
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'boardId' is set
            if (params.boardId == null) {
                throw new Error('Missing required parameter boardId when calling serviceBoardsBoardIdStatusesStatusIdNotificationsIdDelete');
            }
            // verify required parameter 'statusId' is set
            if (params.statusId == null) {
                throw new Error('Missing required parameter statusId when calling serviceBoardsBoardIdStatusesStatusIdNotificationsIdDelete');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsBoardIdStatusesStatusIdNotificationsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Board Status Notification By Id
         * @param boardId
         * @param statusId
         * @param id
         */
        public serviceBoardsBoardIdStatusesStatusIdNotificationsIdGet (params: {  boardId: number; statusId: number; id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardStatusNotification> {
            const localVarPath = this.basePath + '/service/boards/{boardId}/statuses/{statusId}/notifications/{id}'
                .replace('{' + 'boardId' + '}', String(params.boardId))
                .replace('{' + 'statusId' + '}', String(params.statusId))
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'boardId' is set
            if (params.boardId == null) {
                throw new Error('Missing required parameter boardId when calling serviceBoardsBoardIdStatusesStatusIdNotificationsIdGet');
            }
            // verify required parameter 'statusId' is set
            if (params.statusId == null) {
                throw new Error('Missing required parameter statusId when calling serviceBoardsBoardIdStatusesStatusIdNotificationsIdGet');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsBoardIdStatusesStatusIdNotificationsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Board Status Notification
         * @param boardId
         * @param statusId
         * @param id
         * @param operations
         */
        public serviceBoardsBoardIdStatusesStatusIdNotificationsIdPatch (params: {  boardId: number; statusId: number; id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardStatusNotification> {
            const localVarPath = this.basePath + '/service/boards/{boardId}/statuses/{statusId}/notifications/{id}'
                .replace('{' + 'boardId' + '}', String(params.boardId))
                .replace('{' + 'statusId' + '}', String(params.statusId))
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'boardId' is set
            if (params.boardId == null) {
                throw new Error('Missing required parameter boardId when calling serviceBoardsBoardIdStatusesStatusIdNotificationsIdPatch');
            }
            // verify required parameter 'statusId' is set
            if (params.statusId == null) {
                throw new Error('Missing required parameter statusId when calling serviceBoardsBoardIdStatusesStatusIdNotificationsIdPatch');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsBoardIdStatusesStatusIdNotificationsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceBoardsBoardIdStatusesStatusIdNotificationsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Board Status Notification
         * @param boardId
         * @param statusId
         * @param id
         * @param boardStatusNotification
         */
        public serviceBoardsBoardIdStatusesStatusIdNotificationsIdPut (params: {  boardId: number; statusId: number; id: number; boardStatusNotification: BoardStatusNotification; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardStatusNotification> {
            const localVarPath = this.basePath + '/service/boards/{boardId}/statuses/{statusId}/notifications/{id}'
                .replace('{' + 'boardId' + '}', String(params.boardId))
                .replace('{' + 'statusId' + '}', String(params.statusId))
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'boardId' is set
            if (params.boardId == null) {
                throw new Error('Missing required parameter boardId when calling serviceBoardsBoardIdStatusesStatusIdNotificationsIdPut');
            }
            // verify required parameter 'statusId' is set
            if (params.statusId == null) {
                throw new Error('Missing required parameter statusId when calling serviceBoardsBoardIdStatusesStatusIdNotificationsIdPut');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsBoardIdStatusesStatusIdNotificationsIdPut');
            }
            // verify required parameter 'boardStatusNotification' is set
            if (params.boardStatusNotification == null) {
                throw new Error('Missing required parameter boardStatusNotification when calling serviceBoardsBoardIdStatusesStatusIdNotificationsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.boardStatusNotification),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Board Status Notification
         * @param boardId
         * @param statusId
         * @param boardStatusNotification
         */
        public serviceBoardsBoardIdStatusesStatusIdNotificationsPost (params: {  boardId: number; statusId: number; boardStatusNotification: BoardStatusNotification; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardStatusNotification> {
            const localVarPath = this.basePath + '/service/boards/{boardId}/statuses/{statusId}/notifications'
                .replace('{' + 'boardId' + '}', String(params.boardId))
                .replace('{' + 'statusId' + '}', String(params.statusId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'boardId' is set
            if (params.boardId == null) {
                throw new Error('Missing required parameter boardId when calling serviceBoardsBoardIdStatusesStatusIdNotificationsPost');
            }
            // verify required parameter 'statusId' is set
            if (params.statusId == null) {
                throw new Error('Missing required parameter statusId when calling serviceBoardsBoardIdStatusesStatusIdNotificationsPost');
            }
            // verify required parameter 'boardStatusNotification' is set
            if (params.boardStatusNotification == null) {
                throw new Error('Missing required parameter boardStatusNotification when calling serviceBoardsBoardIdStatusesStatusIdNotificationsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.boardStatusNotification),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BoardStatusesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Statuses Count
         * @param id
         * @param conditions
         */
        public serviceBoardsIdStatusesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/boards/{id}/statuses/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdStatusesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Statuses
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceBoardsIdStatusesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<BoardStatus>> {
            const localVarPath = this.basePath + '/service/boards/{id}/statuses'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdStatusesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Statuses
         * @param id
         * @param boardStatus
         */
        public serviceBoardsIdStatusesPost (params: {  id: number; boardStatus: BoardStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardStatus> {
            const localVarPath = this.basePath + '/service/boards/{id}/statuses'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdStatusesPost');
            }
            // verify required parameter 'boardStatus' is set
            if (params.boardStatus == null) {
                throw new Error('Missing required parameter boardStatus when calling serviceBoardsIdStatusesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.boardStatus),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Status By Id
         * @param id
         * @param statusId
         */
        public serviceBoardsIdStatusesStatusIdDelete (params: {  id: number; statusId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/boards/{id}/statuses/{statusId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'statusId' + '}', String(params.statusId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdStatusesStatusIdDelete');
            }
            // verify required parameter 'statusId' is set
            if (params.statusId == null) {
                throw new Error('Missing required parameter statusId when calling serviceBoardsIdStatusesStatusIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Status By Id
         * @param id
         * @param statusId
         */
        public serviceBoardsIdStatusesStatusIdGet (params: {  id: number; statusId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardStatus> {
            const localVarPath = this.basePath + '/service/boards/{id}/statuses/{statusId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'statusId' + '}', String(params.statusId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdStatusesStatusIdGet');
            }
            // verify required parameter 'statusId' is set
            if (params.statusId == null) {
                throw new Error('Missing required parameter statusId when calling serviceBoardsIdStatusesStatusIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Status
         * @param id
         * @param statusId
         * @param operations
         */
        public serviceBoardsIdStatusesStatusIdPatch (params: {  id: number; statusId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardStatus> {
            const localVarPath = this.basePath + '/service/boards/{id}/statuses/{statusId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'statusId' + '}', String(params.statusId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdStatusesStatusIdPatch');
            }
            // verify required parameter 'statusId' is set
            if (params.statusId == null) {
                throw new Error('Missing required parameter statusId when calling serviceBoardsIdStatusesStatusIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceBoardsIdStatusesStatusIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Statuses
         * @param id
         * @param statusId
         * @param boardStatus
         */
        public serviceBoardsIdStatusesStatusIdPut (params: {  id: number; statusId: number; boardStatus: BoardStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardStatus> {
            const localVarPath = this.basePath + '/service/boards/{id}/statuses/{statusId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'statusId' + '}', String(params.statusId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdStatusesStatusIdPut');
            }
            // verify required parameter 'statusId' is set
            if (params.statusId == null) {
                throw new Error('Missing required parameter statusId when calling serviceBoardsIdStatusesStatusIdPut');
            }
            // verify required parameter 'boardStatus' is set
            if (params.boardStatus == null) {
                throw new Error('Missing required parameter boardStatus when calling serviceBoardsIdStatusesStatusIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.boardStatus),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BoardSubTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Subtypes Count
         * @param id
         * @param conditions
         */
        public serviceBoardsIdSubtypesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/boards/{id}/subtypes/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdSubtypesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Subtypes
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceBoardsIdSubtypesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<BoardSubType>> {
            const localVarPath = this.basePath + '/service/boards/{id}/subtypes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdSubtypesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Subtype
         * @param id
         * @param boardSubType
         */
        public serviceBoardsIdSubtypesPost (params: {  id: number; boardSubType: BoardSubType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardSubType> {
            const localVarPath = this.basePath + '/service/boards/{id}/subtypes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdSubtypesPost');
            }
            // verify required parameter 'boardSubType' is set
            if (params.boardSubType == null) {
                throw new Error('Missing required parameter boardSubType when calling serviceBoardsIdSubtypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.boardSubType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Subtype By Id
         * @param id
         * @param subtypeId
         */
        public serviceBoardsIdSubtypesSubtypeIdDelete (params: {  id: number; subtypeId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/boards/{id}/subtypes/{subtypeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'subtypeId' + '}', String(params.subtypeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdSubtypesSubtypeIdDelete');
            }
            // verify required parameter 'subtypeId' is set
            if (params.subtypeId == null) {
                throw new Error('Missing required parameter subtypeId when calling serviceBoardsIdSubtypesSubtypeIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Subtype By Id
         * @param id
         * @param subtypeId
         */
        public serviceBoardsIdSubtypesSubtypeIdGet (params: {  id: number; subtypeId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardSubType> {
            const localVarPath = this.basePath + '/service/boards/{id}/subtypes/{subtypeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'subtypeId' + '}', String(params.subtypeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdSubtypesSubtypeIdGet');
            }
            // verify required parameter 'subtypeId' is set
            if (params.subtypeId == null) {
                throw new Error('Missing required parameter subtypeId when calling serviceBoardsIdSubtypesSubtypeIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Subtype
         * @param id
         * @param subtypeId
         * @param operations
         */
        public serviceBoardsIdSubtypesSubtypeIdPatch (params: {  id: number; subtypeId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardSubType> {
            const localVarPath = this.basePath + '/service/boards/{id}/subtypes/{subtypeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'subtypeId' + '}', String(params.subtypeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdSubtypesSubtypeIdPatch');
            }
            // verify required parameter 'subtypeId' is set
            if (params.subtypeId == null) {
                throw new Error('Missing required parameter subtypeId when calling serviceBoardsIdSubtypesSubtypeIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceBoardsIdSubtypesSubtypeIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Subtype
         * @param id
         * @param subtypeId
         * @param boardSubType
         */
        public serviceBoardsIdSubtypesSubtypeIdPut (params: {  id: number; subtypeId: number; boardSubType: BoardSubType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardSubType> {
            const localVarPath = this.basePath + '/service/boards/{id}/subtypes/{subtypeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'subtypeId' + '}', String(params.subtypeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdSubtypesSubtypeIdPut');
            }
            // verify required parameter 'subtypeId' is set
            if (params.subtypeId == null) {
                throw new Error('Missing required parameter subtypeId when calling serviceBoardsIdSubtypesSubtypeIdPut');
            }
            // verify required parameter 'boardSubType' is set
            if (params.boardSubType == null) {
                throw new Error('Missing required parameter boardSubType when calling serviceBoardsIdSubtypesSubtypeIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.boardSubType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BoardTeamsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Teams Count
         * @param id
         * @param conditions
         */
        public serviceBoardsIdTeamsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/boards/{id}/teams/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdTeamsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Teams
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceBoardsIdTeamsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<BoardTeam>> {
            const localVarPath = this.basePath + '/service/boards/{id}/teams'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdTeamsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Team
         * @param id
         * @param boardTeam
         */
        public serviceBoardsIdTeamsPost (params: {  id: number; boardTeam: BoardTeam; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardTeam> {
            const localVarPath = this.basePath + '/service/boards/{id}/teams'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdTeamsPost');
            }
            // verify required parameter 'boardTeam' is set
            if (params.boardTeam == null) {
                throw new Error('Missing required parameter boardTeam when calling serviceBoardsIdTeamsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.boardTeam),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Team By Id
         * @param id
         * @param teamId
         */
        public serviceBoardsIdTeamsTeamIdDelete (params: {  id: number; teamId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/boards/{id}/teams/{teamId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'teamId' + '}', String(params.teamId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdTeamsTeamIdDelete');
            }
            // verify required parameter 'teamId' is set
            if (params.teamId == null) {
                throw new Error('Missing required parameter teamId when calling serviceBoardsIdTeamsTeamIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Team By Id
         * @param id
         * @param teamId
         */
        public serviceBoardsIdTeamsTeamIdGet (params: {  id: number; teamId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardTeam> {
            const localVarPath = this.basePath + '/service/boards/{id}/teams/{teamId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'teamId' + '}', String(params.teamId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdTeamsTeamIdGet');
            }
            // verify required parameter 'teamId' is set
            if (params.teamId == null) {
                throw new Error('Missing required parameter teamId when calling serviceBoardsIdTeamsTeamIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Team
         * @param id
         * @param teamId
         * @param operations
         */
        public serviceBoardsIdTeamsTeamIdPatch (params: {  id: number; teamId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardTeam> {
            const localVarPath = this.basePath + '/service/boards/{id}/teams/{teamId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'teamId' + '}', String(params.teamId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdTeamsTeamIdPatch');
            }
            // verify required parameter 'teamId' is set
            if (params.teamId == null) {
                throw new Error('Missing required parameter teamId when calling serviceBoardsIdTeamsTeamIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceBoardsIdTeamsTeamIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Team
         * @param id
         * @param teamId
         * @param boardTeam
         */
        public serviceBoardsIdTeamsTeamIdPut (params: {  id: number; teamId: number; boardTeam: BoardTeam; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardTeam> {
            const localVarPath = this.basePath + '/service/boards/{id}/teams/{teamId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'teamId' + '}', String(params.teamId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdTeamsTeamIdPut');
            }
            // verify required parameter 'teamId' is set
            if (params.teamId == null) {
                throw new Error('Missing required parameter teamId when calling serviceBoardsIdTeamsTeamIdPut');
            }
            // verify required parameter 'boardTeam' is set
            if (params.boardTeam == null) {
                throw new Error('Missing required parameter boardTeam when calling serviceBoardsIdTeamsTeamIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.boardTeam),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BoardTypeSubTypeItemAssociationsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Board Type Sub Type Item Associations Count
         * @param id
         * @param conditions
         */
        public serviceBoardsIdTypeSubTypeItemAssociationsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/boards/{id}/typeSubTypeItemAssociations/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdTypeSubTypeItemAssociationsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Board Type Sub Type Item Associations
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceBoardsIdTypeSubTypeItemAssociationsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<BoardTypeSubTypeItemAssociation>> {
            const localVarPath = this.basePath + '/service/boards/{id}/typeSubTypeItemAssociations'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdTypeSubTypeItemAssociationsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Board Type Sub Type Item Association By Id
         * @param id
         * @param typeSubTypeItemAssociationId
         */
        public serviceBoardsIdTypeSubTypeItemAssociationsTypeSubTypeItemAssociationIdGet (params: {  id: number; typeSubTypeItemAssociationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardTypeSubTypeItemAssociation> {
            const localVarPath = this.basePath + '/service/boards/{id}/typeSubTypeItemAssociations/{typeSubTypeItemAssociationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'typeSubTypeItemAssociationId' + '}', String(params.typeSubTypeItemAssociationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdTypeSubTypeItemAssociationsTypeSubTypeItemAssociationIdGet');
            }
            // verify required parameter 'typeSubTypeItemAssociationId' is set
            if (params.typeSubTypeItemAssociationId == null) {
                throw new Error('Missing required parameter typeSubTypeItemAssociationId when calling serviceBoardsIdTypeSubTypeItemAssociationsTypeSubTypeItemAssociationIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BoardTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Types Count
         * @param id
         * @param conditions
         */
        public serviceBoardsIdTypesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/boards/{id}/types/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdTypesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Types
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceBoardsIdTypesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<BoardType>> {
            const localVarPath = this.basePath + '/service/boards/{id}/types'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdTypesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Type
         * @param id
         * @param boardType
         */
        public serviceBoardsIdTypesPost (params: {  id: number; boardType: BoardType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardType> {
            const localVarPath = this.basePath + '/service/boards/{id}/types'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdTypesPost');
            }
            // verify required parameter 'boardType' is set
            if (params.boardType == null) {
                throw new Error('Missing required parameter boardType when calling serviceBoardsIdTypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.boardType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Type By Id
         * @param id
         * @param typeId
         */
        public serviceBoardsIdTypesTypeIdDelete (params: {  id: number; typeId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/boards/{id}/types/{typeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'typeId' + '}', String(params.typeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdTypesTypeIdDelete');
            }
            // verify required parameter 'typeId' is set
            if (params.typeId == null) {
                throw new Error('Missing required parameter typeId when calling serviceBoardsIdTypesTypeIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Type By Id
         * @param id
         * @param typeId
         */
        public serviceBoardsIdTypesTypeIdGet (params: {  id: number; typeId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardType> {
            const localVarPath = this.basePath + '/service/boards/{id}/types/{typeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'typeId' + '}', String(params.typeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdTypesTypeIdGet');
            }
            // verify required parameter 'typeId' is set
            if (params.typeId == null) {
                throw new Error('Missing required parameter typeId when calling serviceBoardsIdTypesTypeIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Types
         * @param id
         * @param typeId
         * @param operations
         */
        public serviceBoardsIdTypesTypeIdPatch (params: {  id: number; typeId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardType> {
            const localVarPath = this.basePath + '/service/boards/{id}/types/{typeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'typeId' + '}', String(params.typeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdTypesTypeIdPatch');
            }
            // verify required parameter 'typeId' is set
            if (params.typeId == null) {
                throw new Error('Missing required parameter typeId when calling serviceBoardsIdTypesTypeIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceBoardsIdTypesTypeIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Types
         * @param id
         * @param typeId
         * @param boardType
         */
        public serviceBoardsIdTypesTypeIdPut (params: {  id: number; typeId: number; boardType: BoardType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardType> {
            const localVarPath = this.basePath + '/service/boards/{id}/types/{typeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'typeId' + '}', String(params.typeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdTypesTypeIdPut');
            }
            // verify required parameter 'typeId' is set
            if (params.typeId == null) {
                throw new Error('Missing required parameter typeId when calling serviceBoardsIdTypesTypeIdPut');
            }
            // verify required parameter 'boardType' is set
            if (params.boardType == null) {
                throw new Error('Missing required parameter boardType when calling serviceBoardsIdTypesTypeIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.boardType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BoardsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Copy Board
         * @param copy
         */
        public serviceBoardsCopyPost (params: {  copy: BoardCopy; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Board> {
            const localVarPath = this.basePath + '/service/boards/copy';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'copy' is set
            if (params.copy == null) {
                throw new Error('Missing required parameter copy when calling serviceBoardsCopyPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.copy),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Boards Count
         * @param conditions
         */
        public serviceBoardsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/boards/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Boards
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceBoardsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Board>> {
            const localVarPath = this.basePath + '/service/boards';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Board By Id
         * @param id
         */
        public serviceBoardsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/boards/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Board By Id
         * @param id
         */
        public serviceBoardsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Board> {
            const localVarPath = this.basePath + '/service/boards/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Board
         * @param id
         * @param operations
         */
        public serviceBoardsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Board> {
            const localVarPath = this.basePath + '/service/boards/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceBoardsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Board
         * @param id
         * @param board
         */
        public serviceBoardsIdPut (params: {  id: number; board: Board; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Board> {
            const localVarPath = this.basePath + '/service/boards/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceBoardsIdPut');
            }
            // verify required parameter 'board' is set
            if (params.board == null) {
                throw new Error('Missing required parameter board when calling serviceBoardsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.board),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Board
         * @param board
         */
        public serviceBoardsPost (params: {  board: Board; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Board> {
            const localVarPath = this.basePath + '/service/boards';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'board' is set
            if (params.board == null) {
                throw new Error('Missing required parameter board when calling serviceBoardsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.board),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CalendarsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Calendars Count
         * @param conditions
         */
        public systemCalendarsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Calendar> {
            const localVarPath = this.basePath + '/system/calendars/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Calendars
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemCalendarsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Calendar>> {
            const localVarPath = this.basePath + '/system/calendars';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Calendar By Id
         * @param id
         */
        public systemCalendarsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Calendar> {
            const localVarPath = this.basePath + '/system/calendars/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemCalendarsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CallbacksApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Callback Entries Count
         * @param conditions
         */
        public systemCallbacksCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/callbacks/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Callback Entries
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemCallbacksGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CallbackEntry>> {
            const localVarPath = this.basePath + '/system/callbacks';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Callback Entry By Id
         * @param id
         */
        public systemCallbacksIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/callbacks/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemCallbacksIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Callback Entry By Id
         * @param id
         */
        public systemCallbacksIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CallbackEntry> {
            const localVarPath = this.basePath + '/system/callbacks/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemCallbacksIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Callback Entry
         * @param id
         * @param operations
         */
        public systemCallbacksIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CallbackEntry> {
            const localVarPath = this.basePath + '/system/callbacks/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemCallbacksIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemCallbacksIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Callback Entry
         * @param id
         * @param callbackEntry
         */
        public systemCallbacksIdPut (params: {  id: number; callbackEntry: CallbackEntry; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CallbackEntry> {
            const localVarPath = this.basePath + '/system/callbacks/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemCallbacksIdPut');
            }
            // verify required parameter 'callbackEntry' is set
            if (params.callbackEntry == null) {
                throw new Error('Missing required parameter callbackEntry when calling systemCallbacksIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.callbackEntry),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Callback Entry
         * @param callbackEntry
         */
        public systemCallbacksPost (params: {  callbackEntry: CallbackEntry; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CallbackEntry> {
            const localVarPath = this.basePath + '/system/callbacks';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'callbackEntry' is set
            if (params.callbackEntry == null) {
                throw new Error('Missing required parameter callbackEntry when calling systemCallbacksPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.callbackEntry),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CampaignAuditsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Delete Campaign Audit By Id
         * @param id
         * @param auditId
         */
        public marketingCampaignsIdAuditsAuditIdDelete (params: {  id: number; auditId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/audits/{auditId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'auditId' + '}', String(params.auditId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdAuditsAuditIdDelete');
            }
            // verify required parameter 'auditId' is set
            if (params.auditId == null) {
                throw new Error('Missing required parameter auditId when calling marketingCampaignsIdAuditsAuditIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Campaign Audit By Id
         * @param id
         * @param auditId
         */
        public marketingCampaignsIdAuditsAuditIdGet (params: {  id: number; auditId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignAudit> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/audits/{auditId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'auditId' + '}', String(params.auditId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdAuditsAuditIdGet');
            }
            // verify required parameter 'auditId' is set
            if (params.auditId == null) {
                throw new Error('Missing required parameter auditId when calling marketingCampaignsIdAuditsAuditIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Campaign Audit
         * @param id
         * @param auditId
         * @param operations
         */
        public marketingCampaignsIdAuditsAuditIdPatch (params: {  id: number; auditId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignAudit> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/audits/{auditId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'auditId' + '}', String(params.auditId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdAuditsAuditIdPatch');
            }
            // verify required parameter 'auditId' is set
            if (params.auditId == null) {
                throw new Error('Missing required parameter auditId when calling marketingCampaignsIdAuditsAuditIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling marketingCampaignsIdAuditsAuditIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Campaign Audit
         * @param id
         * @param auditId
         * @param campaignAudit
         */
        public marketingCampaignsIdAuditsAuditIdPut (params: {  id: number; auditId: number; campaignAudit: CampaignAudit; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignAudit> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/audits/{auditId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'auditId' + '}', String(params.auditId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdAuditsAuditIdPut');
            }
            // verify required parameter 'auditId' is set
            if (params.auditId == null) {
                throw new Error('Missing required parameter auditId when calling marketingCampaignsIdAuditsAuditIdPut');
            }
            // verify required parameter 'campaignAudit' is set
            if (params.campaignAudit == null) {
                throw new Error('Missing required parameter campaignAudit when calling marketingCampaignsIdAuditsAuditIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.campaignAudit),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Campaign Audits Count
         * @param id
         * @param conditions
         */
        public marketingCampaignsIdAuditsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/audits/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdAuditsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Campaign Audits
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public marketingCampaignsIdAuditsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CampaignAudit>> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/audits'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdAuditsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Campaign Audit
         * @param id
         * @param campaignAudit
         */
        public marketingCampaignsIdAuditsPost (params: {  id: number; campaignAudit: CampaignAudit; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignAudit> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/audits'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdAuditsPost');
            }
            // verify required parameter 'campaignAudit' is set
            if (params.campaignAudit == null) {
                throw new Error('Missing required parameter campaignAudit when calling marketingCampaignsIdAuditsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.campaignAudit),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CampaignEmailsOpenedApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Emails Opened Count
         * @param id
         * @param conditions
         */
        public marketingCampaignsIdEmailsOpenedCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/emailsOpened/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdEmailsOpenedCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Email Opened By Id
         * @param id
         * @param emailOpenedId
         */
        public marketingCampaignsIdEmailsOpenedEmailOpenedIdDelete (params: {  id: number; emailOpenedId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/emailsOpened/{emailOpenedId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'emailOpenedId' + '}', String(params.emailOpenedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdEmailsOpenedEmailOpenedIdDelete');
            }
            // verify required parameter 'emailOpenedId' is set
            if (params.emailOpenedId == null) {
                throw new Error('Missing required parameter emailOpenedId when calling marketingCampaignsIdEmailsOpenedEmailOpenedIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Email Opened By Id
         * @param id
         * @param emailOpenedId
         */
        public marketingCampaignsIdEmailsOpenedEmailOpenedIdGet (params: {  id: number; emailOpenedId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<EmailOpened> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/emailsOpened/{emailOpenedId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'emailOpenedId' + '}', String(params.emailOpenedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdEmailsOpenedEmailOpenedIdGet');
            }
            // verify required parameter 'emailOpenedId' is set
            if (params.emailOpenedId == null) {
                throw new Error('Missing required parameter emailOpenedId when calling marketingCampaignsIdEmailsOpenedEmailOpenedIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Email Opened
         * @param id
         * @param emailOpenedId
         * @param operations
         */
        public marketingCampaignsIdEmailsOpenedEmailOpenedIdPatch (params: {  id: number; emailOpenedId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<EmailOpened> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/emailsOpened/{emailOpenedId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'emailOpenedId' + '}', String(params.emailOpenedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdEmailsOpenedEmailOpenedIdPatch');
            }
            // verify required parameter 'emailOpenedId' is set
            if (params.emailOpenedId == null) {
                throw new Error('Missing required parameter emailOpenedId when calling marketingCampaignsIdEmailsOpenedEmailOpenedIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling marketingCampaignsIdEmailsOpenedEmailOpenedIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Email Opened
         * @param id
         * @param emailOpenedId
         * @param emailOpened
         */
        public marketingCampaignsIdEmailsOpenedEmailOpenedIdPut (params: {  id: number; emailOpenedId: number; emailOpened: EmailOpened; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<EmailOpened> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/emailsOpened/{emailOpenedId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'emailOpenedId' + '}', String(params.emailOpenedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdEmailsOpenedEmailOpenedIdPut');
            }
            // verify required parameter 'emailOpenedId' is set
            if (params.emailOpenedId == null) {
                throw new Error('Missing required parameter emailOpenedId when calling marketingCampaignsIdEmailsOpenedEmailOpenedIdPut');
            }
            // verify required parameter 'emailOpened' is set
            if (params.emailOpened == null) {
                throw new Error('Missing required parameter emailOpened when calling marketingCampaignsIdEmailsOpenedEmailOpenedIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.emailOpened),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Emails Opened
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public marketingCampaignsIdEmailsOpenedGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<EmailOpened>> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/emailsOpened'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdEmailsOpenedGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Email Opened
         * @param id
         * @param emailOpened
         */
        public marketingCampaignsIdEmailsOpenedPost (params: {  id: number; emailOpened: EmailOpened; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<EmailOpened> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/emailsOpened'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdEmailsOpenedPost');
            }
            // verify required parameter 'emailOpened' is set
            if (params.emailOpened == null) {
                throw new Error('Missing required parameter emailOpened when calling marketingCampaignsIdEmailsOpenedPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.emailOpened),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CampaignFormsSubmittedApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Forms Submitted Count
         * @param id
         * @param conditions
         */
        public marketingCampaignsIdFormsSubmittedCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/formsSubmitted/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdFormsSubmittedCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Form Submitted By Id
         * @param id
         * @param formSubmittedId
         */
        public marketingCampaignsIdFormsSubmittedFormSubmittedIdDelete (params: {  id: number; formSubmittedId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/formsSubmitted/{formSubmittedId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'formSubmittedId' + '}', String(params.formSubmittedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdFormsSubmittedFormSubmittedIdDelete');
            }
            // verify required parameter 'formSubmittedId' is set
            if (params.formSubmittedId == null) {
                throw new Error('Missing required parameter formSubmittedId when calling marketingCampaignsIdFormsSubmittedFormSubmittedIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Form Submitted By Id
         * @param id
         * @param formSubmittedId
         */
        public marketingCampaignsIdFormsSubmittedFormSubmittedIdGet (params: {  id: number; formSubmittedId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<FormSubmitted> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/formsSubmitted/{formSubmittedId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'formSubmittedId' + '}', String(params.formSubmittedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdFormsSubmittedFormSubmittedIdGet');
            }
            // verify required parameter 'formSubmittedId' is set
            if (params.formSubmittedId == null) {
                throw new Error('Missing required parameter formSubmittedId when calling marketingCampaignsIdFormsSubmittedFormSubmittedIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Form Submitted
         * @param id
         * @param formSubmittedId
         * @param operations
         */
        public marketingCampaignsIdFormsSubmittedFormSubmittedIdPatch (params: {  id: number; formSubmittedId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<FormSubmitted> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/formsSubmitted/{formSubmittedId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'formSubmittedId' + '}', String(params.formSubmittedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdFormsSubmittedFormSubmittedIdPatch');
            }
            // verify required parameter 'formSubmittedId' is set
            if (params.formSubmittedId == null) {
                throw new Error('Missing required parameter formSubmittedId when calling marketingCampaignsIdFormsSubmittedFormSubmittedIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling marketingCampaignsIdFormsSubmittedFormSubmittedIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Form Submitted
         * @param id
         * @param formSubmittedId
         * @param formSubmitted
         */
        public marketingCampaignsIdFormsSubmittedFormSubmittedIdPut (params: {  id: number; formSubmittedId: number; formSubmitted: FormSubmitted; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<FormSubmitted> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/formsSubmitted/{formSubmittedId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'formSubmittedId' + '}', String(params.formSubmittedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdFormsSubmittedFormSubmittedIdPut');
            }
            // verify required parameter 'formSubmittedId' is set
            if (params.formSubmittedId == null) {
                throw new Error('Missing required parameter formSubmittedId when calling marketingCampaignsIdFormsSubmittedFormSubmittedIdPut');
            }
            // verify required parameter 'formSubmitted' is set
            if (params.formSubmitted == null) {
                throw new Error('Missing required parameter formSubmitted when calling marketingCampaignsIdFormsSubmittedFormSubmittedIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.formSubmitted),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Forms Submitted
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public marketingCampaignsIdFormsSubmittedGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<FormSubmitted>> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/formsSubmitted'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdFormsSubmittedGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Form Submitted
         * @param id
         * @param formSubmitted
         */
        public marketingCampaignsIdFormsSubmittedPost (params: {  id: number; formSubmitted: FormSubmitted; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<FormSubmitted> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/formsSubmitted'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdFormsSubmittedPost');
            }
            // verify required parameter 'formSubmitted' is set
            if (params.formSubmitted == null) {
                throw new Error('Missing required parameter formSubmitted when calling marketingCampaignsIdFormsSubmittedPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.formSubmitted),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CampaignLinksClickedApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Links Clicked Count
         * @param id
         * @param conditions
         */
        public marketingCampaignsIdLinksClickedCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/linksClicked/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdLinksClickedCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Links Clicked
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public marketingCampaignsIdLinksClickedGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<LinkClicked>> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/linksClicked'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdLinksClickedGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Link Clicked By Id
         * @param id
         * @param linkClickedId
         */
        public marketingCampaignsIdLinksClickedLinkClickedIdDelete (params: {  id: number; linkClickedId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/linksClicked/{linkClickedId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'linkClickedId' + '}', String(params.linkClickedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdLinksClickedLinkClickedIdDelete');
            }
            // verify required parameter 'linkClickedId' is set
            if (params.linkClickedId == null) {
                throw new Error('Missing required parameter linkClickedId when calling marketingCampaignsIdLinksClickedLinkClickedIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Link Clicked By Id
         * @param id
         * @param linkClickedId
         */
        public marketingCampaignsIdLinksClickedLinkClickedIdGet (params: {  id: number; linkClickedId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<LinkClicked> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/linksClicked/{linkClickedId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'linkClickedId' + '}', String(params.linkClickedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdLinksClickedLinkClickedIdGet');
            }
            // verify required parameter 'linkClickedId' is set
            if (params.linkClickedId == null) {
                throw new Error('Missing required parameter linkClickedId when calling marketingCampaignsIdLinksClickedLinkClickedIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Link Clicked
         * @param id
         * @param linkClickedId
         * @param operations
         */
        public marketingCampaignsIdLinksClickedLinkClickedIdPatch (params: {  id: number; linkClickedId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<LinkClicked> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/linksClicked/{linkClickedId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'linkClickedId' + '}', String(params.linkClickedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdLinksClickedLinkClickedIdPatch');
            }
            // verify required parameter 'linkClickedId' is set
            if (params.linkClickedId == null) {
                throw new Error('Missing required parameter linkClickedId when calling marketingCampaignsIdLinksClickedLinkClickedIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling marketingCampaignsIdLinksClickedLinkClickedIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Link Clicked
         * @param id
         * @param linkClickedId
         * @param linkClicked
         */
        public marketingCampaignsIdLinksClickedLinkClickedIdPut (params: {  id: number; linkClickedId: number; linkClicked: LinkClicked; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<LinkClicked> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/linksClicked/{linkClickedId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'linkClickedId' + '}', String(params.linkClickedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdLinksClickedLinkClickedIdPut');
            }
            // verify required parameter 'linkClickedId' is set
            if (params.linkClickedId == null) {
                throw new Error('Missing required parameter linkClickedId when calling marketingCampaignsIdLinksClickedLinkClickedIdPut');
            }
            // verify required parameter 'linkClicked' is set
            if (params.linkClicked == null) {
                throw new Error('Missing required parameter linkClicked when calling marketingCampaignsIdLinksClickedLinkClickedIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.linkClicked),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Link Clicked
         * @param id
         * @param linkClicked
         */
        public marketingCampaignsIdLinksClickedPost (params: {  id: number; linkClicked: LinkClicked; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<LinkClicked> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/linksClicked'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdLinksClickedPost');
            }
            // verify required parameter 'linkClicked' is set
            if (params.linkClicked == null) {
                throw new Error('Missing required parameter linkClicked when calling marketingCampaignsIdLinksClickedPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.linkClicked),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CampaignStatusesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Campaign Statuses Count
         * @param conditions
         */
        public marketingCampaignsStatusesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/marketing/campaigns/statuses/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Campaign Statuses
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public marketingCampaignsStatusesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CampaignStatus>> {
            const localVarPath = this.basePath + '/marketing/campaigns/statuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Campaign Status By Id
         * @param id
         */
        public marketingCampaignsStatusesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/marketing/campaigns/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsStatusesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Campaign Status By Id
         * @param id
         */
        public marketingCampaignsStatusesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignStatus> {
            const localVarPath = this.basePath + '/marketing/campaigns/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsStatusesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Campaign Status
         * @param id
         * @param operations
         */
        public marketingCampaignsStatusesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignStatus> {
            const localVarPath = this.basePath + '/marketing/campaigns/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsStatusesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling marketingCampaignsStatusesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Campaign Status
         * @param id
         * @param campaignStatus
         */
        public marketingCampaignsStatusesIdPut (params: {  id: number; campaignStatus: CampaignStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignStatus> {
            const localVarPath = this.basePath + '/marketing/campaigns/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsStatusesIdPut');
            }
            // verify required parameter 'campaignStatus' is set
            if (params.campaignStatus == null) {
                throw new Error('Missing required parameter campaignStatus when calling marketingCampaignsStatusesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.campaignStatus),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Campaign Status
         * @param campaignStatus
         */
        public marketingCampaignsStatusesPost (params: {  campaignStatus: CampaignStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignStatus> {
            const localVarPath = this.basePath + '/marketing/campaigns/statuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'campaignStatus' is set
            if (params.campaignStatus == null) {
                throw new Error('Missing required parameter campaignStatus when calling marketingCampaignsStatusesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.campaignStatus),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CampaignSubTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Campaign Sub Types Count
         * @param conditions
         */
        public marketingCampaignsSubTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/marketing/campaigns/subTypes/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Campaign Sub Types
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public marketingCampaignsSubTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CampaignSubType>> {
            const localVarPath = this.basePath + '/marketing/campaigns/subTypes';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Campaign Sub Type By Id
         * @param id
         */
        public marketingCampaignsSubTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/marketing/campaigns/subTypes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsSubTypesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Campaign Sub Type By Id
         * @param id
         */
        public marketingCampaignsSubTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignSubType> {
            const localVarPath = this.basePath + '/marketing/campaigns/subTypes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsSubTypesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Campaign Sub Type
         * @param id
         * @param operations
         */
        public marketingCampaignsSubTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignSubType> {
            const localVarPath = this.basePath + '/marketing/campaigns/subTypes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsSubTypesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling marketingCampaignsSubTypesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Campaign Sub Type
         * @param id
         * @param campaignSubType
         */
        public marketingCampaignsSubTypesIdPut (params: {  id: number; campaignSubType: CampaignSubType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignSubType> {
            const localVarPath = this.basePath + '/marketing/campaigns/subTypes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsSubTypesIdPut');
            }
            // verify required parameter 'campaignSubType' is set
            if (params.campaignSubType == null) {
                throw new Error('Missing required parameter campaignSubType when calling marketingCampaignsSubTypesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.campaignSubType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Campaign Sub Type
         * @param campaignSubType
         */
        public marketingCampaignsSubTypesPost (params: {  campaignSubType: CampaignSubType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignSubType> {
            const localVarPath = this.basePath + '/marketing/campaigns/subTypes';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'campaignSubType' is set
            if (params.campaignSubType == null) {
                throw new Error('Missing required parameter campaignSubType when calling marketingCampaignsSubTypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.campaignSubType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CampaignTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Campaign Types Count
         * @param conditions
         */
        public marketingCampaignsTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/marketing/campaigns/types/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Campaign Types
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public marketingCampaignsTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CampaignType>> {
            const localVarPath = this.basePath + '/marketing/campaigns/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Campaign Type By Id
         * @param id
         */
        public marketingCampaignsTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/marketing/campaigns/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsTypesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Campaign Type By Id
         * @param id
         */
        public marketingCampaignsTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignType> {
            const localVarPath = this.basePath + '/marketing/campaigns/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsTypesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Campaign Type
         * @param id
         * @param operations
         */
        public marketingCampaignsTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignType> {
            const localVarPath = this.basePath + '/marketing/campaigns/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsTypesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling marketingCampaignsTypesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Campaign Type
         * @param id
         * @param campaignType
         */
        public marketingCampaignsTypesIdPut (params: {  id: number; campaignType: CampaignType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignType> {
            const localVarPath = this.basePath + '/marketing/campaigns/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsTypesIdPut');
            }
            // verify required parameter 'campaignType' is set
            if (params.campaignType == null) {
                throw new Error('Missing required parameter campaignType when calling marketingCampaignsTypesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.campaignType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Campaign Type
         * @param campaignType
         */
        public marketingCampaignsTypesPost (params: {  campaignType: CampaignType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignType> {
            const localVarPath = this.basePath + '/marketing/campaigns/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'campaignType' is set
            if (params.campaignType == null) {
                throw new Error('Missing required parameter campaignType when calling marketingCampaignsTypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.campaignType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CampaignsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Campaigns Count
         * @param conditions
         */
        public marketingCampaignsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/marketing/campaigns/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Campaigns
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public marketingCampaignsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Campaign>> {
            const localVarPath = this.basePath + '/marketing/campaigns';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Campaign Activities Count
         * @param id
         */
        public marketingCampaignsIdActivitiesCountGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/activities/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdActivitiesCountGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Campaign Activities
         * @param id
         * @param page
         * @param pageSize
         */
        public marketingCampaignsIdActivitiesGet (params: {  id: number; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ActivityReference>> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/activities'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdActivitiesGet');
            }
            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Campaign By Id
         * @param id
         */
        public marketingCampaignsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Campaign By Id
         * @param id
         */
        public marketingCampaignsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Campaign> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Campaign Opportunities Count
         * @param id
         */
        public marketingCampaignsIdOpportunitiesCountGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/opportunities/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdOpportunitiesCountGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Campaign Opportunities
         * @param id
         * @param page
         * @param pageSize
         */
        public marketingCampaignsIdOpportunitiesGet (params: {  id: number; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<OpportunityReference>> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}/opportunities'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdOpportunitiesGet');
            }
            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Campaign
         * @param id
         * @param operations
         */
        public marketingCampaignsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Campaign> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling marketingCampaignsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Campaign
         * @param id
         * @param campaign
         */
        public marketingCampaignsIdPut (params: {  id: number; campaign: Campaign; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Campaign> {
            const localVarPath = this.basePath + '/marketing/campaigns/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsIdPut');
            }
            // verify required parameter 'campaign' is set
            if (params.campaign == null) {
                throw new Error('Missing required parameter campaign when calling marketingCampaignsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.campaign),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Campaign
         * @param campaign
         */
        public marketingCampaignsPost (params: {  campaign: Campaign; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Campaign> {
            const localVarPath = this.basePath + '/marketing/campaigns';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'campaign' is set
            if (params.campaign == null) {
                throw new Error('Missing required parameter campaign when calling marketingCampaignsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.campaign),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CatalogComponentsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Delete Catalog Component By Id
         * @param id
         * @param componentId
         */
        public procurementCatalogIdComponentsComponentIdDelete (params: {  id: number; componentId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/catalog/{id}/components/{componentId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'componentId' + '}', String(params.componentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCatalogIdComponentsComponentIdDelete');
            }
            // verify required parameter 'componentId' is set
            if (params.componentId == null) {
                throw new Error('Missing required parameter componentId when calling procurementCatalogIdComponentsComponentIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Catalog Component By Id
         * @param id
         * @param componentId
         */
        public procurementCatalogIdComponentsComponentIdGet (params: {  id: number; componentId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CatalogComponent> {
            const localVarPath = this.basePath + '/procurement/catalog/{id}/components/{componentId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'componentId' + '}', String(params.componentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCatalogIdComponentsComponentIdGet');
            }
            // verify required parameter 'componentId' is set
            if (params.componentId == null) {
                throw new Error('Missing required parameter componentId when calling procurementCatalogIdComponentsComponentIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Catalog Component
         * @param id
         * @param componentId
         * @param operations
         */
        public procurementCatalogIdComponentsComponentIdPatch (params: {  id: number; componentId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CatalogComponent> {
            const localVarPath = this.basePath + '/procurement/catalog/{id}/components/{componentId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'componentId' + '}', String(params.componentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCatalogIdComponentsComponentIdPatch');
            }
            // verify required parameter 'componentId' is set
            if (params.componentId == null) {
                throw new Error('Missing required parameter componentId when calling procurementCatalogIdComponentsComponentIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementCatalogIdComponentsComponentIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Catalog Component
         * @param id
         * @param componentId
         * @param catalogComponent
         */
        public procurementCatalogIdComponentsComponentIdPut (params: {  id: number; componentId: number; catalogComponent: CatalogComponent; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CatalogComponent> {
            const localVarPath = this.basePath + '/procurement/catalog/{id}/components/{componentId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'componentId' + '}', String(params.componentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCatalogIdComponentsComponentIdPut');
            }
            // verify required parameter 'componentId' is set
            if (params.componentId == null) {
                throw new Error('Missing required parameter componentId when calling procurementCatalogIdComponentsComponentIdPut');
            }
            // verify required parameter 'catalogComponent' is set
            if (params.catalogComponent == null) {
                throw new Error('Missing required parameter catalogComponent when calling procurementCatalogIdComponentsComponentIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.catalogComponent),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Catalog Components Count
         * @param id
         * @param conditions
         */
        public procurementCatalogIdComponentsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/catalog/{id}/components/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCatalogIdComponentsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Catalog Components
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementCatalogIdComponentsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CatalogComponent>> {
            const localVarPath = this.basePath + '/procurement/catalog/{id}/components'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCatalogIdComponentsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Catalog Component
         * @param id
         * @param catalogComponent
         */
        public procurementCatalogIdComponentsPost (params: {  id: number; catalogComponent: CatalogComponent; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CatalogComponent> {
            const localVarPath = this.basePath + '/procurement/catalog/{id}/components'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCatalogIdComponentsPost');
            }
            // verify required parameter 'catalogComponent' is set
            if (params.catalogComponent == null) {
                throw new Error('Missing required parameter catalogComponent when calling procurementCatalogIdComponentsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.catalogComponent),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CatalogsItemApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Inventory Quantity On Hand
         * @param catalogItemIdentifier
         * @param warehouseBinId
         */
        public procurementCatalogCatalogItemIdentifierQuantityOnHandGet (params: {  catalogItemIdentifier: string; warehouseBinId?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/catalog/{catalogItemIdentifier}/quantityOnHand'
                .replace('{' + 'catalogItemIdentifier' + '}', String(params.catalogItemIdentifier));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'catalogItemIdentifier' is set
            if (params.catalogItemIdentifier == null) {
                throw new Error('Missing required parameter catalogItemIdentifier when calling procurementCatalogCatalogItemIdentifierQuantityOnHandGet');
            }
            if (params.warehouseBinId !== undefined) {
                queryParameters['warehouseBinId'] = params.warehouseBinId;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Catalogs Count
         * @param conditions
         */
        public procurementCatalogCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/catalog/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Catalogs
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementCatalogGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CatalogItem>> {
            const localVarPath = this.basePath + '/procurement/catalog';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Catalog By Id
         * @param id
         */
        public procurementCatalogIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/catalog/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCatalogIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Catalog By Id
         * @param id
         */
        public procurementCatalogIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CatalogItem> {
            const localVarPath = this.basePath + '/procurement/catalog/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCatalogIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Catalog
         * @param id
         * @param operations
         */
        public procurementCatalogIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CatalogItem> {
            const localVarPath = this.basePath + '/procurement/catalog/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCatalogIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementCatalogIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Catalog
         * @param id
         * @param catalogItem
         */
        public procurementCatalogIdPut (params: {  id: number; catalogItem: CatalogItem; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CatalogItem> {
            const localVarPath = this.basePath + '/procurement/catalog/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCatalogIdPut');
            }
            // verify required parameter 'catalogItem' is set
            if (params.catalogItem == null) {
                throw new Error('Missing required parameter catalogItem when calling procurementCatalogIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.catalogItem),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Catalog
         * @param catalogItem
         */
        public procurementCatalogPost (params: {  catalogItem: CatalogItem; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CatalogItem> {
            const localVarPath = this.basePath + '/procurement/catalog';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'catalogItem' is set
            if (params.catalogItem == null) {
                throw new Error('Missing required parameter catalogItem when calling procurementCatalogPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.catalogItem),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CategoriesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Categories Count
         * @param conditions
         */
        public procurementCategoriesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/categories/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Categories
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementCategoriesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Category>> {
            const localVarPath = this.basePath + '/procurement/categories';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Category By Id
         * @param id
         */
        public procurementCategoriesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/categories/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCategoriesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Category By Id
         * @param id
         */
        public procurementCategoriesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Category> {
            const localVarPath = this.basePath + '/procurement/categories/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCategoriesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Category
         * @param id
         * @param operations
         */
        public procurementCategoriesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Category> {
            const localVarPath = this.basePath + '/procurement/categories/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCategoriesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementCategoriesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Category
         * @param id
         * @param category
         */
        public procurementCategoriesIdPut (params: {  id: number; category: Category; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Category> {
            const localVarPath = this.basePath + '/procurement/categories/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCategoriesIdPut');
            }
            // verify required parameter 'category' is set
            if (params.category == null) {
                throw new Error('Missing required parameter category when calling procurementCategoriesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.category),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Category
         * @param category
         */
        public procurementCategoriesPost (params: {  category: Category; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Category> {
            const localVarPath = this.basePath + '/procurement/categories';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'category' is set
            if (params.category == null) {
                throw new Error('Missing required parameter category when calling procurementCategoriesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.category),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CertificationsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Certification Count
         * @param conditions
         */
        public systemCertificationsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/certifications/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Certification
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemCertificationsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Certification>> {
            const localVarPath = this.basePath + '/system/certifications';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Certification By Id
         * @param id
         */
        public systemCertificationsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/certifications/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemCertificationsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Certification By Id
         * @param id
         */
        public systemCertificationsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Certification> {
            const localVarPath = this.basePath + '/system/certifications/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemCertificationsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Certification
         * @param id
         * @param operations
         */
        public systemCertificationsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Certification> {
            const localVarPath = this.basePath + '/system/certifications/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemCertificationsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemCertificationsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Certification
         * @param id
         * @param certification
         */
        public systemCertificationsIdPut (params: {  id: number; certification: Certification; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Certification> {
            const localVarPath = this.basePath + '/system/certifications/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemCertificationsIdPut');
            }
            // verify required parameter 'certification' is set
            if (params.certification == null) {
                throw new Error('Missing required parameter certification when calling systemCertificationsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.certification),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Certification
         * @param certification
         */
        public systemCertificationsPost (params: {  certification: Certification; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Certification> {
            const localVarPath = this.basePath + '/system/certifications';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'certification' is set
            if (params.certification == null) {
                throw new Error('Missing required parameter certification when calling systemCertificationsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.certification),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ChargeCodeExpenseTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Charge Code Expense Entries Count
         * @param id
         * @param conditions
         */
        public timeChargeCodesIdExpenseTypesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/time/chargeCodes/{id}/expenseTypes/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeChargeCodesIdExpenseTypesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Charge Code Expense Type By Id
         * @param id
         * @param expenseTypeId
         */
        public timeChargeCodesIdExpenseTypesExpenseTypeIdDelete (params: {  id: number; expenseTypeId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/time/chargeCodes/{id}/expenseTypes/{expenseTypeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'expenseTypeId' + '}', String(params.expenseTypeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeChargeCodesIdExpenseTypesExpenseTypeIdDelete');
            }
            // verify required parameter 'expenseTypeId' is set
            if (params.expenseTypeId == null) {
                throw new Error('Missing required parameter expenseTypeId when calling timeChargeCodesIdExpenseTypesExpenseTypeIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Charge Code Expense Type By Id
         * @param id
         * @param expenseTypeId
         */
        public timeChargeCodesIdExpenseTypesExpenseTypeIdGet (params: {  id: number; expenseTypeId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ChargeCodeExpenseType> {
            const localVarPath = this.basePath + '/time/chargeCodes/{id}/expenseTypes/{expenseTypeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'expenseTypeId' + '}', String(params.expenseTypeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeChargeCodesIdExpenseTypesExpenseTypeIdGet');
            }
            // verify required parameter 'expenseTypeId' is set
            if (params.expenseTypeId == null) {
                throw new Error('Missing required parameter expenseTypeId when calling timeChargeCodesIdExpenseTypesExpenseTypeIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Charge Code Expense Type
         * @param id
         * @param expenseTypeId
         * @param operations
         */
        public timeChargeCodesIdExpenseTypesExpenseTypeIdPatch (params: {  id: number; expenseTypeId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ChargeCodeExpenseType> {
            const localVarPath = this.basePath + '/time/chargeCodes/{id}/expenseTypes/{expenseTypeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'expenseTypeId' + '}', String(params.expenseTypeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeChargeCodesIdExpenseTypesExpenseTypeIdPatch');
            }
            // verify required parameter 'expenseTypeId' is set
            if (params.expenseTypeId == null) {
                throw new Error('Missing required parameter expenseTypeId when calling timeChargeCodesIdExpenseTypesExpenseTypeIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling timeChargeCodesIdExpenseTypesExpenseTypeIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Charge Code Expense Type
         * @param id
         * @param expenseTypeId
         * @param chargeCodeExpenseType
         */
        public timeChargeCodesIdExpenseTypesExpenseTypeIdPut (params: {  id: number; expenseTypeId: number; chargeCodeExpenseType: ChargeCodeExpenseType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ChargeCodeExpenseType> {
            const localVarPath = this.basePath + '/time/chargeCodes/{id}/expenseTypes/{expenseTypeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'expenseTypeId' + '}', String(params.expenseTypeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeChargeCodesIdExpenseTypesExpenseTypeIdPut');
            }
            // verify required parameter 'expenseTypeId' is set
            if (params.expenseTypeId == null) {
                throw new Error('Missing required parameter expenseTypeId when calling timeChargeCodesIdExpenseTypesExpenseTypeIdPut');
            }
            // verify required parameter 'chargeCodeExpenseType' is set
            if (params.chargeCodeExpenseType == null) {
                throw new Error('Missing required parameter chargeCodeExpenseType when calling timeChargeCodesIdExpenseTypesExpenseTypeIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.chargeCodeExpenseType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Charge Code Expense Entries
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public timeChargeCodesIdExpenseTypesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ChargeCodeExpenseType>> {
            const localVarPath = this.basePath + '/time/chargeCodes/{id}/expenseTypes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeChargeCodesIdExpenseTypesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Charge Code Expense Type
         * @param id
         * @param chargeCodeExpenseType
         */
        public timeChargeCodesIdExpenseTypesPost (params: {  id: number; chargeCodeExpenseType: ChargeCodeExpenseType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ChargeCodeExpenseType> {
            const localVarPath = this.basePath + '/time/chargeCodes/{id}/expenseTypes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeChargeCodesIdExpenseTypesPost');
            }
            // verify required parameter 'chargeCodeExpenseType' is set
            if (params.chargeCodeExpenseType == null) {
                throw new Error('Missing required parameter chargeCodeExpenseType when calling timeChargeCodesIdExpenseTypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.chargeCodeExpenseType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ChargeCodesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Charge Code Count
         * @param conditions
         */
        public timeChargeCodesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/time/chargeCodes/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Charge Code
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public timeChargeCodesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ChargeCode>> {
            const localVarPath = this.basePath + '/time/chargeCodes';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Charge Code By Id
         * @param id
         */
        public timeChargeCodesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/time/chargeCodes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeChargeCodesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Charge Code By Id
         * @param id
         */
        public timeChargeCodesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ChargeCode> {
            const localVarPath = this.basePath + '/time/chargeCodes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeChargeCodesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Charge Code
         * @param id
         * @param operations
         */
        public timeChargeCodesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ChargeCode> {
            const localVarPath = this.basePath + '/time/chargeCodes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeChargeCodesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling timeChargeCodesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Charge Code
         * @param id
         * @param chargeCode
         */
        public timeChargeCodesIdPut (params: {  id: number; chargeCode: ChargeCode; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ChargeCode> {
            const localVarPath = this.basePath + '/time/chargeCodes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeChargeCodesIdPut');
            }
            // verify required parameter 'chargeCode' is set
            if (params.chargeCode == null) {
                throw new Error('Missing required parameter chargeCode when calling timeChargeCodesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.chargeCode),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Charge Code
         * @param chargeCode
         */
        public timeChargeCodesPost (params: {  chargeCode: ChargeCode; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ChargeCode> {
            const localVarPath = this.basePath + '/time/chargeCodes';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'chargeCode' is set
            if (params.chargeCode == null) {
                throw new Error('Missing required parameter chargeCode when calling timeChargeCodesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.chargeCode),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ClassificationsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Classification Count
         * @param conditions
         */
        public expenseClassificationsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/expense/classifications/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Expense Classification
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public expenseClassificationsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Classification>> {
            const localVarPath = this.basePath + '/expense/classifications';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Classification By Id
         * @param id
         */
        public expenseClassificationsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Classification> {
            const localVarPath = this.basePath + '/expense/classifications/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling expenseClassificationsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CodesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Create Codes Count
         * @param conditions
         */
        public serviceCodesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/codes/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Codes
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceCodesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Code>> {
            const localVarPath = this.basePath + '/service/codes';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Code By Id
         * @param id
         */
        public serviceCodesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/codes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceCodesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Code By Id
         * @param id
         */
        public serviceCodesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Code> {
            const localVarPath = this.basePath + '/service/codes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceCodesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Code
         * @param id
         * @param operations
         */
        public serviceCodesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Code> {
            const localVarPath = this.basePath + '/service/codes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceCodesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceCodesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Code
         * @param id
         * @param code
         */
        public serviceCodesIdPut (params: {  id: number; code: Code; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Code> {
            const localVarPath = this.basePath + '/service/codes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceCodesIdPut');
            }
            // verify required parameter 'code' is set
            if (params.code == null) {
                throw new Error('Missing required parameter code when calling serviceCodesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.code),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Codes
         * @param code
         */
        public serviceCodesPost (params: {  code: Code; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Code> {
            const localVarPath = this.basePath + '/service/codes';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'code' is set
            if (params.code == null) {
                throw new Error('Missing required parameter code when calling serviceCodesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.code),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CommissionsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Commissions Count
         * @param conditions
         */
        public salesCommissionsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/sales/commissions/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Commissions
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public salesCommissionsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Commission>> {
            const localVarPath = this.basePath + '/sales/commissions';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Commission By Id
         * @param id
         */
        public salesCommissionsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/sales/commissions/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesCommissionsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Commission By Id
         * @param id
         */
        public salesCommissionsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Commission> {
            const localVarPath = this.basePath + '/sales/commissions/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesCommissionsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Commission
         * @param id
         * @param operations
         */
        public salesCommissionsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Commission> {
            const localVarPath = this.basePath + '/sales/commissions/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesCommissionsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling salesCommissionsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Commission
         * @param id
         * @param commission
         */
        public salesCommissionsIdPut (params: {  id: number; commission: Commission; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Commission> {
            const localVarPath = this.basePath + '/sales/commissions/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesCommissionsIdPut');
            }
            // verify required parameter 'commission' is set
            if (params.commission == null) {
                throw new Error('Missing required parameter commission when calling salesCommissionsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.commission),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Commission
         * @param commission
         */
        public salesCommissionsPost (params: {  commission: Commission; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Commission> {
            const localVarPath = this.basePath + '/sales/commissions';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'commission' is set
            if (params.commission == null) {
                throw new Error('Missing required parameter commission when calling salesCommissionsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.commission),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CompaniesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Companies Count
         * @param conditions
         * @param customFieldConditions
         */
        public companyCompaniesCountGet (params: {  conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/companies/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.customFieldConditions !== undefined) {
                queryParameters['customFieldConditions'] = params.customFieldConditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Companies
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyCompaniesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Company>> {
            const localVarPath = this.basePath + '/company/companies';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Company By Id
         * @param id
         */
        public companyCompaniesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/companies/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Company By Id
         * @param id
         */
        public companyCompaniesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Company> {
            const localVarPath = this.basePath + '/company/companies/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Merge Company
         * @param id
         * @param merge
         */
        public companyCompaniesIdMergePost (params: {  id: number; merge: CompanyMerge; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SuccessResponse> {
            const localVarPath = this.basePath + '/company/companies/{id}/merge'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdMergePost');
            }
            // verify required parameter 'merge' is set
            if (params.merge == null) {
                throw new Error('Missing required parameter merge when calling companyCompaniesIdMergePost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.merge),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Company
         * @param id
         * @param operations
         */
        public companyCompaniesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Company> {
            const localVarPath = this.basePath + '/company/companies/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyCompaniesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Company
         * @param id
         * @param company
         */
        public companyCompaniesIdPut (params: {  id: number; company: Company; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Company> {
            const localVarPath = this.basePath + '/company/companies/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdPut');
            }
            // verify required parameter 'company' is set
            if (params.company == null) {
                throw new Error('Missing required parameter company when calling companyCompaniesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.company),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Company
         * @param company
         */
        public companyCompaniesPost (params: {  company: Company; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Company> {
            const localVarPath = this.basePath + '/company/companies';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'company' is set
            if (params.company == null) {
                throw new Error('Missing required parameter company when calling companyCompaniesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.company),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CompanyCustomNotesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Custom Note Count
         * @param id
         * @param conditions
         */
        public companyCompaniesIdCustomStatusNotesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/companies/{id}/customStatusNotes/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdCustomStatusNotesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Custom Note By Id
         * @param id
         * @param customNoteId
         */
        public companyCompaniesIdCustomStatusNotesCustomNoteIdDelete (params: {  id: number; customNoteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/companies/{id}/customStatusNotes/{customNoteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'customNoteId' + '}', String(params.customNoteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdCustomStatusNotesCustomNoteIdDelete');
            }
            // verify required parameter 'customNoteId' is set
            if (params.customNoteId == null) {
                throw new Error('Missing required parameter customNoteId when calling companyCompaniesIdCustomStatusNotesCustomNoteIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Custom Note By Id
         * @param id
         * @param customNoteId
         */
        public companyCompaniesIdCustomStatusNotesCustomNoteIdGet (params: {  id: number; customNoteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyCustomNote> {
            const localVarPath = this.basePath + '/company/companies/{id}/customStatusNotes/{customNoteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'customNoteId' + '}', String(params.customNoteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdCustomStatusNotesCustomNoteIdGet');
            }
            // verify required parameter 'customNoteId' is set
            if (params.customNoteId == null) {
                throw new Error('Missing required parameter customNoteId when calling companyCompaniesIdCustomStatusNotesCustomNoteIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Custom Note
         * @param id
         * @param customNoteId
         * @param operations
         */
        public companyCompaniesIdCustomStatusNotesCustomNoteIdPatch (params: {  id: number; customNoteId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyCustomNote> {
            const localVarPath = this.basePath + '/company/companies/{id}/customStatusNotes/{customNoteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'customNoteId' + '}', String(params.customNoteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdCustomStatusNotesCustomNoteIdPatch');
            }
            // verify required parameter 'customNoteId' is set
            if (params.customNoteId == null) {
                throw new Error('Missing required parameter customNoteId when calling companyCompaniesIdCustomStatusNotesCustomNoteIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyCompaniesIdCustomStatusNotesCustomNoteIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Custom Note
         * @param id
         * @param customNoteId
         * @param customNote
         */
        public companyCompaniesIdCustomStatusNotesCustomNoteIdPut (params: {  id: number; customNoteId: number; customNote: CompanyCustomNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyCustomNote> {
            const localVarPath = this.basePath + '/company/companies/{id}/customStatusNotes/{customNoteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'customNoteId' + '}', String(params.customNoteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdCustomStatusNotesCustomNoteIdPut');
            }
            // verify required parameter 'customNoteId' is set
            if (params.customNoteId == null) {
                throw new Error('Missing required parameter customNoteId when calling companyCompaniesIdCustomStatusNotesCustomNoteIdPut');
            }
            // verify required parameter 'customNote' is set
            if (params.customNote == null) {
                throw new Error('Missing required parameter customNote when calling companyCompaniesIdCustomStatusNotesCustomNoteIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.customNote),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Custom Note
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyCompaniesIdCustomStatusNotesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CompanyCustomNote>> {
            const localVarPath = this.basePath + '/company/companies/{id}/customStatusNotes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdCustomStatusNotesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Custom Note
         * @param id
         * @param customNote
         */
        public companyCompaniesIdCustomStatusNotesPost (params: {  id: number; customNote: CompanyCustomNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyCustomNote> {
            const localVarPath = this.basePath + '/company/companies/{id}/customStatusNotes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdCustomStatusNotesPost');
            }
            // verify required parameter 'customNote' is set
            if (params.customNote == null) {
                throw new Error('Missing required parameter customNote when calling companyCompaniesIdCustomStatusNotesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.customNote),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CompanyGroupsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Company Groups Count
         * @param id
         * @param conditions
         */
        public companyCompaniesIdGroupsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/companies/{id}/groups/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdGroupsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Company Groups
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyCompaniesIdGroupsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CompanyGroup>> {
            const localVarPath = this.basePath + '/company/companies/{id}/groups'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdGroupsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Company Group By Id
         * @param id
         * @param groupid
         */
        public companyCompaniesIdGroupsGroupidDelete (params: {  id: number; groupid: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/companies/{id}/groups/{groupid}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'groupid' + '}', String(params.groupid));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdGroupsGroupidDelete');
            }
            // verify required parameter 'groupid' is set
            if (params.groupid == null) {
                throw new Error('Missing required parameter groupid when calling companyCompaniesIdGroupsGroupidDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Company Group By Id
         * @param id
         * @param groupid
         */
        public companyCompaniesIdGroupsGroupidGet (params: {  id: number; groupid: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyGroup> {
            const localVarPath = this.basePath + '/company/companies/{id}/groups/{groupid}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'groupid' + '}', String(params.groupid));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdGroupsGroupidGet');
            }
            // verify required parameter 'groupid' is set
            if (params.groupid == null) {
                throw new Error('Missing required parameter groupid when calling companyCompaniesIdGroupsGroupidGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Company Group
         * @param id
         * @param groupid
         * @param operations
         */
        public companyCompaniesIdGroupsGroupidPatch (params: {  id: number; groupid: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyGroup> {
            const localVarPath = this.basePath + '/company/companies/{id}/groups/{groupid}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'groupid' + '}', String(params.groupid));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdGroupsGroupidPatch');
            }
            // verify required parameter 'groupid' is set
            if (params.groupid == null) {
                throw new Error('Missing required parameter groupid when calling companyCompaniesIdGroupsGroupidPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyCompaniesIdGroupsGroupidPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Company Group
         * @param id
         * @param groupid
         * @param companyGroup
         */
        public companyCompaniesIdGroupsGroupidPut (params: {  id: number; groupid: number; companyGroup: CompanyGroup; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyGroup> {
            const localVarPath = this.basePath + '/company/companies/{id}/groups/{groupid}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'groupid' + '}', String(params.groupid));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdGroupsGroupidPut');
            }
            // verify required parameter 'groupid' is set
            if (params.groupid == null) {
                throw new Error('Missing required parameter groupid when calling companyCompaniesIdGroupsGroupidPut');
            }
            // verify required parameter 'companyGroup' is set
            if (params.companyGroup == null) {
                throw new Error('Missing required parameter companyGroup when calling companyCompaniesIdGroupsGroupidPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.companyGroup),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Company Group
         * @param id
         * @param companyGroup
         */
        public companyCompaniesIdGroupsPost (params: {  id: number; companyGroup: CompanyGroup; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyGroup> {
            const localVarPath = this.basePath + '/company/companies/{id}/groups'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdGroupsPost');
            }
            // verify required parameter 'companyGroup' is set
            if (params.companyGroup == null) {
                throw new Error('Missing required parameter companyGroup when calling companyCompaniesIdGroupsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.companyGroup),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CompanyManagementSummaryReportsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Company Types Count
         * @param id
         * @param conditions
         */
        public companyCompaniesIdManagementSummaryReportsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/companies/{id}/managementSummaryReports/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdManagementSummaryReportsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Management Summarys
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyCompaniesIdManagementSummaryReportsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CompanyManagementSummary>> {
            const localVarPath = this.basePath + '/company/companies/{id}/managementSummaryReports'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdManagementSummaryReportsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Management Summary
         * @param id
         * @param managementSummary
         */
        public companyCompaniesIdManagementSummaryReportsPost (params: {  id: number; managementSummary: CompanyManagementSummary; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyManagementSummary> {
            const localVarPath = this.basePath + '/company/companies/{id}/managementSummaryReports'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdManagementSummaryReportsPost');
            }
            // verify required parameter 'managementSummary' is set
            if (params.managementSummary == null) {
                throw new Error('Missing required parameter managementSummary when calling companyCompaniesIdManagementSummaryReportsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.managementSummary),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Management Summary By Id
         * @param id
         * @param reportId
         */
        public companyCompaniesIdManagementSummaryReportsReportIdDelete (params: {  id: number; reportId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/companies/{id}/managementSummaryReports/{reportId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'reportId' + '}', String(params.reportId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdManagementSummaryReportsReportIdDelete');
            }
            // verify required parameter 'reportId' is set
            if (params.reportId == null) {
                throw new Error('Missing required parameter reportId when calling companyCompaniesIdManagementSummaryReportsReportIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Management Summary By Id
         * @param id
         * @param reportId
         */
        public companyCompaniesIdManagementSummaryReportsReportIdGet (params: {  id: number; reportId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyManagementSummary> {
            const localVarPath = this.basePath + '/company/companies/{id}/managementSummaryReports/{reportId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'reportId' + '}', String(params.reportId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdManagementSummaryReportsReportIdGet');
            }
            // verify required parameter 'reportId' is set
            if (params.reportId == null) {
                throw new Error('Missing required parameter reportId when calling companyCompaniesIdManagementSummaryReportsReportIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Management Summary
         * @param id
         * @param reportId
         * @param operations
         */
        public companyCompaniesIdManagementSummaryReportsReportIdPatch (params: {  id: number; reportId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyManagementSummary> {
            const localVarPath = this.basePath + '/company/companies/{id}/managementSummaryReports/{reportId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'reportId' + '}', String(params.reportId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdManagementSummaryReportsReportIdPatch');
            }
            // verify required parameter 'reportId' is set
            if (params.reportId == null) {
                throw new Error('Missing required parameter reportId when calling companyCompaniesIdManagementSummaryReportsReportIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyCompaniesIdManagementSummaryReportsReportIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Management Summary
         * @param id
         * @param reportId
         * @param managementSummary
         */
        public companyCompaniesIdManagementSummaryReportsReportIdPut (params: {  id: number; reportId: number; managementSummary: CompanyManagementSummary; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyManagementSummary> {
            const localVarPath = this.basePath + '/company/companies/{id}/managementSummaryReports/{reportId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'reportId' + '}', String(params.reportId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdManagementSummaryReportsReportIdPut');
            }
            // verify required parameter 'reportId' is set
            if (params.reportId == null) {
                throw new Error('Missing required parameter reportId when calling companyCompaniesIdManagementSummaryReportsReportIdPut');
            }
            // verify required parameter 'managementSummary' is set
            if (params.managementSummary == null) {
                throw new Error('Missing required parameter managementSummary when calling companyCompaniesIdManagementSummaryReportsReportIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.managementSummary),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CompanyNoteTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Note Type Count
         * @param conditions
         */
        public companyNoteTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/noteTypes/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Note Type
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyNoteTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<NoteType>> {
            const localVarPath = this.basePath + '/company/noteTypes';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Note Type By Id
         * @param id
         */
        public companyNoteTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/noteTypes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyNoteTypesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Note Type By Id
         * @param id
         */
        public companyNoteTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<NoteType> {
            const localVarPath = this.basePath + '/company/noteTypes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyNoteTypesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Note Type
         * @param id
         * @param operations
         */
        public companyNoteTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<NoteType> {
            const localVarPath = this.basePath + '/company/noteTypes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyNoteTypesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyNoteTypesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Note Type
         * @param id
         * @param noteType
         */
        public companyNoteTypesIdPut (params: {  id: number; noteType: NoteType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<NoteType> {
            const localVarPath = this.basePath + '/company/noteTypes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyNoteTypesIdPut');
            }
            // verify required parameter 'noteType' is set
            if (params.noteType == null) {
                throw new Error('Missing required parameter noteType when calling companyNoteTypesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.noteType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Note Type
         * @param noteType
         */
        public companyNoteTypesPost (params: {  noteType: NoteType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<NoteType> {
            const localVarPath = this.basePath + '/company/noteTypes';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'noteType' is set
            if (params.noteType == null) {
                throw new Error('Missing required parameter noteType when calling companyNoteTypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.noteType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CompanyNotesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Company Notes Count
         * @param id
         * @param conditions
         */
        public companyCompaniesIdNotesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/companies/{id}/notes/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdNotesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Company Notes
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyCompaniesIdNotesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CompanyNote>> {
            const localVarPath = this.basePath + '/company/companies/{id}/notes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdNotesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Company Note By Id
         * @param id
         * @param noteId
         */
        public companyCompaniesIdNotesNoteIdDelete (params: {  id: number; noteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/companies/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdNotesNoteIdDelete');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling companyCompaniesIdNotesNoteIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Company Note By Id
         * @param id
         * @param noteId
         */
        public companyCompaniesIdNotesNoteIdGet (params: {  id: number; noteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyNote> {
            const localVarPath = this.basePath + '/company/companies/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdNotesNoteIdGet');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling companyCompaniesIdNotesNoteIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Company Note
         * @param id
         * @param noteId
         * @param operations
         */
        public companyCompaniesIdNotesNoteIdPatch (params: {  id: number; noteId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyNote> {
            const localVarPath = this.basePath + '/company/companies/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdNotesNoteIdPatch');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling companyCompaniesIdNotesNoteIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyCompaniesIdNotesNoteIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Company Note
         * @param id
         * @param noteId
         * @param companyNote
         */
        public companyCompaniesIdNotesNoteIdPut (params: {  id: number; noteId: number; companyNote: CompanyNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyNote> {
            const localVarPath = this.basePath + '/company/companies/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdNotesNoteIdPut');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling companyCompaniesIdNotesNoteIdPut');
            }
            // verify required parameter 'companyNote' is set
            if (params.companyNote == null) {
                throw new Error('Missing required parameter companyNote when calling companyCompaniesIdNotesNoteIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.companyNote),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Company Note
         * @param id
         * @param companyNote
         */
        public companyCompaniesIdNotesPost (params: {  id: number; companyNote: CompanyNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyNote> {
            const localVarPath = this.basePath + '/company/companies/{id}/notes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdNotesPost');
            }
            // verify required parameter 'companyNote' is set
            if (params.companyNote == null) {
                throw new Error('Missing required parameter companyNote when calling companyCompaniesIdNotesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.companyNote),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CompanyPickerItemsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Clear All Picker Items By Member
         * @param member
         * @param type
         */
        public companyCompanyPickerItemsClearPost (params: {  member?: string; type?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ClearPickerRequest> {
            const localVarPath = this.basePath + '/company/companyPickerItems/clear';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.member !== undefined) {
                queryParameters['member'] = params.member;
            }

            if (params.type !== undefined) {
                queryParameters['type'] = params.type;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Company Picker Items Count
         * @param conditions
         */
        public companyCompanyPickerItemsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/companyPickerItems/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Company Picker Items
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyCompanyPickerItemsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CompanyPickerItem>> {
            const localVarPath = this.basePath + '/company/companyPickerItems';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Company Picker Item
         * @param id
         */
        public companyCompanyPickerItemsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/companyPickerItems/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompanyPickerItemsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Company Picker Item By Id
         * @param id
         */
        public companyCompanyPickerItemsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyPickerItem> {
            const localVarPath = this.basePath + '/company/companyPickerItems/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompanyPickerItemsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Add Company Picker Item
         * @param companyPickerItem
         */
        public companyCompanyPickerItemsPost (params: {  companyPickerItem: CompanyPickerItem; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyPickerItem> {
            const localVarPath = this.basePath + '/company/companyPickerItems';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'companyPickerItem' is set
            if (params.companyPickerItem == null) {
                throw new Error('Missing required parameter companyPickerItem when calling companyCompanyPickerItemsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.companyPickerItem),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CompanySitesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Sites Count
         * @param id
         * @param conditions
         */
        public companyCompaniesIdSitesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/companies/{id}/sites/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdSitesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Sites
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyCompaniesIdSitesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CompanySite>> {
            const localVarPath = this.basePath + '/company/companies/{id}/sites'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdSitesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Site
         * @param id
         * @param site
         */
        public companyCompaniesIdSitesPost (params: {  id: number; site: CompanySite; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanySite> {
            const localVarPath = this.basePath + '/company/companies/{id}/sites'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdSitesPost');
            }
            // verify required parameter 'site' is set
            if (params.site == null) {
                throw new Error('Missing required parameter site when calling companyCompaniesIdSitesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.site),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Site By Id
         * @param id
         * @param siteId
         */
        public companyCompaniesIdSitesSiteIdDelete (params: {  id: number; siteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/companies/{id}/sites/{siteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'siteId' + '}', String(params.siteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdSitesSiteIdDelete');
            }
            // verify required parameter 'siteId' is set
            if (params.siteId == null) {
                throw new Error('Missing required parameter siteId when calling companyCompaniesIdSitesSiteIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Site By Id
         * @param id
         * @param siteId
         */
        public companyCompaniesIdSitesSiteIdGet (params: {  id: number; siteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanySite> {
            const localVarPath = this.basePath + '/company/companies/{id}/sites/{siteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'siteId' + '}', String(params.siteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdSitesSiteIdGet');
            }
            // verify required parameter 'siteId' is set
            if (params.siteId == null) {
                throw new Error('Missing required parameter siteId when calling companyCompaniesIdSitesSiteIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Site
         * @param id
         * @param siteId
         * @param operations
         */
        public companyCompaniesIdSitesSiteIdPatch (params: {  id: number; siteId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanySite> {
            const localVarPath = this.basePath + '/company/companies/{id}/sites/{siteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'siteId' + '}', String(params.siteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdSitesSiteIdPatch');
            }
            // verify required parameter 'siteId' is set
            if (params.siteId == null) {
                throw new Error('Missing required parameter siteId when calling companyCompaniesIdSitesSiteIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyCompaniesIdSitesSiteIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Site
         * @param id
         * @param siteId
         * @param site
         */
        public companyCompaniesIdSitesSiteIdPut (params: {  id: number; siteId: number; site: CompanySite; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanySite> {
            const localVarPath = this.basePath + '/company/companies/{id}/sites/{siteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'siteId' + '}', String(params.siteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdSitesSiteIdPut');
            }
            // verify required parameter 'siteId' is set
            if (params.siteId == null) {
                throw new Error('Missing required parameter siteId when calling companyCompaniesIdSitesSiteIdPut');
            }
            // verify required parameter 'site' is set
            if (params.site == null) {
                throw new Error('Missing required parameter site when calling companyCompaniesIdSitesSiteIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.site),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CompanyStatusesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Company Statuses Count
         * @param conditions
         */
        public companyCompaniesStatusesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/companies/statuses/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Company Statuses
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyCompaniesStatusesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CompanyStatus>> {
            const localVarPath = this.basePath + '/company/companies/statuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Company Status By Id
         * @param id
         */
        public companyCompaniesStatusesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/companies/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesStatusesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Company Status By Id
         * @param id
         */
        public companyCompaniesStatusesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyStatus> {
            const localVarPath = this.basePath + '/company/companies/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesStatusesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Company Status
         * @param id
         * @param operations
         */
        public companyCompaniesStatusesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyStatus> {
            const localVarPath = this.basePath + '/company/companies/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesStatusesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyCompaniesStatusesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Company Status
         * @param id
         * @param companyStatus
         */
        public companyCompaniesStatusesIdPut (params: {  id: number; companyStatus: CompanyStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyStatus> {
            const localVarPath = this.basePath + '/company/companies/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesStatusesIdPut');
            }
            // verify required parameter 'companyStatus' is set
            if (params.companyStatus == null) {
                throw new Error('Missing required parameter companyStatus when calling companyCompaniesStatusesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.companyStatus),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Company Status
         * @param companyStatus
         */
        public companyCompaniesStatusesPost (params: {  companyStatus: CompanyStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyStatus> {
            const localVarPath = this.basePath + '/company/companies/statuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'companyStatus' is set
            if (params.companyStatus == null) {
                throw new Error('Missing required parameter companyStatus when calling companyCompaniesStatusesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.companyStatus),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CompanyTeamsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Company Teams Count
         * @param id
         * @param conditions
         */
        public companyCompaniesIdTeamsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/companies/{id}/teams/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdTeamsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Company Teams
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyCompaniesIdTeamsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CompanyTeam>> {
            const localVarPath = this.basePath + '/company/companies/{id}/teams'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdTeamsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Company Team
         * @param id
         * @param companyTeam
         */
        public companyCompaniesIdTeamsPost (params: {  id: number; companyTeam: CompanyTeam; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyTeam> {
            const localVarPath = this.basePath + '/company/companies/{id}/teams'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdTeamsPost');
            }
            // verify required parameter 'companyTeam' is set
            if (params.companyTeam == null) {
                throw new Error('Missing required parameter companyTeam when calling companyCompaniesIdTeamsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.companyTeam),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Company Team By Id
         * @param id
         * @param teamId
         */
        public companyCompaniesIdTeamsTeamIdDelete (params: {  id: number; teamId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/companies/{id}/teams/{teamId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'teamId' + '}', String(params.teamId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdTeamsTeamIdDelete');
            }
            // verify required parameter 'teamId' is set
            if (params.teamId == null) {
                throw new Error('Missing required parameter teamId when calling companyCompaniesIdTeamsTeamIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Company Team By Id
         * @param id
         * @param teamId
         */
        public companyCompaniesIdTeamsTeamIdGet (params: {  id: number; teamId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyTeam> {
            const localVarPath = this.basePath + '/company/companies/{id}/teams/{teamId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'teamId' + '}', String(params.teamId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdTeamsTeamIdGet');
            }
            // verify required parameter 'teamId' is set
            if (params.teamId == null) {
                throw new Error('Missing required parameter teamId when calling companyCompaniesIdTeamsTeamIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Company Team
         * @param id
         * @param teamId
         * @param operations
         */
        public companyCompaniesIdTeamsTeamIdPatch (params: {  id: number; teamId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyTeam> {
            const localVarPath = this.basePath + '/company/companies/{id}/teams/{teamId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'teamId' + '}', String(params.teamId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdTeamsTeamIdPatch');
            }
            // verify required parameter 'teamId' is set
            if (params.teamId == null) {
                throw new Error('Missing required parameter teamId when calling companyCompaniesIdTeamsTeamIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyCompaniesIdTeamsTeamIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Company Team
         * @param id
         * @param teamId
         * @param companyTeam
         */
        public companyCompaniesIdTeamsTeamIdPut (params: {  id: number; teamId: number; companyTeam: CompanyTeam; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyTeam> {
            const localVarPath = this.basePath + '/company/companies/{id}/teams/{teamId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'teamId' + '}', String(params.teamId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesIdTeamsTeamIdPut');
            }
            // verify required parameter 'teamId' is set
            if (params.teamId == null) {
                throw new Error('Missing required parameter teamId when calling companyCompaniesIdTeamsTeamIdPut');
            }
            // verify required parameter 'companyTeam' is set
            if (params.companyTeam == null) {
                throw new Error('Missing required parameter companyTeam when calling companyCompaniesIdTeamsTeamIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.companyTeam),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CompanyTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Company Types Count
         * @param conditions
         */
        public companyCompaniesTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/companies/types/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Company Types
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyCompaniesTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CompanyType>> {
            const localVarPath = this.basePath + '/company/companies/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Company Type By Id
         * @param id
         */
        public companyCompaniesTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/companies/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesTypesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Company Type By Id
         * @param id
         */
        public companyCompaniesTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyType> {
            const localVarPath = this.basePath + '/company/companies/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesTypesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Company Type
         * @param id
         * @param operations
         */
        public companyCompaniesTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyType> {
            const localVarPath = this.basePath + '/company/companies/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesTypesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyCompaniesTypesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Company Type
         * @param id
         * @param companyType
         */
        public companyCompaniesTypesIdPut (params: {  id: number; companyType: CompanyType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyType> {
            const localVarPath = this.basePath + '/company/companies/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCompaniesTypesIdPut');
            }
            // verify required parameter 'companyType' is set
            if (params.companyType == null) {
                throw new Error('Missing required parameter companyType when calling companyCompaniesTypesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.companyType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Company Type
         * @param companyType
         */
        public companyCompaniesTypesPost (params: {  companyType: CompanyType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyType> {
            const localVarPath = this.basePath + '/company/companies/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'companyType' is set
            if (params.companyType == null) {
                throw new Error('Missing required parameter companyType when calling companyCompaniesTypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.companyType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ConfigurationStatusesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Configuration Statuses Count
         * @param conditions
         */
        public companyConfigurationsStatusesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/configurations/statuses/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Configuration Statuses
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyConfigurationsStatusesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ConfigurationStatus>> {
            const localVarPath = this.basePath + '/company/configurations/statuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Configuration Status By Id
         * @param id
         */
        public companyConfigurationsStatusesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/configurations/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsStatusesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Configuration Status By Id
         * @param id
         */
        public companyConfigurationsStatusesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationStatus> {
            const localVarPath = this.basePath + '/company/configurations/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsStatusesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Configuration Status
         * @param id
         * @param operations
         */
        public companyConfigurationsStatusesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationStatus> {
            const localVarPath = this.basePath + '/company/configurations/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsStatusesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyConfigurationsStatusesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Configuration Status
         * @param id
         * @param configurationStatus
         */
        public companyConfigurationsStatusesIdPut (params: {  id: number; configurationStatus: ConfigurationStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationStatus> {
            const localVarPath = this.basePath + '/company/configurations/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsStatusesIdPut');
            }
            // verify required parameter 'configurationStatus' is set
            if (params.configurationStatus == null) {
                throw new Error('Missing required parameter configurationStatus when calling companyConfigurationsStatusesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.configurationStatus),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Configuration Status
         * @param configurationStatus
         */
        public companyConfigurationsStatusesPost (params: {  configurationStatus: ConfigurationStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationStatus> {
            const localVarPath = this.basePath + '/company/configurations/statuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'configurationStatus' is set
            if (params.configurationStatus == null) {
                throw new Error('Missing required parameter configurationStatus when calling companyConfigurationsStatusesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.configurationStatus),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ConfigurationTypeQuestionValuesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Configuration Type Question Values Count
         * @param questionId
         * @param conditions
         */
        public companyConfigurationsTypesConfigurationTypeIdintQuestionsQuestionIdintValuesCountGet (params: {  questionId: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/configurations/types/{configurationTypeId:int}/questions/{questionId:int}/values/count'
                .replace('{' + 'questionId' + '}', String(params.questionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'questionId' is set
            if (params.questionId == null) {
                throw new Error('Missing required parameter questionId when calling companyConfigurationsTypesConfigurationTypeIdintQuestionsQuestionIdintValuesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Configuration Type Question Values
         * @param questionId
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyConfigurationsTypesConfigurationTypeIdintQuestionsQuestionIdintValuesGet (params: {  questionId: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ConfigurationTypeQuestionValue>> {
            const localVarPath = this.basePath + '/company/configurations/types/{configurationTypeId:int}/questions/{questionId:int}/values'
                .replace('{' + 'questionId' + '}', String(params.questionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'questionId' is set
            if (params.questionId == null) {
                throw new Error('Missing required parameter questionId when calling companyConfigurationsTypesConfigurationTypeIdintQuestionsQuestionIdintValuesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Configuration Type Question Value By Id
         * @param questionId
         * @param id
         */
        public companyConfigurationsTypesConfigurationTypeIdintQuestionsQuestionIdintValuesIdDelete (params: {  questionId: number; id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/configurations/types/{configurationTypeId:int}/questions/{questionId:int}/values/{Id}'
                .replace('{' + 'questionId' + '}', String(params.questionId))
                .replace('{' + 'Id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'questionId' is set
            if (params.questionId == null) {
                throw new Error('Missing required parameter questionId when calling companyConfigurationsTypesConfigurationTypeIdintQuestionsQuestionIdintValuesIdDelete');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsTypesConfigurationTypeIdintQuestionsQuestionIdintValuesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Configuration Type Question Value By Id
         * @param questionId
         * @param id
         */
        public companyConfigurationsTypesConfigurationTypeIdintQuestionsQuestionIdintValuesIdGet (params: {  questionId: number; id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationTypeQuestionValue> {
            const localVarPath = this.basePath + '/company/configurations/types/{configurationTypeId:int}/questions/{questionId:int}/values/{Id}'
                .replace('{' + 'questionId' + '}', String(params.questionId))
                .replace('{' + 'Id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'questionId' is set
            if (params.questionId == null) {
                throw new Error('Missing required parameter questionId when calling companyConfigurationsTypesConfigurationTypeIdintQuestionsQuestionIdintValuesIdGet');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsTypesConfigurationTypeIdintQuestionsQuestionIdintValuesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Configuration Type Question Value
         * @param configurationTypeId
         * @param questionId
         * @param id
         * @param operations
         */
        public companyConfigurationsTypesConfigurationTypeIdintQuestionsQuestionIdintValuesIdPatch (params: {  configurationTypeId: number; questionId: number; id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationTypeQuestionValue> {
            const localVarPath = this.basePath + '/company/configurations/types/{configurationTypeId:int}/questions/{questionId:int}/values/{Id}'
                .replace('{' + 'configurationTypeId' + '}', String(params.configurationTypeId))
                .replace('{' + 'questionId' + '}', String(params.questionId))
                .replace('{' + 'Id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'configurationTypeId' is set
            if (params.configurationTypeId == null) {
                throw new Error('Missing required parameter configurationTypeId when calling companyConfigurationsTypesConfigurationTypeIdintQuestionsQuestionIdintValuesIdPatch');
            }
            // verify required parameter 'questionId' is set
            if (params.questionId == null) {
                throw new Error('Missing required parameter questionId when calling companyConfigurationsTypesConfigurationTypeIdintQuestionsQuestionIdintValuesIdPatch');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsTypesConfigurationTypeIdintQuestionsQuestionIdintValuesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyConfigurationsTypesConfigurationTypeIdintQuestionsQuestionIdintValuesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Configuration Type Question Value
         * @param configurationTypeId
         * @param questionId
         * @param id
         * @param configurationTypeQuestionValue
         */
        public companyConfigurationsTypesConfigurationTypeIdintQuestionsQuestionIdintValuesIdPut (params: {  configurationTypeId: number; questionId: number; id: number; configurationTypeQuestionValue: ConfigurationTypeQuestionValue; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationTypeQuestionValue> {
            const localVarPath = this.basePath + '/company/configurations/types/{configurationTypeId:int}/questions/{questionId:int}/values/{Id}'
                .replace('{' + 'configurationTypeId' + '}', String(params.configurationTypeId))
                .replace('{' + 'questionId' + '}', String(params.questionId))
                .replace('{' + 'Id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'configurationTypeId' is set
            if (params.configurationTypeId == null) {
                throw new Error('Missing required parameter configurationTypeId when calling companyConfigurationsTypesConfigurationTypeIdintQuestionsQuestionIdintValuesIdPut');
            }
            // verify required parameter 'questionId' is set
            if (params.questionId == null) {
                throw new Error('Missing required parameter questionId when calling companyConfigurationsTypesConfigurationTypeIdintQuestionsQuestionIdintValuesIdPut');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsTypesConfigurationTypeIdintQuestionsQuestionIdintValuesIdPut');
            }
            // verify required parameter 'configurationTypeQuestionValue' is set
            if (params.configurationTypeQuestionValue == null) {
                throw new Error('Missing required parameter configurationTypeQuestionValue when calling companyConfigurationsTypesConfigurationTypeIdintQuestionsQuestionIdintValuesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.configurationTypeQuestionValue),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Configuration Type Question Value
         * @param configurationTypeId
         * @param questionId
         * @param configurationTypeQuestionValue
         */
        public companyConfigurationsTypesConfigurationTypeIdintQuestionsQuestionIdintValuesPost (params: {  configurationTypeId: number; questionId: number; configurationTypeQuestionValue: ConfigurationTypeQuestionValue; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationTypeQuestionValue> {
            const localVarPath = this.basePath + '/company/configurations/types/{configurationTypeId:int}/questions/{questionId:int}/values'
                .replace('{' + 'configurationTypeId' + '}', String(params.configurationTypeId))
                .replace('{' + 'questionId' + '}', String(params.questionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'configurationTypeId' is set
            if (params.configurationTypeId == null) {
                throw new Error('Missing required parameter configurationTypeId when calling companyConfigurationsTypesConfigurationTypeIdintQuestionsQuestionIdintValuesPost');
            }
            // verify required parameter 'questionId' is set
            if (params.questionId == null) {
                throw new Error('Missing required parameter questionId when calling companyConfigurationsTypesConfigurationTypeIdintQuestionsQuestionIdintValuesPost');
            }
            // verify required parameter 'configurationTypeQuestionValue' is set
            if (params.configurationTypeQuestionValue == null) {
                throw new Error('Missing required parameter configurationTypeQuestionValue when calling companyConfigurationsTypesConfigurationTypeIdintQuestionsQuestionIdintValuesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.configurationTypeQuestionValue),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ConfigurationTypeQuestionsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Configuration Type Questions Count
         * @param id
         * @param conditions
         */
        public companyConfigurationsTypesIdQuestionsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/configurations/types/{id}/questions/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsTypesIdQuestionsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Configuration Type Questions
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyConfigurationsTypesIdQuestionsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ConfigurationTypeQuestion>> {
            const localVarPath = this.basePath + '/company/configurations/types/{id}/questions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsTypesIdQuestionsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Configuration Type Question
         * @param id
         * @param configurationTypeQuestion
         */
        public companyConfigurationsTypesIdQuestionsPost (params: {  id: number; configurationTypeQuestion: ConfigurationTypeQuestion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationTypeQuestion> {
            const localVarPath = this.basePath + '/company/configurations/types/{id}/questions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsTypesIdQuestionsPost');
            }
            // verify required parameter 'configurationTypeQuestion' is set
            if (params.configurationTypeQuestion == null) {
                throw new Error('Missing required parameter configurationTypeQuestion when calling companyConfigurationsTypesIdQuestionsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.configurationTypeQuestion),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Configuration Type Question By Id
         * @param id
         * @param questionId
         */
        public companyConfigurationsTypesIdQuestionsQuestionIdDelete (params: {  id: number; questionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/configurations/types/{id}/questions/{questionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'questionId' + '}', String(params.questionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsTypesIdQuestionsQuestionIdDelete');
            }
            // verify required parameter 'questionId' is set
            if (params.questionId == null) {
                throw new Error('Missing required parameter questionId when calling companyConfigurationsTypesIdQuestionsQuestionIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Configuration Type Question By Id
         * @param id
         * @param questionId
         */
        public companyConfigurationsTypesIdQuestionsQuestionIdGet (params: {  id: number; questionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationTypeQuestion> {
            const localVarPath = this.basePath + '/company/configurations/types/{id}/questions/{questionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'questionId' + '}', String(params.questionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsTypesIdQuestionsQuestionIdGet');
            }
            // verify required parameter 'questionId' is set
            if (params.questionId == null) {
                throw new Error('Missing required parameter questionId when calling companyConfigurationsTypesIdQuestionsQuestionIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Configuration Type Question
         * @param id
         * @param questionId
         * @param operations
         */
        public companyConfigurationsTypesIdQuestionsQuestionIdPatch (params: {  id: number; questionId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationTypeQuestion> {
            const localVarPath = this.basePath + '/company/configurations/types/{id}/questions/{questionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'questionId' + '}', String(params.questionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsTypesIdQuestionsQuestionIdPatch');
            }
            // verify required parameter 'questionId' is set
            if (params.questionId == null) {
                throw new Error('Missing required parameter questionId when calling companyConfigurationsTypesIdQuestionsQuestionIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyConfigurationsTypesIdQuestionsQuestionIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Configuration Type Question
         * @param id
         * @param questionId
         * @param configurationTypeQuestion
         */
        public companyConfigurationsTypesIdQuestionsQuestionIdPut (params: {  id: number; questionId: number; configurationTypeQuestion: ConfigurationTypeQuestion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationTypeQuestion> {
            const localVarPath = this.basePath + '/company/configurations/types/{id}/questions/{questionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'questionId' + '}', String(params.questionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsTypesIdQuestionsQuestionIdPut');
            }
            // verify required parameter 'questionId' is set
            if (params.questionId == null) {
                throw new Error('Missing required parameter questionId when calling companyConfigurationsTypesIdQuestionsQuestionIdPut');
            }
            // verify required parameter 'configurationTypeQuestion' is set
            if (params.configurationTypeQuestion == null) {
                throw new Error('Missing required parameter configurationTypeQuestion when calling companyConfigurationsTypesIdQuestionsQuestionIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.configurationTypeQuestion),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ConfigurationTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Configuration Types Count
         * @param conditions
         */
        public companyConfigurationsTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/configurations/types/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Configuration Types
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyConfigurationsTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ConfigurationType>> {
            const localVarPath = this.basePath + '/company/configurations/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Configuration Type By Id
         * @param id
         */
        public companyConfigurationsTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/configurations/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsTypesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Configuration Type By Id
         * @param id
         */
        public companyConfigurationsTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationType> {
            const localVarPath = this.basePath + '/company/configurations/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsTypesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Configuration Type
         * @param id
         * @param operations
         */
        public companyConfigurationsTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationType> {
            const localVarPath = this.basePath + '/company/configurations/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsTypesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyConfigurationsTypesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Configuration Type
         * @param id
         * @param configurationType
         */
        public companyConfigurationsTypesIdPut (params: {  id: number; configurationType: ConfigurationType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationType> {
            const localVarPath = this.basePath + '/company/configurations/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsTypesIdPut');
            }
            // verify required parameter 'configurationType' is set
            if (params.configurationType == null) {
                throw new Error('Missing required parameter configurationType when calling companyConfigurationsTypesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.configurationType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Configuration Type
         * @param configurationType
         */
        public companyConfigurationsTypesPost (params: {  configurationType: ConfigurationType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationType> {
            const localVarPath = this.basePath + '/company/configurations/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'configurationType' is set
            if (params.configurationType == null) {
                throw new Error('Missing required parameter configurationType when calling companyConfigurationsTypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.configurationType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ConfigurationsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Configurations Count
         * @param conditions
         * @param managedIdentifier
         */
        public companyConfigurationsCountGet (params: {  conditions?: string; managedIdentifier?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/configurations/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.managedIdentifier !== undefined) {
                queryParameters['managedIdentifier'] = params.managedIdentifier;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Configurations
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         * @param managedIdentifier
         */
        public companyConfigurationsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; managedIdentifier?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Configuration>> {
            const localVarPath = this.basePath + '/company/configurations';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            if (params.managedIdentifier !== undefined) {
                queryParameters['managedIdentifier'] = params.managedIdentifier;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Configuration By Id
         * @param id
         */
        public companyConfigurationsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/configurations/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Configuration By Id
         * @param id
         */
        public companyConfigurationsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Configuration> {
            const localVarPath = this.basePath + '/company/configurations/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Configuration
         * @param id
         * @param operations
         * @param managementSolutionName
         * @param managedIdentifier
         * @param type
         * @param level
         * @param childConfigurationsMatchingOn
         * @param inactivateConfigurationsMatchingOn
         * @param inactiveConfigurationStatusId
         */
        public companyConfigurationsIdPatch (params: {  id: number; operations: Array<PatchOperation>; managementSolutionName?: string; managedIdentifier?: string; type?: string; level?: string; childConfigurationsMatchingOn?: string; inactivateConfigurationsMatchingOn?: string; inactiveConfigurationStatusId?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Configuration> {
            const localVarPath = this.basePath + '/company/configurations/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyConfigurationsIdPatch');
            }
            if (params.managementSolutionName !== undefined) {
                queryParameters['managementSolutionName'] = params.managementSolutionName;
            }

            if (params.managedIdentifier !== undefined) {
                queryParameters['managedIdentifier'] = params.managedIdentifier;
            }

            if (params.type !== undefined) {
                queryParameters['type'] = params.type;
            }

            if (params.level !== undefined) {
                queryParameters['level'] = params.level;
            }

            if (params.childConfigurationsMatchingOn !== undefined) {
                queryParameters['childConfigurationsMatchingOn'] = params.childConfigurationsMatchingOn;
            }

            if (params.inactivateConfigurationsMatchingOn !== undefined) {
                queryParameters['inactivateConfigurationsMatchingOn'] = params.inactivateConfigurationsMatchingOn;
            }

            if (params.inactiveConfigurationStatusId !== undefined) {
                queryParameters['inactiveConfigurationStatusId'] = params.inactiveConfigurationStatusId;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Configuration
         * @param id
         * @param configuration
         * @param managementSolutionName
         * @param managedIdentifier
         * @param type
         * @param level
         * @param childConfigurationsMatchingOn
         * @param inactivateConfigurationsMatchingOn
         * @param inactiveConfigurationStatusId
         */
        public companyConfigurationsIdPut (params: {  id: number; configuration: Configuration; managementSolutionName?: string; managedIdentifier?: string; type?: string; level?: string; childConfigurationsMatchingOn?: string; inactivateConfigurationsMatchingOn?: string; inactiveConfigurationStatusId?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Configuration> {
            const localVarPath = this.basePath + '/company/configurations/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyConfigurationsIdPut');
            }
            // verify required parameter 'configuration' is set
            if (params.configuration == null) {
                throw new Error('Missing required parameter configuration when calling companyConfigurationsIdPut');
            }
            if (params.managementSolutionName !== undefined) {
                queryParameters['managementSolutionName'] = params.managementSolutionName;
            }

            if (params.managedIdentifier !== undefined) {
                queryParameters['managedIdentifier'] = params.managedIdentifier;
            }

            if (params.type !== undefined) {
                queryParameters['type'] = params.type;
            }

            if (params.level !== undefined) {
                queryParameters['level'] = params.level;
            }

            if (params.childConfigurationsMatchingOn !== undefined) {
                queryParameters['childConfigurationsMatchingOn'] = params.childConfigurationsMatchingOn;
            }

            if (params.inactivateConfigurationsMatchingOn !== undefined) {
                queryParameters['inactivateConfigurationsMatchingOn'] = params.inactivateConfigurationsMatchingOn;
            }

            if (params.inactiveConfigurationStatusId !== undefined) {
                queryParameters['inactiveConfigurationStatusId'] = params.inactiveConfigurationStatusId;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.configuration),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Configuration
         * @param configuration
         * @param managementSolutionName
         * @param managedIdentifier
         * @param type
         * @param level
         * @param childConfigurationsMatchingOn
         * @param inactivateConfigurationsMatchingOn
         * @param inactiveConfigurationStatusId
         */
        public companyConfigurationsPost (params: {  configuration: Configuration; managementSolutionName?: string; managedIdentifier?: string; type?: string; level?: string; childConfigurationsMatchingOn?: string; inactivateConfigurationsMatchingOn?: string; inactiveConfigurationStatusId?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Configuration> {
            const localVarPath = this.basePath + '/company/configurations';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'configuration' is set
            if (params.configuration == null) {
                throw new Error('Missing required parameter configuration when calling companyConfigurationsPost');
            }
            if (params.managementSolutionName !== undefined) {
                queryParameters['managementSolutionName'] = params.managementSolutionName;
            }

            if (params.managedIdentifier !== undefined) {
                queryParameters['managedIdentifier'] = params.managedIdentifier;
            }

            if (params.type !== undefined) {
                queryParameters['type'] = params.type;
            }

            if (params.level !== undefined) {
                queryParameters['level'] = params.level;
            }

            if (params.childConfigurationsMatchingOn !== undefined) {
                queryParameters['childConfigurationsMatchingOn'] = params.childConfigurationsMatchingOn;
            }

            if (params.inactivateConfigurationsMatchingOn !== undefined) {
                queryParameters['inactivateConfigurationsMatchingOn'] = params.inactivateConfigurationsMatchingOn;
            }

            if (params.inactiveConfigurationStatusId !== undefined) {
                queryParameters['inactiveConfigurationStatusId'] = params.inactiveConfigurationStatusId;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.configuration),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ConnectWiseHostedSetupsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Connect Wise Hosted Setups Count
         * @param conditions
         */
        public systemConnectwisehostedsetupsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/connectwisehostedsetups/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Connect Wise Hosted Setups
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemConnectwisehostedsetupsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ConnectWiseHostedSetup>> {
            const localVarPath = this.basePath + '/system/connectwisehostedsetups';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Connect Wise Hosted Setup By Id
         * @param id
         */
        public systemConnectwisehostedsetupsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/connectwisehostedsetups/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemConnectwisehostedsetupsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Connect Wise Hosted Setup By Id
         * @param id
         */
        public systemConnectwisehostedsetupsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConnectWiseHostedSetup> {
            const localVarPath = this.basePath + '/system/connectwisehostedsetups/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemConnectwisehostedsetupsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Connect Wise Hosted Setup
         * @param id
         * @param operations
         */
        public systemConnectwisehostedsetupsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConnectWiseHostedSetup> {
            const localVarPath = this.basePath + '/system/connectwisehostedsetups/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemConnectwisehostedsetupsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemConnectwisehostedsetupsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Connect Wise Hosted Setup
         * @param id
         * @param connectWiseHostedSetup
         */
        public systemConnectwisehostedsetupsIdPut (params: {  id: number; connectWiseHostedSetup: ConnectWiseHostedSetup; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConnectWiseHostedSetup> {
            const localVarPath = this.basePath + '/system/connectwisehostedsetups/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemConnectwisehostedsetupsIdPut');
            }
            // verify required parameter 'connectWiseHostedSetup' is set
            if (params.connectWiseHostedSetup == null) {
                throw new Error('Missing required parameter connectWiseHostedSetup when calling systemConnectwisehostedsetupsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.connectWiseHostedSetup),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Connect Wise Hosted Setup
         * @param connectWiseHostedSetup
         */
        public systemConnectwisehostedsetupsPost (params: {  connectWiseHostedSetup: ConnectWiseHostedSetup; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConnectWiseHostedSetup> {
            const localVarPath = this.basePath + '/system/connectwisehostedsetups';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'connectWiseHostedSetup' is set
            if (params.connectWiseHostedSetup == null) {
                throw new Error('Missing required parameter connectWiseHostedSetup when calling systemConnectwisehostedsetupsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.connectWiseHostedSetup),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ContactCommunicationsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Delete Contact Communication By Id
         * @param id
         * @param communicationId
         */
        public companyContactsIdCommunicationsCommunicationIdDelete (params: {  id: number; communicationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/contacts/{id}/communications/{communicationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'communicationId' + '}', String(params.communicationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdCommunicationsCommunicationIdDelete');
            }
            // verify required parameter 'communicationId' is set
            if (params.communicationId == null) {
                throw new Error('Missing required parameter communicationId when calling companyContactsIdCommunicationsCommunicationIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Contact Communication By Id
         * @param id
         * @param communicationId
         */
        public companyContactsIdCommunicationsCommunicationIdGet (params: {  id: number; communicationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactCommunication> {
            const localVarPath = this.basePath + '/company/contacts/{id}/communications/{communicationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'communicationId' + '}', String(params.communicationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdCommunicationsCommunicationIdGet');
            }
            // verify required parameter 'communicationId' is set
            if (params.communicationId == null) {
                throw new Error('Missing required parameter communicationId when calling companyContactsIdCommunicationsCommunicationIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Contact Communication
         * @param id
         * @param communicationId
         * @param operations
         */
        public companyContactsIdCommunicationsCommunicationIdPatch (params: {  id: number; communicationId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactCommunication> {
            const localVarPath = this.basePath + '/company/contacts/{id}/communications/{communicationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'communicationId' + '}', String(params.communicationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdCommunicationsCommunicationIdPatch');
            }
            // verify required parameter 'communicationId' is set
            if (params.communicationId == null) {
                throw new Error('Missing required parameter communicationId when calling companyContactsIdCommunicationsCommunicationIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyContactsIdCommunicationsCommunicationIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Contact Communication
         * @param id
         * @param communicationId
         * @param contactCommunication
         */
        public companyContactsIdCommunicationsCommunicationIdPut (params: {  id: number; communicationId: number; contactCommunication: ContactCommunication; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactCommunication> {
            const localVarPath = this.basePath + '/company/contacts/{id}/communications/{communicationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'communicationId' + '}', String(params.communicationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdCommunicationsCommunicationIdPut');
            }
            // verify required parameter 'communicationId' is set
            if (params.communicationId == null) {
                throw new Error('Missing required parameter communicationId when calling companyContactsIdCommunicationsCommunicationIdPut');
            }
            // verify required parameter 'contactCommunication' is set
            if (params.contactCommunication == null) {
                throw new Error('Missing required parameter contactCommunication when calling companyContactsIdCommunicationsCommunicationIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.contactCommunication),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Contact Communications Count
         * @param id
         * @param conditions
         */
        public companyContactsIdCommunicationsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/contacts/{id}/communications/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdCommunicationsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Contact Communications
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyContactsIdCommunicationsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ContactCommunication>> {
            const localVarPath = this.basePath + '/company/contacts/{id}/communications'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdCommunicationsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Contact Communication
         * @param id
         * @param contactCommunication
         */
        public companyContactsIdCommunicationsPost (params: {  id: number; contactCommunication: ContactCommunication; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactCommunication> {
            const localVarPath = this.basePath + '/company/contacts/{id}/communications'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdCommunicationsPost');
            }
            // verify required parameter 'contactCommunication' is set
            if (params.contactCommunication == null) {
                throw new Error('Missing required parameter contactCommunication when calling companyContactsIdCommunicationsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.contactCommunication),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ContactDepartmentsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Contact Departments Count
         * @param conditions
         */
        public companyContactsDepartmentsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/contacts/departments/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Contact Departments
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyContactsDepartmentsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ContactDepartment>> {
            const localVarPath = this.basePath + '/company/contacts/departments';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Contact Department By Id
         * @param id
         */
        public companyContactsDepartmentsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/contacts/departments/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsDepartmentsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Contact Department By Id
         * @param id
         */
        public companyContactsDepartmentsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactDepartment> {
            const localVarPath = this.basePath + '/company/contacts/departments/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsDepartmentsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Contact Department
         * @param id
         * @param operations
         */
        public companyContactsDepartmentsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactDepartment> {
            const localVarPath = this.basePath + '/company/contacts/departments/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsDepartmentsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyContactsDepartmentsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Contact Department
         * @param id
         * @param contactDepartment
         */
        public companyContactsDepartmentsIdPut (params: {  id: number; contactDepartment: ContactDepartment; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactDepartment> {
            const localVarPath = this.basePath + '/company/contacts/departments/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsDepartmentsIdPut');
            }
            // verify required parameter 'contactDepartment' is set
            if (params.contactDepartment == null) {
                throw new Error('Missing required parameter contactDepartment when calling companyContactsDepartmentsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.contactDepartment),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Contact Department
         * @param contactDepartment
         */
        public companyContactsDepartmentsPost (params: {  contactDepartment: ContactDepartment; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactDepartment> {
            const localVarPath = this.basePath + '/company/contacts/departments';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'contactDepartment' is set
            if (params.contactDepartment == null) {
                throw new Error('Missing required parameter contactDepartment when calling companyContactsDepartmentsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.contactDepartment),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ContactGroupsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Contact Groups Count
         * @param id
         * @param conditions
         */
        public companyContactsIdGroupsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/contacts/{id}/groups/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdGroupsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Contact Groups
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyContactsIdGroupsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ContactGroup>> {
            const localVarPath = this.basePath + '/company/contacts/{id}/groups'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdGroupsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Contact Group By Id
         * @param id
         * @param groupid
         */
        public companyContactsIdGroupsGroupidDelete (params: {  id: number; groupid: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/contacts/{id}/groups/{groupid}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'groupid' + '}', String(params.groupid));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdGroupsGroupidDelete');
            }
            // verify required parameter 'groupid' is set
            if (params.groupid == null) {
                throw new Error('Missing required parameter groupid when calling companyContactsIdGroupsGroupidDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Contact Group By Id
         * @param id
         * @param groupid
         */
        public companyContactsIdGroupsGroupidGet (params: {  id: number; groupid: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactGroup> {
            const localVarPath = this.basePath + '/company/contacts/{id}/groups/{groupid}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'groupid' + '}', String(params.groupid));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdGroupsGroupidGet');
            }
            // verify required parameter 'groupid' is set
            if (params.groupid == null) {
                throw new Error('Missing required parameter groupid when calling companyContactsIdGroupsGroupidGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Contact Group
         * @param id
         * @param groupid
         * @param operations
         */
        public companyContactsIdGroupsGroupidPatch (params: {  id: number; groupid: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactGroup> {
            const localVarPath = this.basePath + '/company/contacts/{id}/groups/{groupid}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'groupid' + '}', String(params.groupid));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdGroupsGroupidPatch');
            }
            // verify required parameter 'groupid' is set
            if (params.groupid == null) {
                throw new Error('Missing required parameter groupid when calling companyContactsIdGroupsGroupidPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyContactsIdGroupsGroupidPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Contact Group
         * @param id
         * @param groupid
         * @param contactGroup
         */
        public companyContactsIdGroupsGroupidPut (params: {  id: number; groupid: number; contactGroup: ContactGroup; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactGroup> {
            const localVarPath = this.basePath + '/company/contacts/{id}/groups/{groupid}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'groupid' + '}', String(params.groupid));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdGroupsGroupidPut');
            }
            // verify required parameter 'groupid' is set
            if (params.groupid == null) {
                throw new Error('Missing required parameter groupid when calling companyContactsIdGroupsGroupidPut');
            }
            // verify required parameter 'contactGroup' is set
            if (params.contactGroup == null) {
                throw new Error('Missing required parameter contactGroup when calling companyContactsIdGroupsGroupidPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.contactGroup),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Contact Group
         * @param id
         * @param contactGroup
         */
        public companyContactsIdGroupsPost (params: {  id: number; contactGroup: ContactGroup; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactGroup> {
            const localVarPath = this.basePath + '/company/contacts/{id}/groups'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdGroupsPost');
            }
            // verify required parameter 'contactGroup' is set
            if (params.contactGroup == null) {
                throw new Error('Missing required parameter contactGroup when calling companyContactsIdGroupsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.contactGroup),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ContactNotesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Contact Notes Count
         * @param id
         * @param conditions
         */
        public companyContactsIdNotesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/contacts/{id}/notes/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdNotesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Contact Notes
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyContactsIdNotesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ContactNote>> {
            const localVarPath = this.basePath + '/company/contacts/{id}/notes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdNotesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Contact Note By Id
         * @param id
         * @param noteId
         */
        public companyContactsIdNotesNoteIdDelete (params: {  id: number; noteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/contacts/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdNotesNoteIdDelete');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling companyContactsIdNotesNoteIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Contact Note By Id
         * @param id
         * @param noteId
         */
        public companyContactsIdNotesNoteIdGet (params: {  id: number; noteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactNote> {
            const localVarPath = this.basePath + '/company/contacts/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdNotesNoteIdGet');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling companyContactsIdNotesNoteIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Contact Note
         * @param id
         * @param noteId
         * @param operations
         */
        public companyContactsIdNotesNoteIdPatch (params: {  id: number; noteId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactNote> {
            const localVarPath = this.basePath + '/company/contacts/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdNotesNoteIdPatch');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling companyContactsIdNotesNoteIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyContactsIdNotesNoteIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Contact Note
         * @param id
         * @param noteId
         * @param contactNote
         */
        public companyContactsIdNotesNoteIdPut (params: {  id: number; noteId: number; contactNote: ContactNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactNote> {
            const localVarPath = this.basePath + '/company/contacts/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdNotesNoteIdPut');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling companyContactsIdNotesNoteIdPut');
            }
            // verify required parameter 'contactNote' is set
            if (params.contactNote == null) {
                throw new Error('Missing required parameter contactNote when calling companyContactsIdNotesNoteIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.contactNote),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Contact Note
         * @param id
         * @param contactNote
         */
        public companyContactsIdNotesPost (params: {  id: number; contactNote: ContactNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactNote> {
            const localVarPath = this.basePath + '/company/contacts/{id}/notes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdNotesPost');
            }
            // verify required parameter 'contactNote' is set
            if (params.contactNote == null) {
                throw new Error('Missing required parameter contactNote when calling companyContactsIdNotesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.contactNote),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ContactRelationshipsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Contact Relationships Count
         * @param conditions
         */
        public companyContactsRelationshipsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/contacts/relationships/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Contact Relationships
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyContactsRelationshipsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ContactRelationship>> {
            const localVarPath = this.basePath + '/company/contacts/relationships';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Contact Relationship By Id
         * @param id
         */
        public companyContactsRelationshipsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/contacts/relationships/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsRelationshipsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Contact Relationship By Id
         * @param id
         */
        public companyContactsRelationshipsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactRelationship> {
            const localVarPath = this.basePath + '/company/contacts/relationships/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsRelationshipsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Contact Relationship
         * @param id
         * @param operations
         */
        public companyContactsRelationshipsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactRelationship> {
            const localVarPath = this.basePath + '/company/contacts/relationships/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsRelationshipsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyContactsRelationshipsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Contact Relationship
         * @param id
         * @param contactRelationship
         */
        public companyContactsRelationshipsIdPut (params: {  id: number; contactRelationship: ContactRelationship; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactRelationship> {
            const localVarPath = this.basePath + '/company/contacts/relationships/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsRelationshipsIdPut');
            }
            // verify required parameter 'contactRelationship' is set
            if (params.contactRelationship == null) {
                throw new Error('Missing required parameter contactRelationship when calling companyContactsRelationshipsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.contactRelationship),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Contact Relationship
         * @param contactRelationship
         */
        public companyContactsRelationshipsPost (params: {  contactRelationship: ContactRelationship; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactRelationship> {
            const localVarPath = this.basePath + '/company/contacts/relationships';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'contactRelationship' is set
            if (params.contactRelationship == null) {
                throw new Error('Missing required parameter contactRelationship when calling companyContactsRelationshipsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.contactRelationship),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ContactTracksApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Tracks Count
         * @param id
         * @param conditions
         */
        public companyContactsIdTracksCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/contacts/{id}/tracks/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdTracksCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Tracks
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyContactsIdTracksGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Track>> {
            const localVarPath = this.basePath + '/company/contacts/{id}/tracks'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdTracksGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Track
         * @param id
         * @param track
         */
        public companyContactsIdTracksPost (params: {  id: number; track: Track; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Track> {
            const localVarPath = this.basePath + '/company/contacts/{id}/tracks'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdTracksPost');
            }
            // verify required parameter 'track' is set
            if (params.track == null) {
                throw new Error('Missing required parameter track when calling companyContactsIdTracksPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.track),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Track By Id
         * @param id
         * @param trackId
         */
        public companyContactsIdTracksTrackIdDelete (params: {  id: number; trackId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/contacts/{id}/tracks/{trackId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'trackId' + '}', String(params.trackId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdTracksTrackIdDelete');
            }
            // verify required parameter 'trackId' is set
            if (params.trackId == null) {
                throw new Error('Missing required parameter trackId when calling companyContactsIdTracksTrackIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Track By Id
         * @param id
         * @param trackId
         */
        public companyContactsIdTracksTrackIdGet (params: {  id: number; trackId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Track> {
            const localVarPath = this.basePath + '/company/contacts/{id}/tracks/{trackId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'trackId' + '}', String(params.trackId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdTracksTrackIdGet');
            }
            // verify required parameter 'trackId' is set
            if (params.trackId == null) {
                throw new Error('Missing required parameter trackId when calling companyContactsIdTracksTrackIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ContactTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Contact Types Count
         * @param conditions
         */
        public companyContactsTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/contacts/types/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Contact Types
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyContactsTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ContactType>> {
            const localVarPath = this.basePath + '/company/contacts/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Contact Type By Id
         * @param id
         */
        public companyContactsTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/contacts/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsTypesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Contact Type By Id
         * @param id
         */
        public companyContactsTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactType> {
            const localVarPath = this.basePath + '/company/contacts/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsTypesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Contact Type
         * @param id
         * @param operations
         */
        public companyContactsTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactType> {
            const localVarPath = this.basePath + '/company/contacts/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsTypesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyContactsTypesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Contact Type
         * @param id
         * @param contactType
         */
        public companyContactsTypesIdPut (params: {  id: number; contactType: ContactType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactType> {
            const localVarPath = this.basePath + '/company/contacts/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsTypesIdPut');
            }
            // verify required parameter 'contactType' is set
            if (params.contactType == null) {
                throw new Error('Missing required parameter contactType when calling companyContactsTypesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.contactType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Contact Type
         * @param contactType
         */
        public companyContactsTypesPost (params: {  contactType: ContactType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactType> {
            const localVarPath = this.basePath + '/company/contacts/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'contactType' is set
            if (params.contactType == null) {
                throw new Error('Missing required parameter contactType when calling companyContactsTypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.contactType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ContactsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Contacts Count
         * @param conditions
         * @param customFieldConditions
         * @param childConditions
         */
        public companyContactsCountGet (params: {  conditions?: string; customFieldConditions?: string; childConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/contacts/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.customFieldConditions !== undefined) {
                queryParameters['customFieldConditions'] = params.customFieldConditions;
            }

            if (params.childConditions !== undefined) {
                queryParameters['childConditions'] = params.childConditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Contacts
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyContactsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Contact>> {
            const localVarPath = this.basePath + '/company/contacts';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Contact By Id
         * @param id
         * @param transferContactId
         */
        public companyContactsIdDelete (params: {  id: number; transferContactId?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/contacts/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdDelete');
            }
            if (params.transferContactId !== undefined) {
                queryParameters['transferContactId'] = params.transferContactId;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Contact By Id
         * @param id
         */
        public companyContactsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Contact> {
            const localVarPath = this.basePath + '/company/contacts/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Contact Image
         * @param id
         * @param useDefaultFlag
         * @param lastModified
         */
        public companyContactsIdImageGet (params: {  id: number; useDefaultFlag?: boolean; lastModified?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/contacts/{id}/image'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdImageGet');
            }
            if (params.useDefaultFlag !== undefined) {
                queryParameters['useDefaultFlag'] = params.useDefaultFlag;
            }

            if (params.lastModified !== undefined) {
                queryParameters['lastModified'] = params.lastModified;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Contact
         * @param id
         * @param operations
         */
        public companyContactsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Contact> {
            const localVarPath = this.basePath + '/company/contacts/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyContactsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Portal Security
         * @param id
         */
        public companyContactsIdPortalSecurityGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<PortalSecurity>> {
            const localVarPath = this.basePath + '/company/contacts/{id}/portalSecurity'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdPortalSecurityGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Contact
         * @param id
         * @param contact
         */
        public companyContactsIdPut (params: {  id: number; contact: Contact; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Contact> {
            const localVarPath = this.basePath + '/company/contacts/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyContactsIdPut');
            }
            // verify required parameter 'contact' is set
            if (params.contact == null) {
                throw new Error('Missing required parameter contact when calling companyContactsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.contact),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Contact
         * @param contact
         */
        public companyContactsPost (params: {  contact: Contact; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Contact> {
            const localVarPath = this.basePath + '/company/contacts';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'contact' is set
            if (params.contact == null) {
                throw new Error('Missing required parameter contact when calling companyContactsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.contact),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Request Password
         * @param request
         */
        public companyContactsRequestPasswordPost (params: {  request: RequestPasswordRequest; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/contacts/requestPassword';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'request' is set
            if (params.request == null) {
                throw new Error('Missing required parameter request when calling companyContactsRequestPasswordPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.request),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Validate Portal Credentials
         * @param request
         */
        public companyContactsValidatePortalCredentialsPost (params: {  request: ValidatePortalRequest; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ValidatePortalResponse> {
            const localVarPath = this.basePath + '/company/contacts/validatePortalCredentials';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'request' is set
            if (params.request == null) {
                throw new Error('Missing required parameter request when calling companyContactsValidatePortalCredentialsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.request),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CorporateStructureLevelsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Corporate Structure Levels Count
         * @param conditions
         */
        public systemMyCompanyCorporateStructureLevelsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/myCompany/corporateStructureLevels/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Corporate Structure Levels
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemMyCompanyCorporateStructureLevelsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CorporateStructureLevel>> {
            const localVarPath = this.basePath + '/system/myCompany/corporateStructureLevels';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Corporate Structure Level By Id
         * @param id
         */
        public systemMyCompanyCorporateStructureLevelsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CorporateStructureLevel> {
            const localVarPath = this.basePath + '/system/myCompany/corporateStructureLevels/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMyCompanyCorporateStructureLevelsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CorporateStructuresApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Corporate Structures Count
         * @param conditions
         */
        public systemMyCompanyCorporateStructureCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/myCompany/corporateStructure/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Corporate Structures
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemMyCompanyCorporateStructureGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CorporateStructure>> {
            const localVarPath = this.basePath + '/system/myCompany/corporateStructure';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Corporate Structure By Id
         * @param id
         */
        public systemMyCompanyCorporateStructureIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CorporateStructure> {
            const localVarPath = this.basePath + '/system/myCompany/corporateStructure/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMyCompanyCorporateStructureIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Corporate Structure
         * @param id
         * @param operations
         */
        public systemMyCompanyCorporateStructureIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CorporateStructure> {
            const localVarPath = this.basePath + '/system/myCompany/corporateStructure/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMyCompanyCorporateStructureIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemMyCompanyCorporateStructureIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Corporate Structure
         * @param id
         * @param corporateStructure
         */
        public systemMyCompanyCorporateStructureIdPut (params: {  id: number; corporateStructure: CorporateStructure; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CorporateStructure> {
            const localVarPath = this.basePath + '/system/myCompany/corporateStructure/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMyCompanyCorporateStructureIdPut');
            }
            // verify required parameter 'corporateStructure' is set
            if (params.corporateStructure == null) {
                throw new Error('Missing required parameter corporateStructure when calling systemMyCompanyCorporateStructureIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.corporateStructure),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CountriesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Countries Count
         * @param conditions
         */
        public companyCountriesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/countries/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Countries
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyCountriesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Country>> {
            const localVarPath = this.basePath + '/company/countries';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Country By Id
         * @param id
         */
        public companyCountriesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/countries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCountriesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Country By Id
         * @param id
         */
        public companyCountriesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Country> {
            const localVarPath = this.basePath + '/company/countries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCountriesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Country
         * @param id
         * @param operations
         */
        public companyCountriesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Country> {
            const localVarPath = this.basePath + '/company/countries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCountriesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyCountriesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Country
         * @param id
         * @param country
         */
        public companyCountriesIdPut (params: {  id: number; country: Country; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Country> {
            const localVarPath = this.basePath + '/company/countries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyCountriesIdPut');
            }
            // verify required parameter 'country' is set
            if (params.country == null) {
                throw new Error('Missing required parameter country when calling companyCountriesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.country),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Country
         * @param country
         */
        public companyCountriesPost (params: {  country: Country; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Country> {
            const localVarPath = this.basePath + '/company/countries';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'country' is set
            if (params.country == null) {
                throw new Error('Missing required parameter country when calling companyCountriesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.country),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CrmsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Crms Count
         * @param conditions
         */
        public systemMyCompanyCrmCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/myCompany/crm/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Crms
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemMyCompanyCrmGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Crm>> {
            const localVarPath = this.basePath + '/system/myCompany/crm';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Crm By Id
         * @param id
         */
        public systemMyCompanyCrmIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Crm> {
            const localVarPath = this.basePath + '/system/myCompany/crm/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMyCompanyCrmIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Crm
         * @param id
         * @param operations
         */
        public systemMyCompanyCrmIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Crm> {
            const localVarPath = this.basePath + '/system/myCompany/crm/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMyCompanyCrmIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemMyCompanyCrmIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Crm
         * @param id
         * @param crm
         */
        public systemMyCompanyCrmIdPut (params: {  id: number; crm: Crm; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Crm> {
            const localVarPath = this.basePath + '/system/myCompany/crm/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMyCompanyCrmIdPut');
            }
            // verify required parameter 'crm' is set
            if (params.crm == null) {
                throw new Error('Missing required parameter crm when calling systemMyCompanyCrmIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.crm),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CurrenciesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Currencies Count
         * @param conditions
         */
        public financeCurrenciesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/currencies/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Currencies
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeCurrenciesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Currency>> {
            const localVarPath = this.basePath + '/finance/currencies';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Currency By Id
         * @param id
         */
        public financeCurrenciesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/currencies/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeCurrenciesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Currency By Id
         * @param id
         */
        public financeCurrenciesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Currency> {
            const localVarPath = this.basePath + '/finance/currencies/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeCurrenciesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Currency
         * @param id
         * @param operations
         */
        public financeCurrenciesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Currency> {
            const localVarPath = this.basePath + '/finance/currencies/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeCurrenciesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeCurrenciesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Currency
         * @param id
         * @param currency
         */
        public financeCurrenciesIdPut (params: {  id: number; currency: Currency; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Currency> {
            const localVarPath = this.basePath + '/finance/currencies/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeCurrenciesIdPut');
            }
            // verify required parameter 'currency' is set
            if (params.currency == null) {
                throw new Error('Missing required parameter currency when calling financeCurrenciesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.currency),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Currency
         * @param currency
         */
        public financeCurrenciesPost (params: {  currency: Currency; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Currency> {
            const localVarPath = this.basePath + '/finance/currencies';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'currency' is set
            if (params.currency == null) {
                throw new Error('Missing required parameter currency when calling financeCurrenciesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.currency),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CustomReportParametersApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Custom Report Parameters Count
         * @param id
         * @param conditions
         */
        public systemCustomReportsIdParametersCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/customReports/{id}/parameters/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemCustomReportsIdParametersCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Custom Report Parameters
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemCustomReportsIdParametersGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CustomReportParameter>> {
            const localVarPath = this.basePath + '/system/customReports/{id}/parameters'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemCustomReportsIdParametersGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Custom Report Parameter By Id
         * @param id
         * @param parameterId
         */
        public systemCustomReportsIdParametersParameterIdDelete (params: {  id: number; parameterId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/customReports/{id}/parameters/{parameterId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'parameterId' + '}', String(params.parameterId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemCustomReportsIdParametersParameterIdDelete');
            }
            // verify required parameter 'parameterId' is set
            if (params.parameterId == null) {
                throw new Error('Missing required parameter parameterId when calling systemCustomReportsIdParametersParameterIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Custom Report Parameter By Id
         * @param id
         * @param parameterId
         */
        public systemCustomReportsIdParametersParameterIdGet (params: {  id: number; parameterId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CustomReportParameter> {
            const localVarPath = this.basePath + '/system/customReports/{id}/parameters/{parameterId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'parameterId' + '}', String(params.parameterId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemCustomReportsIdParametersParameterIdGet');
            }
            // verify required parameter 'parameterId' is set
            if (params.parameterId == null) {
                throw new Error('Missing required parameter parameterId when calling systemCustomReportsIdParametersParameterIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Custom Report Parameter
         * @param id
         * @param parameterId
         * @param operations
         */
        public systemCustomReportsIdParametersParameterIdPatch (params: {  id: number; parameterId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CustomReportParameter> {
            const localVarPath = this.basePath + '/system/customReports/{id}/parameters/{parameterId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'parameterId' + '}', String(params.parameterId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemCustomReportsIdParametersParameterIdPatch');
            }
            // verify required parameter 'parameterId' is set
            if (params.parameterId == null) {
                throw new Error('Missing required parameter parameterId when calling systemCustomReportsIdParametersParameterIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemCustomReportsIdParametersParameterIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Custom Report Parameter
         * @param id
         * @param parameterId
         * @param customReportParameter
         */
        public systemCustomReportsIdParametersParameterIdPut (params: {  id: number; parameterId: number; customReportParameter: CustomReportParameter; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CustomReportParameter> {
            const localVarPath = this.basePath + '/system/customReports/{id}/parameters/{parameterId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'parameterId' + '}', String(params.parameterId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemCustomReportsIdParametersParameterIdPut');
            }
            // verify required parameter 'parameterId' is set
            if (params.parameterId == null) {
                throw new Error('Missing required parameter parameterId when calling systemCustomReportsIdParametersParameterIdPut');
            }
            // verify required parameter 'customReportParameter' is set
            if (params.customReportParameter == null) {
                throw new Error('Missing required parameter customReportParameter when calling systemCustomReportsIdParametersParameterIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.customReportParameter),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Custom Report Parameter
         * @param id
         * @param customReportParameter
         */
        public systemCustomReportsIdParametersPost (params: {  id: number; customReportParameter: CustomReportParameter; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CustomReportParameter> {
            const localVarPath = this.basePath + '/system/customReports/{id}/parameters'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemCustomReportsIdParametersPost');
            }
            // verify required parameter 'customReportParameter' is set
            if (params.customReportParameter == null) {
                throw new Error('Missing required parameter customReportParameter when calling systemCustomReportsIdParametersPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.customReportParameter),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CustomReportsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Custom Report Count
         * @param conditions
         */
        public systemCustomReportsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/customReports/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Custom Report
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemCustomReportsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CustomReport>> {
            const localVarPath = this.basePath + '/system/customReports';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Custom Report By Id
         * @param id
         */
        public systemCustomReportsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/customReports/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemCustomReportsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Custom Report By Id
         * @param id
         */
        public systemCustomReportsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CustomReport> {
            const localVarPath = this.basePath + '/system/customReports/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemCustomReportsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Custom Report
         * @param id
         * @param operations
         */
        public systemCustomReportsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CustomReport> {
            const localVarPath = this.basePath + '/system/customReports/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemCustomReportsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemCustomReportsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Custom Report
         * @param id
         * @param customReport
         */
        public systemCustomReportsIdPut (params: {  id: number; customReport: CustomReport; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CustomReport> {
            const localVarPath = this.basePath + '/system/customReports/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemCustomReportsIdPut');
            }
            // verify required parameter 'customReport' is set
            if (params.customReport == null) {
                throw new Error('Missing required parameter customReport when calling systemCustomReportsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.customReport),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Custom Report
         * @param customReport
         */
        public systemCustomReportsPost (params: {  customReport: CustomReport; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CustomReport> {
            const localVarPath = this.basePath + '/system/customReports';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'customReport' is set
            if (params.customReport == null) {
                throw new Error('Missing required parameter customReport when calling systemCustomReportsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.customReport),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class DeliveryMethodsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Delivery Method Count
         * @param conditions
         */
        public financeDeliveryMethodsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/deliveryMethods/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Delivery Method
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeDeliveryMethodsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<DeliveryMethod>> {
            const localVarPath = this.basePath + '/finance/deliveryMethods';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Delivery Method By Id
         * @param id
         */
        public financeDeliveryMethodsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/deliveryMethods/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeDeliveryMethodsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Delivery Method By Id
         * @param id
         */
        public financeDeliveryMethodsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<DeliveryMethod> {
            const localVarPath = this.basePath + '/finance/deliveryMethods/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeDeliveryMethodsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Delivery Method
         * @param id
         * @param operations
         */
        public financeDeliveryMethodsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<DeliveryMethod> {
            const localVarPath = this.basePath + '/finance/deliveryMethods/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeDeliveryMethodsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeDeliveryMethodsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Delivery Method
         * @param id
         * @param deliveryMethod
         */
        public financeDeliveryMethodsIdPut (params: {  id: number; deliveryMethod: DeliveryMethod; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<DeliveryMethod> {
            const localVarPath = this.basePath + '/finance/deliveryMethods/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeDeliveryMethodsIdPut');
            }
            // verify required parameter 'deliveryMethod' is set
            if (params.deliveryMethod == null) {
                throw new Error('Missing required parameter deliveryMethod when calling financeDeliveryMethodsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.deliveryMethod),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Delivery Method
         * @param deliveryMethod
         */
        public financeDeliveryMethodsPost (params: {  deliveryMethod: DeliveryMethod; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<DeliveryMethod> {
            const localVarPath = this.basePath + '/finance/deliveryMethods';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'deliveryMethod' is set
            if (params.deliveryMethod == null) {
                throw new Error('Missing required parameter deliveryMethod when calling financeDeliveryMethodsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.deliveryMethod),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class DepartmentLocationsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Department Location Count
         * @param id
         * @param conditions
         */
        public systemDepartmentsIdLocationsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/departments/{id}/locations/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemDepartmentsIdLocationsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Department Location
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemDepartmentsIdLocationsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<DepartmentLocation>> {
            const localVarPath = this.basePath + '/system/departments/{id}/locations'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemDepartmentsIdLocationsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Department Location By Id
         * @param id
         * @param locationId
         */
        public systemDepartmentsIdLocationsLocationIdDelete (params: {  id: number; locationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/departments/{id}/locations/{locationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'locationId' + '}', String(params.locationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemDepartmentsIdLocationsLocationIdDelete');
            }
            // verify required parameter 'locationId' is set
            if (params.locationId == null) {
                throw new Error('Missing required parameter locationId when calling systemDepartmentsIdLocationsLocationIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Department Location By Id
         * @param id
         * @param locationId
         */
        public systemDepartmentsIdLocationsLocationIdGet (params: {  id: number; locationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<DepartmentLocation> {
            const localVarPath = this.basePath + '/system/departments/{id}/locations/{locationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'locationId' + '}', String(params.locationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemDepartmentsIdLocationsLocationIdGet');
            }
            // verify required parameter 'locationId' is set
            if (params.locationId == null) {
                throw new Error('Missing required parameter locationId when calling systemDepartmentsIdLocationsLocationIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Department Location
         * @param id
         * @param locationId
         * @param operations
         */
        public systemDepartmentsIdLocationsLocationIdPatch (params: {  id: number; locationId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<DepartmentLocation> {
            const localVarPath = this.basePath + '/system/departments/{id}/locations/{locationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'locationId' + '}', String(params.locationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemDepartmentsIdLocationsLocationIdPatch');
            }
            // verify required parameter 'locationId' is set
            if (params.locationId == null) {
                throw new Error('Missing required parameter locationId when calling systemDepartmentsIdLocationsLocationIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemDepartmentsIdLocationsLocationIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Company Team
         * @param id
         * @param locationId
         * @param departmentLocation
         */
        public systemDepartmentsIdLocationsLocationIdPut (params: {  id: number; locationId: number; departmentLocation: DepartmentLocation; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<DepartmentLocation> {
            const localVarPath = this.basePath + '/system/departments/{id}/locations/{locationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'locationId' + '}', String(params.locationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemDepartmentsIdLocationsLocationIdPut');
            }
            // verify required parameter 'locationId' is set
            if (params.locationId == null) {
                throw new Error('Missing required parameter locationId when calling systemDepartmentsIdLocationsLocationIdPut');
            }
            // verify required parameter 'departmentLocation' is set
            if (params.departmentLocation == null) {
                throw new Error('Missing required parameter departmentLocation when calling systemDepartmentsIdLocationsLocationIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.departmentLocation),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Department Location
         * @param id
         * @param departmentLocation
         */
        public systemDepartmentsIdLocationsPost (params: {  id: number; departmentLocation: DepartmentLocation; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<DepartmentLocation> {
            const localVarPath = this.basePath + '/system/departments/{id}/locations'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemDepartmentsIdLocationsPost');
            }
            // verify required parameter 'departmentLocation' is set
            if (params.departmentLocation == null) {
                throw new Error('Missing required parameter departmentLocation when calling systemDepartmentsIdLocationsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.departmentLocation),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class DepartmentsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Department Count
         * @param conditions
         */
        public systemDepartmentsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/departments/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Department
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemDepartmentsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Department>> {
            const localVarPath = this.basePath + '/system/departments';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Department By Id
         * @param id
         */
        public systemDepartmentsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/departments/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemDepartmentsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Department By Id
         * @param id
         */
        public systemDepartmentsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Department> {
            const localVarPath = this.basePath + '/system/departments/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemDepartmentsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Department
         * @param id
         * @param operations
         */
        public systemDepartmentsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Department> {
            const localVarPath = this.basePath + '/system/departments/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemDepartmentsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemDepartmentsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Department
         * @param id
         * @param department
         */
        public systemDepartmentsIdPut (params: {  id: number; department: Department; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Department> {
            const localVarPath = this.basePath + '/system/departments/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemDepartmentsIdPut');
            }
            // verify required parameter 'department' is set
            if (params.department == null) {
                throw new Error('Missing required parameter department when calling systemDepartmentsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.department),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Department
         * @param department
         */
        public systemDepartmentsPost (params: {  department: Department; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Department> {
            const localVarPath = this.basePath + '/system/departments';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'department' is set
            if (params.department == null) {
                throw new Error('Missing required parameter department when calling systemDepartmentsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.department),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class DocumentsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Documents Info Count
         * @param recordType
         * @param recordId
         */
        public systemDocumentsCountGet (params: {  recordType?: string; recordId?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/documents/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.recordType !== undefined) {
                queryParameters['recordType'] = params.recordType;
            }

            if (params.recordId !== undefined) {
                queryParameters['recordId'] = params.recordId;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Documents Info
         * @param recordType
         * @param recordId
         * @param page
         * @param pageSize
         */
        public systemDocumentsGet (params: {  recordType?: string; recordId?: number; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<DocumentInfo>> {
            const localVarPath = this.basePath + '/system/documents';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.recordType !== undefined) {
                queryParameters['recordType'] = params.recordType;
            }

            if (params.recordId !== undefined) {
                queryParameters['recordId'] = params.recordId;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Document Info By Id
         * @param id
         */
        public systemDocumentsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/documents/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemDocumentsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Download Document
         * @param id
         * @param lastModified
         */
        public systemDocumentsIdDownloadGet (params: {  id: number; lastModified?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/documents/{id}/download'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemDocumentsIdDownloadGet');
            }
            if (params.lastModified !== undefined) {
                queryParameters['lastModified'] = params.lastModified;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Document Info By Id
         * @param id
         */
        public systemDocumentsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<DocumentInfo> {
            const localVarPath = this.basePath + '/system/documents/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemDocumentsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Document By Id
         * @param id
         * @param recordId Entity id
         * @param recordType Entity type
         * @param title Document title
         * @param url Document url
         * @param file File to upload
         * @param privateFlag Indicates if document is private
         * @param readOnlyFlag Indicates if document is readonly
         * @param isAvatar Indicates if document contains an avatar
         */
        public systemDocumentsIdPost (params: {  id: number; recordId: number; recordType: string; title: string; url: string; file?: any; privateFlag?: boolean; readOnlyFlag?: boolean; isAvatar?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<DocumentInfo> {
            const localVarPath = this.basePath + '/system/documents/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            let formParams: any = {};
            headerParams['Content-Type'] = 'application/x-www-form-urlencoded';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemDocumentsIdPost');
            }
            // verify required parameter 'recordId' is set
            if (params.recordId == null) {
                throw new Error('Missing required parameter recordId when calling systemDocumentsIdPost');
            }
            // verify required parameter 'recordType' is set
            if (params.recordType == null) {
                throw new Error('Missing required parameter recordType when calling systemDocumentsIdPost');
            }
            // verify required parameter 'title' is set
            if (params.title == null) {
                throw new Error('Missing required parameter title when calling systemDocumentsIdPost');
            }
            // verify required parameter 'url' is set
            if (params.url == null) {
                throw new Error('Missing required parameter url when calling systemDocumentsIdPost');
            }
            formParams['file'] = params.file;

            formParams['recordId'] = params.recordId;

            formParams['recordType'] = params.recordType;

            formParams['title'] = params.title;

            formParams['url'] = params.url;

            formParams['privateFlag'] = params.privateFlag;

            formParams['readOnlyFlag'] = params.readOnlyFlag;

            formParams['isAvatar'] = params.isAvatar;

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                                body: querystring.stringify(formParams),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Insert Document
         * @param recordType Entity type
         * @param title Document title
         * @param url Document url
         * @param file File to upload
         * @param recordId Entity id
         * @param privateFlag Indicates if document is private
         * @param readOnlyFlag Indicates if document is readonly
         * @param isAvatar Indicates if document contains an avatar
         */
        public systemDocumentsPost (params: {  recordType: string; title: string; url: string; file?: any; recordId?: number; privateFlag?: boolean; readOnlyFlag?: boolean; isAvatar?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<DocumentInfo> {
            const localVarPath = this.basePath + '/system/documents';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            let formParams: any = {};
            headerParams['Content-Type'] = 'application/x-www-form-urlencoded';

            // verify required parameter 'recordType' is set
            if (params.recordType == null) {
                throw new Error('Missing required parameter recordType when calling systemDocumentsPost');
            }
            // verify required parameter 'title' is set
            if (params.title == null) {
                throw new Error('Missing required parameter title when calling systemDocumentsPost');
            }
            // verify required parameter 'url' is set
            if (params.url == null) {
                throw new Error('Missing required parameter url when calling systemDocumentsPost');
            }
            formParams['file'] = params.file;

            formParams['recordId'] = params.recordId;

            formParams['recordType'] = params.recordType;

            formParams['title'] = params.title;

            formParams['url'] = params.url;

            formParams['privateFlag'] = params.privateFlag;

            formParams['readOnlyFlag'] = params.readOnlyFlag;

            formParams['isAvatar'] = params.isAvatar;

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                                body: querystring.stringify(formParams),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Upload Sample Page
         */
        public systemDocumentsUploadsampleGet (params: {  }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/documents/uploadsample';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class DocumentsSetupApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Documents
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemMycompanyDocumentsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<DocumentSetup>> {
            const localVarPath = this.basePath + '/system/mycompany/documents';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Document By Id
         * @param id
         */
        public systemMycompanyDocumentsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<DocumentSetup> {
            const localVarPath = this.basePath + '/system/mycompany/documents/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMycompanyDocumentsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Document
         * @param id
         * @param operations
         */
        public systemMycompanyDocumentsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<DocumentSetup> {
            const localVarPath = this.basePath + '/system/mycompany/documents/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMycompanyDocumentsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemMycompanyDocumentsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Document
         * @param id
         * @param document
         */
        public systemMycompanyDocumentsIdPut (params: {  id: number; document: DocumentSetup; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<DocumentSetup> {
            const localVarPath = this.basePath + '/system/mycompany/documents/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMycompanyDocumentsIdPut');
            }
            // verify required parameter 'document' is set
            if (params.document == null) {
                throw new Error('Missing required parameter document when calling systemMycompanyDocumentsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.document),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class EmailConnectorParsingRulesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Email Connector Parsing Rule Count
         * @param id
         * @param styleId
         * @param conditions
         */
        public systemEmailConnectorsIdParsingStylesStyleIdParsingRulesCountGet (params: {  id: number; styleId: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/emailConnectors/{id}/parsingStyles/{styleId}/parsingRules/count'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'styleId' + '}', String(params.styleId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemEmailConnectorsIdParsingStylesStyleIdParsingRulesCountGet');
            }
            // verify required parameter 'styleId' is set
            if (params.styleId == null) {
                throw new Error('Missing required parameter styleId when calling systemEmailConnectorsIdParsingStylesStyleIdParsingRulesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Email Connector Parsing Rules
         * @param id
         * @param styleId
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemEmailConnectorsIdParsingStylesStyleIdParsingRulesGet (params: {  id: number; styleId: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<EmailConnectorParsingRule>> {
            const localVarPath = this.basePath + '/system/emailConnectors/{id}/parsingStyles/{styleId}/parsingRules'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'styleId' + '}', String(params.styleId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemEmailConnectorsIdParsingStylesStyleIdParsingRulesGet');
            }
            // verify required parameter 'styleId' is set
            if (params.styleId == null) {
                throw new Error('Missing required parameter styleId when calling systemEmailConnectorsIdParsingStylesStyleIdParsingRulesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Email Connector Parsing Rule
         * @param id
         * @param styleId
         * @param emailConnectorParsingRule
         */
        public systemEmailConnectorsIdParsingStylesStyleIdParsingRulesPost (params: {  id: number; styleId: number; emailConnectorParsingRule: EmailConnectorParsingRule; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<EmailConnectorParsingRule> {
            const localVarPath = this.basePath + '/system/emailConnectors/{id}/parsingStyles/{styleId}/parsingRules'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'styleId' + '}', String(params.styleId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemEmailConnectorsIdParsingStylesStyleIdParsingRulesPost');
            }
            // verify required parameter 'styleId' is set
            if (params.styleId == null) {
                throw new Error('Missing required parameter styleId when calling systemEmailConnectorsIdParsingStylesStyleIdParsingRulesPost');
            }
            // verify required parameter 'emailConnectorParsingRule' is set
            if (params.emailConnectorParsingRule == null) {
                throw new Error('Missing required parameter emailConnectorParsingRule when calling systemEmailConnectorsIdParsingStylesStyleIdParsingRulesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.emailConnectorParsingRule),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Email Connector Parsing Rule By Id
         * @param id
         * @param styleId
         * @param ruleId
         */
        public systemEmailConnectorsIdParsingStylesStyleIdParsingRulesRuleIdDelete (params: {  id: number; styleId: number; ruleId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/emailConnectors/{id}/parsingStyles/{styleId}/parsingRules/{ruleId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'styleId' + '}', String(params.styleId))
                .replace('{' + 'ruleId' + '}', String(params.ruleId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemEmailConnectorsIdParsingStylesStyleIdParsingRulesRuleIdDelete');
            }
            // verify required parameter 'styleId' is set
            if (params.styleId == null) {
                throw new Error('Missing required parameter styleId when calling systemEmailConnectorsIdParsingStylesStyleIdParsingRulesRuleIdDelete');
            }
            // verify required parameter 'ruleId' is set
            if (params.ruleId == null) {
                throw new Error('Missing required parameter ruleId when calling systemEmailConnectorsIdParsingStylesStyleIdParsingRulesRuleIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Email Connector Parsing Rule By Id
         * @param id
         * @param styleId
         * @param ruleId
         */
        public systemEmailConnectorsIdParsingStylesStyleIdParsingRulesRuleIdGet (params: {  id: number; styleId: number; ruleId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<EmailConnectorParsingRule> {
            const localVarPath = this.basePath + '/system/emailConnectors/{id}/parsingStyles/{styleId}/parsingRules/{ruleId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'styleId' + '}', String(params.styleId))
                .replace('{' + 'ruleId' + '}', String(params.ruleId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemEmailConnectorsIdParsingStylesStyleIdParsingRulesRuleIdGet');
            }
            // verify required parameter 'styleId' is set
            if (params.styleId == null) {
                throw new Error('Missing required parameter styleId when calling systemEmailConnectorsIdParsingStylesStyleIdParsingRulesRuleIdGet');
            }
            // verify required parameter 'ruleId' is set
            if (params.ruleId == null) {
                throw new Error('Missing required parameter ruleId when calling systemEmailConnectorsIdParsingStylesStyleIdParsingRulesRuleIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Email Connector Parsing Rule
         * @param id
         * @param styleId
         * @param ruleId
         * @param operations
         */
        public systemEmailConnectorsIdParsingStylesStyleIdParsingRulesRuleIdPatch (params: {  id: number; styleId: number; ruleId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<EmailConnectorParsingRule> {
            const localVarPath = this.basePath + '/system/emailConnectors/{id}/parsingStyles/{styleId}/parsingRules/{ruleId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'styleId' + '}', String(params.styleId))
                .replace('{' + 'ruleId' + '}', String(params.ruleId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemEmailConnectorsIdParsingStylesStyleIdParsingRulesRuleIdPatch');
            }
            // verify required parameter 'styleId' is set
            if (params.styleId == null) {
                throw new Error('Missing required parameter styleId when calling systemEmailConnectorsIdParsingStylesStyleIdParsingRulesRuleIdPatch');
            }
            // verify required parameter 'ruleId' is set
            if (params.ruleId == null) {
                throw new Error('Missing required parameter ruleId when calling systemEmailConnectorsIdParsingStylesStyleIdParsingRulesRuleIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemEmailConnectorsIdParsingStylesStyleIdParsingRulesRuleIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Email Connector Parsing Rule
         * @param id
         * @param styleId
         * @param ruleId
         * @param emailConnectorParsingRule
         */
        public systemEmailConnectorsIdParsingStylesStyleIdParsingRulesRuleIdPut (params: {  id: number; styleId: number; ruleId: number; emailConnectorParsingRule: EmailConnectorParsingRule; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<EmailConnectorParsingRule> {
            const localVarPath = this.basePath + '/system/emailConnectors/{id}/parsingStyles/{styleId}/parsingRules/{ruleId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'styleId' + '}', String(params.styleId))
                .replace('{' + 'ruleId' + '}', String(params.ruleId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemEmailConnectorsIdParsingStylesStyleIdParsingRulesRuleIdPut');
            }
            // verify required parameter 'styleId' is set
            if (params.styleId == null) {
                throw new Error('Missing required parameter styleId when calling systemEmailConnectorsIdParsingStylesStyleIdParsingRulesRuleIdPut');
            }
            // verify required parameter 'ruleId' is set
            if (params.ruleId == null) {
                throw new Error('Missing required parameter ruleId when calling systemEmailConnectorsIdParsingStylesStyleIdParsingRulesRuleIdPut');
            }
            // verify required parameter 'emailConnectorParsingRule' is set
            if (params.emailConnectorParsingRule == null) {
                throw new Error('Missing required parameter emailConnectorParsingRule when calling systemEmailConnectorsIdParsingStylesStyleIdParsingRulesRuleIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.emailConnectorParsingRule),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class EmailConnectorParsingStylesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Email Connector Parsing Style Count
         * @param id
         * @param conditions
         */
        public systemEmailConnectorsIdParsingStylesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/emailConnectors/{id}/parsingStyles/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemEmailConnectorsIdParsingStylesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Email Connector Parsing Styles
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemEmailConnectorsIdParsingStylesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<EmailConnectorParsingStyle>> {
            const localVarPath = this.basePath + '/system/emailConnectors/{id}/parsingStyles'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemEmailConnectorsIdParsingStylesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Email Connector Parsing Style
         * @param id
         * @param emailConnectorParsingStyle
         */
        public systemEmailConnectorsIdParsingStylesPost (params: {  id: number; emailConnectorParsingStyle: EmailConnectorParsingStyle; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<EmailConnectorParsingStyle> {
            const localVarPath = this.basePath + '/system/emailConnectors/{id}/parsingStyles'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemEmailConnectorsIdParsingStylesPost');
            }
            // verify required parameter 'emailConnectorParsingStyle' is set
            if (params.emailConnectorParsingStyle == null) {
                throw new Error('Missing required parameter emailConnectorParsingStyle when calling systemEmailConnectorsIdParsingStylesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.emailConnectorParsingStyle),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Email Connector Parsing Style By Id
         * @param id
         * @param styleId
         */
        public systemEmailConnectorsIdParsingStylesStyleIdDelete (params: {  id: number; styleId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/emailConnectors/{id}/parsingStyles/{styleId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'styleId' + '}', String(params.styleId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemEmailConnectorsIdParsingStylesStyleIdDelete');
            }
            // verify required parameter 'styleId' is set
            if (params.styleId == null) {
                throw new Error('Missing required parameter styleId when calling systemEmailConnectorsIdParsingStylesStyleIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Email Connector Parsing Style By Id
         * @param id
         * @param styleId
         */
        public systemEmailConnectorsIdParsingStylesStyleIdGet (params: {  id: number; styleId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<EmailConnectorParsingStyle> {
            const localVarPath = this.basePath + '/system/emailConnectors/{id}/parsingStyles/{styleId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'styleId' + '}', String(params.styleId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemEmailConnectorsIdParsingStylesStyleIdGet');
            }
            // verify required parameter 'styleId' is set
            if (params.styleId == null) {
                throw new Error('Missing required parameter styleId when calling systemEmailConnectorsIdParsingStylesStyleIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Email Connector Parsing Style
         * @param id
         * @param styleId
         * @param operations
         */
        public systemEmailConnectorsIdParsingStylesStyleIdPatch (params: {  id: number; styleId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<EmailConnectorParsingStyle> {
            const localVarPath = this.basePath + '/system/emailConnectors/{id}/parsingStyles/{styleId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'styleId' + '}', String(params.styleId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemEmailConnectorsIdParsingStylesStyleIdPatch');
            }
            // verify required parameter 'styleId' is set
            if (params.styleId == null) {
                throw new Error('Missing required parameter styleId when calling systemEmailConnectorsIdParsingStylesStyleIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemEmailConnectorsIdParsingStylesStyleIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Email Connector Parsing Style
         * @param id
         * @param styleId
         * @param emailConnectorParsingStyle
         */
        public systemEmailConnectorsIdParsingStylesStyleIdPut (params: {  id: number; styleId: number; emailConnectorParsingStyle: EmailConnectorParsingStyle; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<EmailConnectorParsingStyle> {
            const localVarPath = this.basePath + '/system/emailConnectors/{id}/parsingStyles/{styleId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'styleId' + '}', String(params.styleId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemEmailConnectorsIdParsingStylesStyleIdPut');
            }
            // verify required parameter 'styleId' is set
            if (params.styleId == null) {
                throw new Error('Missing required parameter styleId when calling systemEmailConnectorsIdParsingStylesStyleIdPut');
            }
            // verify required parameter 'emailConnectorParsingStyle' is set
            if (params.emailConnectorParsingStyle == null) {
                throw new Error('Missing required parameter emailConnectorParsingStyle when calling systemEmailConnectorsIdParsingStylesStyleIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.emailConnectorParsingStyle),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class EmailConnectorsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Email Connectors Count
         * @param conditions
         */
        public systemEmailConnectorsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/emailConnectors/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Email Connectors
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemEmailConnectorsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<EmailConnector>> {
            const localVarPath = this.basePath + '/system/emailConnectors';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Email Connector By Id
         * @param id
         */
        public systemEmailConnectorsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/emailConnectors/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemEmailConnectorsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Email Connector By Id
         * @param id
         */
        public systemEmailConnectorsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<EmailConnector> {
            const localVarPath = this.basePath + '/system/emailConnectors/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemEmailConnectorsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Email Connector
         * @param id
         * @param operations
         */
        public systemEmailConnectorsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<EmailConnector> {
            const localVarPath = this.basePath + '/system/emailConnectors/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemEmailConnectorsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemEmailConnectorsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Email Connector
         * @param id
         * @param emailConnector
         */
        public systemEmailConnectorsIdPut (params: {  id: number; emailConnector: EmailConnector; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<EmailConnector> {
            const localVarPath = this.basePath + '/system/emailConnectors/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemEmailConnectorsIdPut');
            }
            // verify required parameter 'emailConnector' is set
            if (params.emailConnector == null) {
                throw new Error('Missing required parameter emailConnector when calling systemEmailConnectorsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.emailConnector),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Email Connector
         * @param emailConnector
         */
        public systemEmailConnectorsPost (params: {  emailConnector: EmailConnector; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<EmailConnector> {
            const localVarPath = this.basePath + '/system/emailConnectors';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'emailConnector' is set
            if (params.emailConnector == null) {
                throw new Error('Missing required parameter emailConnector when calling systemEmailConnectorsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.emailConnector),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class EmailTokensApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Email Tokens Count
         * @param conditions
         */
        public systemEmailTokensCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/emailTokens/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Email Tokens
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemEmailTokensGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<EmailToken>> {
            const localVarPath = this.basePath + '/system/emailTokens';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Email Token By Id
         * @param id
         */
        public systemEmailTokensIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<EmailToken> {
            const localVarPath = this.basePath + '/system/emailTokens/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemEmailTokensIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ExpenseEntriesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Expense Entries Count
         * @param conditions
         * @param customFieldConditions
         * @param childConditions
         */
        public expenseEntriesCountGet (params: {  conditions?: string; customFieldConditions?: string; childConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/expense/entries/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.customFieldConditions !== undefined) {
                queryParameters['customFieldConditions'] = params.customFieldConditions;
            }

            if (params.childConditions !== undefined) {
                queryParameters['childConditions'] = params.childConditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Expense Entries
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public expenseEntriesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ExpenseEntry>> {
            const localVarPath = this.basePath + '/expense/entries';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Expense Entry By Id
         * @param id
         */
        public expenseEntriesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/expense/entries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling expenseEntriesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Expense Entry By Id
         * @param id
         */
        public expenseEntriesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ExpenseEntry> {
            const localVarPath = this.basePath + '/expense/entries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling expenseEntriesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Expense Entry
         * @param id
         * @param operations
         */
        public expenseEntriesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ExpenseEntry> {
            const localVarPath = this.basePath + '/expense/entries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling expenseEntriesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling expenseEntriesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Expense Entry
         * @param id
         * @param expenseEntry
         */
        public expenseEntriesIdPut (params: {  id: number; expenseEntry: ExpenseEntry; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ExpenseEntry> {
            const localVarPath = this.basePath + '/expense/entries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling expenseEntriesIdPut');
            }
            // verify required parameter 'expenseEntry' is set
            if (params.expenseEntry == null) {
                throw new Error('Missing required parameter expenseEntry when calling expenseEntriesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.expenseEntry),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Expense Entry
         * @param expenseEntry
         */
        public expenseEntriesPost (params: {  expenseEntry: ExpenseEntry; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ExpenseEntry> {
            const localVarPath = this.basePath + '/expense/entries';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'expenseEntry' is set
            if (params.expenseEntry == null) {
                throw new Error('Missing required parameter expenseEntry when calling expenseEntriesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.expenseEntry),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ExpenseReportsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Expense Reports Count
         * @param conditions
         */
        public expenseReportsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/expense/reports/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Expense Reports
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public expenseReportsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ExpenseReport>> {
            const localVarPath = this.basePath + '/expense/reports';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Expense Report By Id
         * @param id
         */
        public expenseReportsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ExpenseReport> {
            const localVarPath = this.basePath + '/expense/reports/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling expenseReportsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Reverse Expense Report
         * @param id
         */
        public expenseReportsIdReversePost (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SuccessResponse> {
            const localVarPath = this.basePath + '/expense/reports/{id}/reverse'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling expenseReportsIdReversePost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Submit Expense Report
         * @param id
         */
        public expenseReportsIdSubmitPost (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SuccessResponse> {
            const localVarPath = this.basePath + '/expense/reports/{id}/submit'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling expenseReportsIdSubmitPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ExpenseTypeExternalIntegrationReferencesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get External Integration Reference Count
         * @param conditions
         */
        public expenseExpenseTypeExternalIntegrationReferencesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/expense/expenseTypeExternalIntegrationReferences/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get External Integration Referencet
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public expenseExpenseTypeExternalIntegrationReferencesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ExpenseTypeExternalIntegrationReference>> {
            const localVarPath = this.basePath + '/expense/expenseTypeExternalIntegrationReferences';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get External Integration Reference By Id
         * @param id
         */
        public expenseExpenseTypeExternalIntegrationReferencesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ExpenseTypeExternalIntegrationReference> {
            const localVarPath = this.basePath + '/expense/expenseTypeExternalIntegrationReferences/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling expenseExpenseTypeExternalIntegrationReferencesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ExpenseTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Expense Types Count
         * @param conditions
         */
        public expenseTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/expense/types/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Expense Types
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public expenseTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ExpenseType>> {
            const localVarPath = this.basePath + '/expense/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Expense Type By Id
         * @param id
         */
        public expenseTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/expense/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling expenseTypesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Expense Type By Id
         * @param id
         */
        public expenseTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ExpenseType> {
            const localVarPath = this.basePath + '/expense/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling expenseTypesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Expense Type
         * @param id
         * @param operations
         */
        public expenseTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ExpenseType> {
            const localVarPath = this.basePath + '/expense/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling expenseTypesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling expenseTypesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Expense Type
         * @param id
         * @param expenseType
         */
        public expenseTypesIdPut (params: {  id: number; expenseType: ExpenseType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ExpenseType> {
            const localVarPath = this.basePath + '/expense/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling expenseTypesIdPut');
            }
            // verify required parameter 'expenseType' is set
            if (params.expenseType == null) {
                throw new Error('Missing required parameter expenseType when calling expenseTypesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.expenseType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Expense Type
         * @param expenseType
         */
        public expenseTypesPost (params: {  expenseType: ExpenseType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ExpenseType> {
            const localVarPath = this.basePath + '/expense/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'expenseType' is set
            if (params.expenseType == null) {
                throw new Error('Missing required parameter expenseType when calling expenseTypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.expenseType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class GroupCompaniesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Delete Marketing Company By Id
         * @param id
         * @param companyId
         */
        public marketingGroupsIdCompaniesCompanyIdDelete (params: {  id: number; companyId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/marketing/groups/{id}/companies/{companyId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'companyId' + '}', String(params.companyId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdCompaniesCompanyIdDelete');
            }
            // verify required parameter 'companyId' is set
            if (params.companyId == null) {
                throw new Error('Missing required parameter companyId when calling marketingGroupsIdCompaniesCompanyIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Marketing Company By Id
         * @param id
         * @param companyId
         */
        public marketingGroupsIdCompaniesCompanyIdGet (params: {  id: number; companyId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MarketingCompany> {
            const localVarPath = this.basePath + '/marketing/groups/{id}/companies/{companyId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'companyId' + '}', String(params.companyId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdCompaniesCompanyIdGet');
            }
            // verify required parameter 'companyId' is set
            if (params.companyId == null) {
                throw new Error('Missing required parameter companyId when calling marketingGroupsIdCompaniesCompanyIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Marketing Company
         * @param id
         * @param companyId
         * @param operations
         */
        public marketingGroupsIdCompaniesCompanyIdPatch (params: {  id: number; companyId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MarketingCompany> {
            const localVarPath = this.basePath + '/marketing/groups/{id}/companies/{companyId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'companyId' + '}', String(params.companyId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdCompaniesCompanyIdPatch');
            }
            // verify required parameter 'companyId' is set
            if (params.companyId == null) {
                throw new Error('Missing required parameter companyId when calling marketingGroupsIdCompaniesCompanyIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling marketingGroupsIdCompaniesCompanyIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Marketing Company
         * @param id
         * @param companyId
         * @param marketingCompany
         */
        public marketingGroupsIdCompaniesCompanyIdPut (params: {  id: number; companyId: number; marketingCompany: MarketingCompany; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MarketingCompany> {
            const localVarPath = this.basePath + '/marketing/groups/{id}/companies/{companyId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'companyId' + '}', String(params.companyId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdCompaniesCompanyIdPut');
            }
            // verify required parameter 'companyId' is set
            if (params.companyId == null) {
                throw new Error('Missing required parameter companyId when calling marketingGroupsIdCompaniesCompanyIdPut');
            }
            // verify required parameter 'marketingCompany' is set
            if (params.marketingCompany == null) {
                throw new Error('Missing required parameter marketingCompany when calling marketingGroupsIdCompaniesCompanyIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.marketingCompany),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Marketing Companys Count
         * @param id
         * @param conditions
         */
        public marketingGroupsIdCompaniesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/marketing/groups/{id}/companies/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdCompaniesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Marketing Companys
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public marketingGroupsIdCompaniesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<MarketingCompany>> {
            const localVarPath = this.basePath + '/marketing/groups/{id}/companies'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdCompaniesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Marketing Company
         * @param id
         * @param marketingCompany
         */
        public marketingGroupsIdCompaniesPost (params: {  id: number; marketingCompany: MarketingCompany; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MarketingCompany> {
            const localVarPath = this.basePath + '/marketing/groups/{id}/companies'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdCompaniesPost');
            }
            // verify required parameter 'marketingCompany' is set
            if (params.marketingCompany == null) {
                throw new Error('Missing required parameter marketingCompany when calling marketingGroupsIdCompaniesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.marketingCompany),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class GroupContactsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Delete Marketing Contact By Id
         * @param id
         * @param contactId
         */
        public marketingGroupsIdContactsContactIdDelete (params: {  id: number; contactId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/marketing/groups/{id}/contacts/{contactId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'contactId' + '}', String(params.contactId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdContactsContactIdDelete');
            }
            // verify required parameter 'contactId' is set
            if (params.contactId == null) {
                throw new Error('Missing required parameter contactId when calling marketingGroupsIdContactsContactIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Marketing Contact By Id
         * @param id
         * @param contactId
         */
        public marketingGroupsIdContactsContactIdGet (params: {  id: number; contactId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MarketingContact> {
            const localVarPath = this.basePath + '/marketing/groups/{id}/contacts/{contactId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'contactId' + '}', String(params.contactId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdContactsContactIdGet');
            }
            // verify required parameter 'contactId' is set
            if (params.contactId == null) {
                throw new Error('Missing required parameter contactId when calling marketingGroupsIdContactsContactIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Marketing Contact
         * @param id
         * @param contactId
         * @param operations
         */
        public marketingGroupsIdContactsContactIdPatch (params: {  id: number; contactId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MarketingContact> {
            const localVarPath = this.basePath + '/marketing/groups/{id}/contacts/{contactId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'contactId' + '}', String(params.contactId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdContactsContactIdPatch');
            }
            // verify required parameter 'contactId' is set
            if (params.contactId == null) {
                throw new Error('Missing required parameter contactId when calling marketingGroupsIdContactsContactIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling marketingGroupsIdContactsContactIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Marketing Contact
         * @param id
         * @param contactId
         * @param marketingContact
         */
        public marketingGroupsIdContactsContactIdPut (params: {  id: number; contactId: number; marketingContact: MarketingContact; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MarketingContact> {
            const localVarPath = this.basePath + '/marketing/groups/{id}/contacts/{contactId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'contactId' + '}', String(params.contactId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdContactsContactIdPut');
            }
            // verify required parameter 'contactId' is set
            if (params.contactId == null) {
                throw new Error('Missing required parameter contactId when calling marketingGroupsIdContactsContactIdPut');
            }
            // verify required parameter 'marketingContact' is set
            if (params.marketingContact == null) {
                throw new Error('Missing required parameter marketingContact when calling marketingGroupsIdContactsContactIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.marketingContact),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Marketing Contacts Count
         * @param id
         * @param conditions
         */
        public marketingGroupsIdContactsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/marketing/groups/{id}/contacts/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdContactsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Marketing Contacts
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public marketingGroupsIdContactsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<MarketingContact>> {
            const localVarPath = this.basePath + '/marketing/groups/{id}/contacts'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdContactsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Marketing Contact
         * @param id
         * @param marketingContact
         */
        public marketingGroupsIdContactsPost (params: {  id: number; marketingContact: MarketingContact; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MarketingContact> {
            const localVarPath = this.basePath + '/marketing/groups/{id}/contacts'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdContactsPost');
            }
            // verify required parameter 'marketingContact' is set
            if (params.marketingContact == null) {
                throw new Error('Missing required parameter marketingContact when calling marketingGroupsIdContactsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.marketingContact),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class GroupsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Groups Count
         * @param conditions
         */
        public marketingGroupsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/marketing/groups/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Groups
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public marketingGroupsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Group>> {
            const localVarPath = this.basePath + '/marketing/groups';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Group By Id
         * @param id
         */
        public marketingGroupsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/marketing/groups/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Group By Id
         * @param id
         */
        public marketingGroupsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Group> {
            const localVarPath = this.basePath + '/marketing/groups/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Group
         * @param id
         * @param operations
         */
        public marketingGroupsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Group> {
            const localVarPath = this.basePath + '/marketing/groups/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling marketingGroupsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Group
         * @param id
         * @param group
         */
        public marketingGroupsIdPut (params: {  id: number; group: Group; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Group> {
            const localVarPath = this.basePath + '/marketing/groups/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingGroupsIdPut');
            }
            // verify required parameter 'group' is set
            if (params.group == null) {
                throw new Error('Missing required parameter group when calling marketingGroupsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.group),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Group
         * @param group
         */
        public marketingGroupsPost (params: {  group: Group; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Group> {
            const localVarPath = this.basePath + '/marketing/groups';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'group' is set
            if (params.group == null) {
                throw new Error('Missing required parameter group when calling marketingGroupsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.group),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class HolidayListsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Holiday List Count
         * @param conditions
         */
        public systemHolidayListsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/holidayLists/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Holiday List
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemHolidayListsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<HolidayList>> {
            const localVarPath = this.basePath + '/system/holidayLists';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Holiday List By Id
         * @param id
         */
        public systemHolidayListsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/holidayLists/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemHolidayListsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Holiday List By Id
         * @param id
         */
        public systemHolidayListsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<HolidayList> {
            const localVarPath = this.basePath + '/system/holidayLists/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemHolidayListsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Holiday List
         * @param id
         * @param operations
         */
        public systemHolidayListsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<HolidayList> {
            const localVarPath = this.basePath + '/system/holidayLists/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemHolidayListsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemHolidayListsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Holiday List
         * @param id
         * @param holidayList
         */
        public systemHolidayListsIdPut (params: {  id: number; holidayList: HolidayList; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<HolidayList> {
            const localVarPath = this.basePath + '/system/holidayLists/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemHolidayListsIdPut');
            }
            // verify required parameter 'holidayList' is set
            if (params.holidayList == null) {
                throw new Error('Missing required parameter holidayList when calling systemHolidayListsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.holidayList),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Holiday List
         * @param holidayList
         */
        public systemHolidayListsPost (params: {  holidayList: HolidayList; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<HolidayList> {
            const localVarPath = this.basePath + '/system/holidayLists';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'holidayList' is set
            if (params.holidayList == null) {
                throw new Error('Missing required parameter holidayList when calling systemHolidayListsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.holidayList),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class HolidaysApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Holidays Count
         * @param id
         * @param conditions
         */
        public systemHolidayListsIdHolidaysCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/holidayLists/{id}/holidays/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemHolidayListsIdHolidaysCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Holidays
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemHolidayListsIdHolidaysGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Holiday>> {
            const localVarPath = this.basePath + '/system/holidayLists/{id}/holidays'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemHolidayListsIdHolidaysGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Holiday By Id
         * @param id
         * @param holidayId
         */
        public systemHolidayListsIdHolidaysHolidayIdDelete (params: {  id: number; holidayId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/holidayLists/{id}/holidays/{holidayId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'holidayId' + '}', String(params.holidayId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemHolidayListsIdHolidaysHolidayIdDelete');
            }
            // verify required parameter 'holidayId' is set
            if (params.holidayId == null) {
                throw new Error('Missing required parameter holidayId when calling systemHolidayListsIdHolidaysHolidayIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Holiday By Id
         * @param id
         * @param holidayId
         */
        public systemHolidayListsIdHolidaysHolidayIdGet (params: {  id: number; holidayId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Holiday> {
            const localVarPath = this.basePath + '/system/holidayLists/{id}/holidays/{holidayId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'holidayId' + '}', String(params.holidayId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemHolidayListsIdHolidaysHolidayIdGet');
            }
            // verify required parameter 'holidayId' is set
            if (params.holidayId == null) {
                throw new Error('Missing required parameter holidayId when calling systemHolidayListsIdHolidaysHolidayIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Holiday
         * @param id
         * @param holidayId
         * @param operations
         */
        public systemHolidayListsIdHolidaysHolidayIdPatch (params: {  id: number; holidayId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Holiday> {
            const localVarPath = this.basePath + '/system/holidayLists/{id}/holidays/{holidayId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'holidayId' + '}', String(params.holidayId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemHolidayListsIdHolidaysHolidayIdPatch');
            }
            // verify required parameter 'holidayId' is set
            if (params.holidayId == null) {
                throw new Error('Missing required parameter holidayId when calling systemHolidayListsIdHolidaysHolidayIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemHolidayListsIdHolidaysHolidayIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Holiday
         * @param id
         * @param holidayId
         * @param holiday
         */
        public systemHolidayListsIdHolidaysHolidayIdPut (params: {  id: number; holidayId: number; holiday: Holiday; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Holiday> {
            const localVarPath = this.basePath + '/system/holidayLists/{id}/holidays/{holidayId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'holidayId' + '}', String(params.holidayId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemHolidayListsIdHolidaysHolidayIdPut');
            }
            // verify required parameter 'holidayId' is set
            if (params.holidayId == null) {
                throw new Error('Missing required parameter holidayId when calling systemHolidayListsIdHolidaysHolidayIdPut');
            }
            // verify required parameter 'holiday' is set
            if (params.holiday == null) {
                throw new Error('Missing required parameter holiday when calling systemHolidayListsIdHolidaysHolidayIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.holiday),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Holiday
         * @param id
         * @param holiday
         */
        public systemHolidayListsIdHolidaysPost (params: {  id: number; holiday: Holiday; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Holiday> {
            const localVarPath = this.basePath + '/system/holidayLists/{id}/holidays'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemHolidayListsIdHolidaysPost');
            }
            // verify required parameter 'holiday' is set
            if (params.holiday == null) {
                throw new Error('Missing required parameter holiday when calling systemHolidayListsIdHolidaysPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.holiday),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ImapsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Imap Count
         * @param conditions
         */
        public systemImapsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/imaps/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Imaps
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemImapsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Imap>> {
            const localVarPath = this.basePath + '/system/imaps';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Imap By Id
         * @param id
         */
        public systemImapsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Imap> {
            const localVarPath = this.basePath + '/system/imaps/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemImapsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ImpactsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Impact Count
         * @param conditions
         */
        public serviceImpactsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/impacts/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Impact
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceImpactsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Impact>> {
            const localVarPath = this.basePath + '/service/impacts';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Impact By Id
         * @param id
         */
        public serviceImpactsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Impact> {
            const localVarPath = this.basePath + '/service/impacts/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceImpactsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Impact
         * @param id
         * @param operations
         */
        public serviceImpactsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Impact> {
            const localVarPath = this.basePath + '/service/impacts/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceImpactsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceImpactsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Impact
         * @param id
         * @param impact
         */
        public serviceImpactsIdPut (params: {  id: number; impact: Impact; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Impact> {
            const localVarPath = this.basePath + '/service/impacts/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceImpactsIdPut');
            }
            // verify required parameter 'impact' is set
            if (params.impact == null) {
                throw new Error('Missing required parameter impact when calling serviceImpactsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.impact),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ImportsMassMaintenanceApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Delete Import Mass Maintenance By Id
         * @param id
         */
        public systemImportMassMaintenanceIdPost (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ImportMassMaintenance> {
            const localVarPath = this.basePath + '/system/importMassMaintenance/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemImportMassMaintenanceIdPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class InOutBoardsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get In Out Board Count
         * @param conditions
         */
        public systemInOutBoardsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/inOutBoards/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get In Out Board
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemInOutBoardsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<InOutBoard>> {
            const localVarPath = this.basePath + '/system/inOutBoards';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete In Out Board By Id
         * @param id
         */
        public systemInOutBoardsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/inOutBoards/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemInOutBoardsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get In Out Board By Id
         * @param id
         */
        public systemInOutBoardsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<InOutBoard> {
            const localVarPath = this.basePath + '/system/inOutBoards/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemInOutBoardsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update In Out Board
         * @param id
         * @param operations
         */
        public systemInOutBoardsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<InOutBoard> {
            const localVarPath = this.basePath + '/system/inOutBoards/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemInOutBoardsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemInOutBoardsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace In Out Board
         * @param id
         * @param inOutBoard
         */
        public systemInOutBoardsIdPut (params: {  id: number; inOutBoard: InOutBoard; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<InOutBoard> {
            const localVarPath = this.basePath + '/system/inOutBoards/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemInOutBoardsIdPut');
            }
            // verify required parameter 'inOutBoard' is set
            if (params.inOutBoard == null) {
                throw new Error('Missing required parameter inOutBoard when calling systemInOutBoardsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.inOutBoard),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create In Out Board
         * @param inOutBoard
         */
        public systemInOutBoardsPost (params: {  inOutBoard: InOutBoard; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<InOutBoard> {
            const localVarPath = this.basePath + '/system/inOutBoards';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'inOutBoard' is set
            if (params.inOutBoard == null) {
                throw new Error('Missing required parameter inOutBoard when calling systemInOutBoardsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.inOutBoard),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class InOutTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get In Out Type Count
         * @param conditions
         */
        public systemInOutTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/inOutTypes/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get In Out Type
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemInOutTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<InOutType>> {
            const localVarPath = this.basePath + '/system/inOutTypes';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete In Out Type By Id
         * @param id
         */
        public systemInOutTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/inOutTypes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemInOutTypesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get In Out Type By Id
         * @param id
         */
        public systemInOutTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<InOutType> {
            const localVarPath = this.basePath + '/system/inOutTypes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemInOutTypesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update In Out Type
         * @param id
         * @param operations
         */
        public systemInOutTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<InOutType> {
            const localVarPath = this.basePath + '/system/inOutTypes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemInOutTypesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemInOutTypesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace In Out Type
         * @param id
         * @param inOutType
         */
        public systemInOutTypesIdPut (params: {  id: number; inOutType: InOutType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<InOutType> {
            const localVarPath = this.basePath + '/system/inOutTypes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemInOutTypesIdPut');
            }
            // verify required parameter 'inOutType' is set
            if (params.inOutType == null) {
                throw new Error('Missing required parameter inOutType when calling systemInOutTypesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.inOutType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create In Out Type
         * @param inOutType
         */
        public systemInOutTypesPost (params: {  inOutType: InOutType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<InOutType> {
            const localVarPath = this.basePath + '/system/inOutTypes';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'inOutType' is set
            if (params.inOutType == null) {
                throw new Error('Missing required parameter inOutType when calling systemInOutTypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.inOutType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class InfoApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Infos
         */
        public systemInfoGet (params: {  }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Info> {
            const localVarPath = this.basePath + '/system/info';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class IntegratorLoginsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Integrator Login Count
         * @param conditions
         */
        public systemIntegratorloginsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/integratorlogins/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Integrator Login
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemIntegratorloginsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<IntegratorLogin>> {
            const localVarPath = this.basePath + '/system/integratorlogins';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Integrator Login By Id
         * @param id
         */
        public systemIntegratorloginsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/integratorlogins/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemIntegratorloginsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Integrator Login By Id
         * @param id
         */
        public systemIntegratorloginsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<IntegratorLogin> {
            const localVarPath = this.basePath + '/system/integratorlogins/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemIntegratorloginsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Integrator Login
         * @param id
         * @param operations
         */
        public systemIntegratorloginsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<IntegratorLogin> {
            const localVarPath = this.basePath + '/system/integratorlogins/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemIntegratorloginsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemIntegratorloginsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Integrator Login
         * @param id
         * @param integratorLogin
         */
        public systemIntegratorloginsIdPut (params: {  id: number; integratorLogin: IntegratorLogin; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<IntegratorLogin> {
            const localVarPath = this.basePath + '/system/integratorlogins/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemIntegratorloginsIdPut');
            }
            // verify required parameter 'integratorLogin' is set
            if (params.integratorLogin == null) {
                throw new Error('Missing required parameter integratorLogin when calling systemIntegratorloginsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.integratorLogin),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Integrator Login
         * @param integratorLogin
         */
        public systemIntegratorloginsPost (params: {  integratorLogin: IntegratorLogin; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<IntegratorLogin> {
            const localVarPath = this.basePath + '/system/integratorlogins';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'integratorLogin' is set
            if (params.integratorLogin == null) {
                throw new Error('Missing required parameter integratorLogin when calling systemIntegratorloginsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.integratorLogin),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class InvoiceEmailTemplatesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Invoice Email Templates Count
         * @param conditions
         */
        public financeInvoiceEmailTemplatesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/invoiceEmailTemplates/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Invoice Email Templates
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeInvoiceEmailTemplatesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<InvoiceEmailTemplate>> {
            const localVarPath = this.basePath + '/finance/invoiceEmailTemplates';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Invoice Email Template By Id
         * @param id
         */
        public financeInvoiceEmailTemplatesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/invoiceEmailTemplates/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeInvoiceEmailTemplatesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Invoice Email Template By Id
         * @param id
         */
        public financeInvoiceEmailTemplatesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<InvoiceEmailTemplate> {
            const localVarPath = this.basePath + '/finance/invoiceEmailTemplates/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeInvoiceEmailTemplatesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Invoice Email Template
         * @param id
         * @param operations
         */
        public financeInvoiceEmailTemplatesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<InvoiceEmailTemplate> {
            const localVarPath = this.basePath + '/finance/invoiceEmailTemplates/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeInvoiceEmailTemplatesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeInvoiceEmailTemplatesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Invoice Email Template
         * @param id
         * @param invoiceEmailTemplate
         */
        public financeInvoiceEmailTemplatesIdPut (params: {  id: number; invoiceEmailTemplate: InvoiceEmailTemplate; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<InvoiceEmailTemplate> {
            const localVarPath = this.basePath + '/finance/invoiceEmailTemplates/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeInvoiceEmailTemplatesIdPut');
            }
            // verify required parameter 'invoiceEmailTemplate' is set
            if (params.invoiceEmailTemplate == null) {
                throw new Error('Missing required parameter invoiceEmailTemplate when calling financeInvoiceEmailTemplatesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.invoiceEmailTemplate),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Invoice Email Template
         * @param invoiceEmailTemplate
         */
        public financeInvoiceEmailTemplatesPost (params: {  invoiceEmailTemplate: InvoiceEmailTemplate; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<InvoiceEmailTemplate> {
            const localVarPath = this.basePath + '/finance/invoiceEmailTemplates';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'invoiceEmailTemplate' is set
            if (params.invoiceEmailTemplate == null) {
                throw new Error('Missing required parameter invoiceEmailTemplate when calling financeInvoiceEmailTemplatesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.invoiceEmailTemplate),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class InvoicePaymentsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Payments
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeInvoicesIdPaymentsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Payment>> {
            const localVarPath = this.basePath + '/finance/invoices/{id}/payments'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeInvoicesIdPaymentsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Payment By Id
         * @param id
         * @param paymentId
         */
        public financeInvoicesIdPaymentsPaymentIdDelete (params: {  id: number; paymentId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/invoices/{id}/payments/{paymentId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'paymentId' + '}', String(params.paymentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeInvoicesIdPaymentsPaymentIdDelete');
            }
            // verify required parameter 'paymentId' is set
            if (params.paymentId == null) {
                throw new Error('Missing required parameter paymentId when calling financeInvoicesIdPaymentsPaymentIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Payment By Id
         * @param id
         * @param paymentId
         */
        public financeInvoicesIdPaymentsPaymentIdGet (params: {  id: number; paymentId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Payment> {
            const localVarPath = this.basePath + '/finance/invoices/{id}/payments/{paymentId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'paymentId' + '}', String(params.paymentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeInvoicesIdPaymentsPaymentIdGet');
            }
            // verify required parameter 'paymentId' is set
            if (params.paymentId == null) {
                throw new Error('Missing required parameter paymentId when calling financeInvoicesIdPaymentsPaymentIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Payment
         * @param id
         * @param paymentId
         * @param operations
         */
        public financeInvoicesIdPaymentsPaymentIdPatch (params: {  id: number; paymentId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Payment> {
            const localVarPath = this.basePath + '/finance/invoices/{id}/payments/{paymentId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'paymentId' + '}', String(params.paymentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeInvoicesIdPaymentsPaymentIdPatch');
            }
            // verify required parameter 'paymentId' is set
            if (params.paymentId == null) {
                throw new Error('Missing required parameter paymentId when calling financeInvoicesIdPaymentsPaymentIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeInvoicesIdPaymentsPaymentIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Payment
         * @param id
         * @param paymentId
         * @param payment
         */
        public financeInvoicesIdPaymentsPaymentIdPut (params: {  id: number; paymentId: number; payment: Payment; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Payment> {
            const localVarPath = this.basePath + '/finance/invoices/{id}/payments/{paymentId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'paymentId' + '}', String(params.paymentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeInvoicesIdPaymentsPaymentIdPut');
            }
            // verify required parameter 'paymentId' is set
            if (params.paymentId == null) {
                throw new Error('Missing required parameter paymentId when calling financeInvoicesIdPaymentsPaymentIdPut');
            }
            // verify required parameter 'payment' is set
            if (params.payment == null) {
                throw new Error('Missing required parameter payment when calling financeInvoicesIdPaymentsPaymentIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.payment),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Payment
         * @param id
         * @param payment
         */
        public financeInvoicesIdPaymentsPost (params: {  id: number; payment: Payment; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Payment> {
            const localVarPath = this.basePath + '/finance/invoices/{id}/payments'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeInvoicesIdPaymentsPost');
            }
            // verify required parameter 'payment' is set
            if (params.payment == null) {
                throw new Error('Missing required parameter payment when calling financeInvoicesIdPaymentsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.payment),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class InvoiceTemplateSetupsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Invoice Template Setups Count
         * @param conditions
         */
        public financeInvoiceTemplateSetupsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/invoiceTemplateSetups/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Retrieves a list of standard and custom invoice templates
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeInvoiceTemplateSetupsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<InvoiceTemplateSetup>> {
            const localVarPath = this.basePath + '/finance/invoiceTemplateSetups';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Invoice Template Setup By Id
         * @param id
         */
        public financeInvoiceTemplateSetupsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<InvoiceTemplateSetup> {
            const localVarPath = this.basePath + '/finance/invoiceTemplateSetups/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeInvoiceTemplateSetupsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class InvoiceTemplatesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Invoice Templates Count
         * @param conditions
         */
        public financeInvoiceTemplatesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/invoiceTemplates/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Invoice Templates
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeInvoiceTemplatesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<InvoiceTemplate>> {
            const localVarPath = this.basePath + '/finance/invoiceTemplates';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Invoice Template By Id
         * @param id
         */
        public financeInvoiceTemplatesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<InvoiceTemplate> {
            const localVarPath = this.basePath + '/finance/invoiceTemplates/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeInvoiceTemplatesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class InvoicesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Invoices Count
         * @param conditions
         * @param customFieldConditions
         */
        public financeInvoicesCountGet (params: {  conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/invoices/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.customFieldConditions !== undefined) {
                queryParameters['customFieldConditions'] = params.customFieldConditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Invoices
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeInvoicesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Invoice>> {
            const localVarPath = this.basePath + '/finance/invoices';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Invoice By Id
         * @param id
         */
        public financeInvoicesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/invoices/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeInvoicesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Invoice By Id
         * @param id
         */
        public financeInvoicesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Invoice> {
            const localVarPath = this.basePath + '/finance/invoices/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeInvoicesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Invoice
         * @param id
         * @param operations
         */
        public financeInvoicesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Invoice> {
            const localVarPath = this.basePath + '/finance/invoices/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeInvoicesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeInvoicesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Invoice Pdf
         * @param id
         */
        public financeInvoicesIdPdfGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/invoices/{id}/pdf'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeInvoicesIdPdfGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Invoice
         * @param id
         * @param invoice
         */
        public financeInvoicesIdPut (params: {  id: number; invoice: Invoice; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Invoice> {
            const localVarPath = this.basePath + '/finance/invoices/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeInvoicesIdPut');
            }
            // verify required parameter 'invoice' is set
            if (params.invoice == null) {
                throw new Error('Missing required parameter invoice when calling financeInvoicesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.invoice),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Invoice
         * @param invoice
         */
        public financeInvoicesPost (params: {  invoice: Invoice; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Invoice> {
            const localVarPath = this.basePath + '/finance/invoices';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'invoice' is set
            if (params.invoice == null) {
                throw new Error('Missing required parameter invoice when calling financeInvoicesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.invoice),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class KPICategoriesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get K P I Categories Count
         * @param conditions
         */
        public systemKpiCategoriesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/kpiCategories/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get K P I Categories
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemKpiCategoriesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<KPICategory>> {
            const localVarPath = this.basePath + '/system/kpiCategories';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get K P I Category By Id
         * @param id
         */
        public systemKpiCategoriesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<KPICategory> {
            const localVarPath = this.basePath + '/system/kpiCategories/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemKpiCategoriesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class KPIsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get K P I Count
         * @param conditions
         */
        public systemKpisCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/kpis/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get K P I
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemKpisGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<KPI>> {
            const localVarPath = this.basePath + '/system/kpis';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get K P I By Id
         * @param id
         */
        public systemKpisIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<KPI> {
            const localVarPath = this.basePath + '/system/kpis/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemKpisIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class KnowledgeBaseArticlesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Knowledge Base Articles Count
         * @param conditions
         * @param customFieldConditions
         */
        public serviceKnowledgeBaseArticlesCountGet (params: {  conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/knowledgeBaseArticles/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.customFieldConditions !== undefined) {
                queryParameters['customFieldConditions'] = params.customFieldConditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Knowledge Base Articles
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceKnowledgeBaseArticlesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<KnowledgeBaseArticle>> {
            const localVarPath = this.basePath + '/service/knowledgeBaseArticles';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Knowledge Base Article By Id
         * @param id
         */
        public serviceKnowledgeBaseArticlesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/knowledgeBaseArticles/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceKnowledgeBaseArticlesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Knowledge Base Article By Id
         * @param id
         */
        public serviceKnowledgeBaseArticlesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<KnowledgeBaseArticle> {
            const localVarPath = this.basePath + '/service/knowledgeBaseArticles/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceKnowledgeBaseArticlesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Knowledge Base Article
         * @param id
         * @param operations
         */
        public serviceKnowledgeBaseArticlesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<KnowledgeBaseArticle> {
            const localVarPath = this.basePath + '/service/knowledgeBaseArticles/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceKnowledgeBaseArticlesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceKnowledgeBaseArticlesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Knowledge Base Article
         * @param id
         * @param knowledgeBaseArticle
         */
        public serviceKnowledgeBaseArticlesIdPut (params: {  id: number; knowledgeBaseArticle: KnowledgeBaseArticle; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<KnowledgeBaseArticle> {
            const localVarPath = this.basePath + '/service/knowledgeBaseArticles/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceKnowledgeBaseArticlesIdPut');
            }
            // verify required parameter 'knowledgeBaseArticle' is set
            if (params.knowledgeBaseArticle == null) {
                throw new Error('Missing required parameter knowledgeBaseArticle when calling serviceKnowledgeBaseArticlesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.knowledgeBaseArticle),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Knowledge Base Article
         * @param knowledgeBaseArticle
         */
        public serviceKnowledgeBaseArticlesPost (params: {  knowledgeBaseArticle: KnowledgeBaseArticle; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<KnowledgeBaseArticle> {
            const localVarPath = this.basePath + '/service/knowledgeBaseArticles';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'knowledgeBaseArticle' is set
            if (params.knowledgeBaseArticle == null) {
                throw new Error('Missing required parameter knowledgeBaseArticle when calling serviceKnowledgeBaseArticlesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.knowledgeBaseArticle),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class LdapConfigurationsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Ldap Configurations Count
         * @param conditions
         */
        public systemLdapConfigurationsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/ldapConfigurations/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Ldap Configurations
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemLdapConfigurationsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<LdapConfiguration>> {
            const localVarPath = this.basePath + '/system/ldapConfigurations';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Ldap Configuration By Id
         * @param id
         */
        public systemLdapConfigurationsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/ldapConfigurations/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemLdapConfigurationsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Ldap Configuration By Id
         * @param id
         */
        public systemLdapConfigurationsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<LdapConfiguration> {
            const localVarPath = this.basePath + '/system/ldapConfigurations/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemLdapConfigurationsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Ldap Configuration
         * @param id
         * @param operations
         */
        public systemLdapConfigurationsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<LdapConfiguration> {
            const localVarPath = this.basePath + '/system/ldapConfigurations/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemLdapConfigurationsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemLdapConfigurationsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Ldap Configuration
         * @param id
         * @param ldapConfiguration
         */
        public systemLdapConfigurationsIdPut (params: {  id: number; ldapConfiguration: LdapConfiguration; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<LdapConfiguration> {
            const localVarPath = this.basePath + '/system/ldapConfigurations/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemLdapConfigurationsIdPut');
            }
            // verify required parameter 'ldapConfiguration' is set
            if (params.ldapConfiguration == null) {
                throw new Error('Missing required parameter ldapConfiguration when calling systemLdapConfigurationsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.ldapConfiguration),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Ldap Configuration
         * @param ldapConfiguration
         */
        public systemLdapConfigurationsPost (params: {  ldapConfiguration: LdapConfiguration; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<LdapConfiguration> {
            const localVarPath = this.basePath + '/system/ldapConfigurations';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'ldapConfiguration' is set
            if (params.ldapConfiguration == null) {
                throw new Error('Missing required parameter ldapConfiguration when calling systemLdapConfigurationsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.ldapConfiguration),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class LegacyCampaignSubTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Campaign Sub Types Count
         * @param id
         * @param conditions
         */
        public marketingCampaignsTypesIdSubTypesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/marketing/campaigns/types/{id}/subTypes/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsTypesIdSubTypesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Campaign Sub Types
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public marketingCampaignsTypesIdSubTypesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CampaignSubType>> {
            const localVarPath = this.basePath + '/marketing/campaigns/types/{id}/subTypes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsTypesIdSubTypesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Campaign Sub Type By Id
         * @param id
         * @param subTypeId
         */
        public marketingCampaignsTypesIdSubTypesSubTypeIdGet (params: {  id: number; subTypeId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignSubType> {
            const localVarPath = this.basePath + '/marketing/campaigns/types/{id}/subTypes/{subTypeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'subTypeId' + '}', String(params.subTypeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling marketingCampaignsTypesIdSubTypesSubTypeIdGet');
            }
            // verify required parameter 'subTypeId' is set
            if (params.subTypeId == null) {
                throw new Error('Missing required parameter subTypeId when calling marketingCampaignsTypesIdSubTypesSubTypeIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class LegacySubCategoriesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Legacy Sub Categories Count
         * @param id
         * @param conditions
         */
        public procurementCategoriesIdSubcategoriesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/categories/{id}/subcategories/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCategoriesIdSubcategoriesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Legacy Sub Categories
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementCategoriesIdSubcategoriesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<LegacySubCategory>> {
            const localVarPath = this.basePath + '/procurement/categories/{id}/subcategories'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCategoriesIdSubcategoriesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Legacy Sub Category
         * @param id
         * @param subCategory
         */
        public procurementCategoriesIdSubcategoriesPost (params: {  id: number; subCategory: LegacySubCategory; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<LegacySubCategory> {
            const localVarPath = this.basePath + '/procurement/categories/{id}/subcategories'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCategoriesIdSubcategoriesPost');
            }
            // verify required parameter 'subCategory' is set
            if (params.subCategory == null) {
                throw new Error('Missing required parameter subCategory when calling procurementCategoriesIdSubcategoriesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.subCategory),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Legacy Sub Category By Id
         * @param id
         * @param subcategoryID
         */
        public procurementCategoriesIdSubcategoriesSubcategoryIDDelete (params: {  id: number; subcategoryID: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/categories/{id}/subcategories/{subcategoryID}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'subcategoryID' + '}', String(params.subcategoryID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCategoriesIdSubcategoriesSubcategoryIDDelete');
            }
            // verify required parameter 'subcategoryID' is set
            if (params.subcategoryID == null) {
                throw new Error('Missing required parameter subcategoryID when calling procurementCategoriesIdSubcategoriesSubcategoryIDDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Legacy Sub Category By Id
         * @param id
         * @param subcategoryID
         */
        public procurementCategoriesIdSubcategoriesSubcategoryIDGet (params: {  id: number; subcategoryID: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<LegacySubCategory> {
            const localVarPath = this.basePath + '/procurement/categories/{id}/subcategories/{subcategoryID}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'subcategoryID' + '}', String(params.subcategoryID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCategoriesIdSubcategoriesSubcategoryIDGet');
            }
            // verify required parameter 'subcategoryID' is set
            if (params.subcategoryID == null) {
                throw new Error('Missing required parameter subcategoryID when calling procurementCategoriesIdSubcategoriesSubcategoryIDGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Legacy Sub Category
         * @param id
         * @param subcategoryID
         * @param operations
         */
        public procurementCategoriesIdSubcategoriesSubcategoryIDPatch (params: {  id: number; subcategoryID: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<LegacySubCategory> {
            const localVarPath = this.basePath + '/procurement/categories/{id}/subcategories/{subcategoryID}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'subcategoryID' + '}', String(params.subcategoryID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCategoriesIdSubcategoriesSubcategoryIDPatch');
            }
            // verify required parameter 'subcategoryID' is set
            if (params.subcategoryID == null) {
                throw new Error('Missing required parameter subcategoryID when calling procurementCategoriesIdSubcategoriesSubcategoryIDPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementCategoriesIdSubcategoriesSubcategoryIDPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Legacy Sub Category
         * @param id
         * @param subcategoryID
         * @param subCategory
         */
        public procurementCategoriesIdSubcategoriesSubcategoryIDPut (params: {  id: number; subcategoryID: number; subCategory: LegacySubCategory; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<LegacySubCategory> {
            const localVarPath = this.basePath + '/procurement/categories/{id}/subcategories/{subcategoryID}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'subcategoryID' + '}', String(params.subcategoryID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementCategoriesIdSubcategoriesSubcategoryIDPut');
            }
            // verify required parameter 'subcategoryID' is set
            if (params.subcategoryID == null) {
                throw new Error('Missing required parameter subcategoryID when calling procurementCategoriesIdSubcategoriesSubcategoryIDPut');
            }
            // verify required parameter 'subCategory' is set
            if (params.subCategory == null) {
                throw new Error('Missing required parameter subCategory when calling procurementCategoriesIdSubcategoriesSubcategoryIDPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.subCategory),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class LinksApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Links Count
         * @param conditions
         */
        public systemLinksCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/links/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Links
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemLinksGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Link>> {
            const localVarPath = this.basePath + '/system/links';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Link By Id
         * @param id
         */
        public systemLinksIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/links/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemLinksIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Link By Id
         * @param id
         */
        public systemLinksIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Link> {
            const localVarPath = this.basePath + '/system/links/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemLinksIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Link
         * @param id
         * @param operations
         */
        public systemLinksIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Link> {
            const localVarPath = this.basePath + '/system/links/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemLinksIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemLinksIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Link
         * @param id
         * @param link
         */
        public systemLinksIdPut (params: {  id: number; link: Link; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Link> {
            const localVarPath = this.basePath + '/system/links/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemLinksIdPut');
            }
            // verify required parameter 'link' is set
            if (params.link == null) {
                throw new Error('Missing required parameter link when calling systemLinksIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.link),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Link
         * @param link
         */
        public systemLinksPost (params: {  link: Link; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Link> {
            const localVarPath = this.basePath + '/system/links';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'link' is set
            if (params.link == null) {
                throw new Error('Missing required parameter link when calling systemLinksPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.link),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class LocationDepartmentsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Location Department Count
         * @param id
         * @param conditions
         */
        public systemLocationsIdDepartmentsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/locations/{id}/departments/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemLocationsIdDepartmentsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Location Department
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemLocationsIdDepartmentsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<LocationDepartment>> {
            const localVarPath = this.basePath + '/system/locations/{id}/departments'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemLocationsIdDepartmentsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Location Department By Id
         * @param parentId
         * @param id
         */
        public systemLocationsParentIdDepartmentsIdGet (params: {  parentId: number; id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<LocationDepartment> {
            const localVarPath = this.basePath + '/system/locations/{parentId}/departments/{id}'
                .replace('{' + 'parentId' + '}', String(params.parentId))
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'parentId' is set
            if (params.parentId == null) {
                throw new Error('Missing required parameter parentId when calling systemLocationsParentIdDepartmentsIdGet');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemLocationsParentIdDepartmentsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class LocationWorkRolesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Location Work Role Count
         * @param id
         * @param conditions
         */
        public systemLocationsIdWorkRolesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/locations/{id}/workRoles/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemLocationsIdWorkRolesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Location Work Role
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemLocationsIdWorkRolesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<LocationWorkRole>> {
            const localVarPath = this.basePath + '/system/locations/{id}/workRoles'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemLocationsIdWorkRolesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Location Work Role By Id
         * @param parentId
         * @param id
         */
        public systemLocationsParentIdWorkRolesIdGet (params: {  parentId: number; id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<LocationWorkRole> {
            const localVarPath = this.basePath + '/system/locations/{parentId}/workRoles/{id}'
                .replace('{' + 'parentId' + '}', String(params.parentId))
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'parentId' is set
            if (params.parentId == null) {
                throw new Error('Missing required parameter parentId when calling systemLocationsParentIdWorkRolesIdGet');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemLocationsParentIdWorkRolesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class LocationsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Location Count
         * @param conditions
         */
        public systemLocationsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/locations/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Location
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemLocationsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Location>> {
            const localVarPath = this.basePath + '/system/locations';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Location By Id
         * @param id
         */
        public systemLocationsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/locations/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemLocationsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Location By Id
         * @param id
         */
        public systemLocationsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Location> {
            const localVarPath = this.basePath + '/system/locations/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemLocationsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Location
         * @param id
         * @param operations
         */
        public systemLocationsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Location> {
            const localVarPath = this.basePath + '/system/locations/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemLocationsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemLocationsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Location
         * @param id
         * @param location
         */
        public systemLocationsIdPut (params: {  id: number; location: Location; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Location> {
            const localVarPath = this.basePath + '/system/locations/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemLocationsIdPut');
            }
            // verify required parameter 'location' is set
            if (params.location == null) {
                throw new Error('Missing required parameter location when calling systemLocationsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.location),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Location
         * @param location
         */
        public systemLocationsPost (params: {  location: Location; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Location> {
            const localVarPath = this.basePath + '/system/locations';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'location' is set
            if (params.location == null) {
                throw new Error('Missing required parameter location when calling systemLocationsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.location),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ManagedDevicesIntegrationCrossReferencesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Cross Reference Count
         * @param id
         * @param conditions
         */
        public companyManagedDevicesIntegrationsIdCrossReferencesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/managedDevicesIntegrations/{id}/crossReferences/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagedDevicesIntegrationsIdCrossReferencesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Cross Reference
         * @param id
         * @param crossReferenceID
         */
        public companyManagedDevicesIntegrationsIdCrossReferencesCrossReferenceIDDelete (params: {  id: number; crossReferenceID: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagedDevicesIntegrationCrossReference> {
            const localVarPath = this.basePath + '/company/managedDevicesIntegrations/{id}/crossReferences/{crossReferenceID}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'crossReferenceID' + '}', String(params.crossReferenceID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagedDevicesIntegrationsIdCrossReferencesCrossReferenceIDDelete');
            }
            // verify required parameter 'crossReferenceID' is set
            if (params.crossReferenceID == null) {
                throw new Error('Missing required parameter crossReferenceID when calling companyManagedDevicesIntegrationsIdCrossReferencesCrossReferenceIDDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Cross Reference By Id
         * @param id
         * @param crossReferenceID
         */
        public companyManagedDevicesIntegrationsIdCrossReferencesCrossReferenceIDGet (params: {  id: number; crossReferenceID: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagedDevicesIntegrationCrossReference> {
            const localVarPath = this.basePath + '/company/managedDevicesIntegrations/{id}/crossReferences/{crossReferenceID}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'crossReferenceID' + '}', String(params.crossReferenceID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagedDevicesIntegrationsIdCrossReferencesCrossReferenceIDGet');
            }
            // verify required parameter 'crossReferenceID' is set
            if (params.crossReferenceID == null) {
                throw new Error('Missing required parameter crossReferenceID when calling companyManagedDevicesIntegrationsIdCrossReferencesCrossReferenceIDGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Cross Reference
         * @param id
         * @param crossReferenceID
         * @param operations
         */
        public companyManagedDevicesIntegrationsIdCrossReferencesCrossReferenceIDPatch (params: {  id: number; crossReferenceID: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagedDevicesIntegrationCrossReference> {
            const localVarPath = this.basePath + '/company/managedDevicesIntegrations/{id}/crossReferences/{crossReferenceID}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'crossReferenceID' + '}', String(params.crossReferenceID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagedDevicesIntegrationsIdCrossReferencesCrossReferenceIDPatch');
            }
            // verify required parameter 'crossReferenceID' is set
            if (params.crossReferenceID == null) {
                throw new Error('Missing required parameter crossReferenceID when calling companyManagedDevicesIntegrationsIdCrossReferencesCrossReferenceIDPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyManagedDevicesIntegrationsIdCrossReferencesCrossReferenceIDPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Cross Reference
         * @param id
         * @param crossReferenceID
         * @param crossReference
         */
        public companyManagedDevicesIntegrationsIdCrossReferencesCrossReferenceIDPut (params: {  id: number; crossReferenceID: number; crossReference: ManagedDevicesIntegrationCrossReference; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagedDevicesIntegrationCrossReference> {
            const localVarPath = this.basePath + '/company/managedDevicesIntegrations/{id}/crossReferences/{crossReferenceID}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'crossReferenceID' + '}', String(params.crossReferenceID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagedDevicesIntegrationsIdCrossReferencesCrossReferenceIDPut');
            }
            // verify required parameter 'crossReferenceID' is set
            if (params.crossReferenceID == null) {
                throw new Error('Missing required parameter crossReferenceID when calling companyManagedDevicesIntegrationsIdCrossReferencesCrossReferenceIDPut');
            }
            // verify required parameter 'crossReference' is set
            if (params.crossReference == null) {
                throw new Error('Missing required parameter crossReference when calling companyManagedDevicesIntegrationsIdCrossReferencesCrossReferenceIDPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.crossReference),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Cross Reference
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyManagedDevicesIntegrationsIdCrossReferencesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ManagedDevicesIntegrationCrossReference>> {
            const localVarPath = this.basePath + '/company/managedDevicesIntegrations/{id}/crossReferences'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagedDevicesIntegrationsIdCrossReferencesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Cross Reference
         * @param id
         * @param crossReference
         */
        public companyManagedDevicesIntegrationsIdCrossReferencesPost (params: {  id: number; crossReference: ManagedDevicesIntegrationCrossReference; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagedDevicesIntegrationCrossReference> {
            const localVarPath = this.basePath + '/company/managedDevicesIntegrations/{id}/crossReferences'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagedDevicesIntegrationsIdCrossReferencesPost');
            }
            // verify required parameter 'crossReference' is set
            if (params.crossReference == null) {
                throw new Error('Missing required parameter crossReference when calling companyManagedDevicesIntegrationsIdCrossReferencesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.crossReference),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ManagedDevicesIntegrationLoginsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Login Count
         * @param id
         * @param conditions
         */
        public companyManagedDevicesIntegrationsIdLoginsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/managedDevicesIntegrations/{id}/logins/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagedDevicesIntegrationsIdLoginsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Login
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyManagedDevicesIntegrationsIdLoginsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ManagedDevicesIntegrationLogin>> {
            const localVarPath = this.basePath + '/company/managedDevicesIntegrations/{id}/logins'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagedDevicesIntegrationsIdLoginsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Login
         * @param id
         * @param loginID
         */
        public companyManagedDevicesIntegrationsIdLoginsLoginIDDelete (params: {  id: number; loginID: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagedDevicesIntegrationLogin> {
            const localVarPath = this.basePath + '/company/managedDevicesIntegrations/{id}/logins/{loginID}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'loginID' + '}', String(params.loginID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagedDevicesIntegrationsIdLoginsLoginIDDelete');
            }
            // verify required parameter 'loginID' is set
            if (params.loginID == null) {
                throw new Error('Missing required parameter loginID when calling companyManagedDevicesIntegrationsIdLoginsLoginIDDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Login By Id
         * @param id
         * @param loginID
         */
        public companyManagedDevicesIntegrationsIdLoginsLoginIDGet (params: {  id: number; loginID: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagedDevicesIntegrationLogin> {
            const localVarPath = this.basePath + '/company/managedDevicesIntegrations/{id}/logins/{loginID}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'loginID' + '}', String(params.loginID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagedDevicesIntegrationsIdLoginsLoginIDGet');
            }
            // verify required parameter 'loginID' is set
            if (params.loginID == null) {
                throw new Error('Missing required parameter loginID when calling companyManagedDevicesIntegrationsIdLoginsLoginIDGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Login
         * @param id
         * @param loginID
         * @param operations
         */
        public companyManagedDevicesIntegrationsIdLoginsLoginIDPatch (params: {  id: number; loginID: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagedDevicesIntegrationLogin> {
            const localVarPath = this.basePath + '/company/managedDevicesIntegrations/{id}/logins/{loginID}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'loginID' + '}', String(params.loginID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagedDevicesIntegrationsIdLoginsLoginIDPatch');
            }
            // verify required parameter 'loginID' is set
            if (params.loginID == null) {
                throw new Error('Missing required parameter loginID when calling companyManagedDevicesIntegrationsIdLoginsLoginIDPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyManagedDevicesIntegrationsIdLoginsLoginIDPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Login
         * @param id
         * @param loginID
         * @param login
         */
        public companyManagedDevicesIntegrationsIdLoginsLoginIDPut (params: {  id: number; loginID: number; login: ManagedDevicesIntegrationLogin; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagedDevicesIntegrationLogin> {
            const localVarPath = this.basePath + '/company/managedDevicesIntegrations/{id}/logins/{loginID}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'loginID' + '}', String(params.loginID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagedDevicesIntegrationsIdLoginsLoginIDPut');
            }
            // verify required parameter 'loginID' is set
            if (params.loginID == null) {
                throw new Error('Missing required parameter loginID when calling companyManagedDevicesIntegrationsIdLoginsLoginIDPut');
            }
            // verify required parameter 'login' is set
            if (params.login == null) {
                throw new Error('Missing required parameter login when calling companyManagedDevicesIntegrationsIdLoginsLoginIDPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.login),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Login
         * @param id
         * @param login
         */
        public companyManagedDevicesIntegrationsIdLoginsPost (params: {  id: number; login: ManagedDevicesIntegrationLogin; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagedDevicesIntegrationLogin> {
            const localVarPath = this.basePath + '/company/managedDevicesIntegrations/{id}/logins'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagedDevicesIntegrationsIdLoginsPost');
            }
            // verify required parameter 'login' is set
            if (params.login == null) {
                throw new Error('Missing required parameter login when calling companyManagedDevicesIntegrationsIdLoginsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.login),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ManagedDevicesIntegrationNotificationsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Notification Count
         * @param id
         * @param conditions
         */
        public companyManagedDevicesIntegrationsIdNotificationsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/managedDevicesIntegrations/{id}/notifications/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagedDevicesIntegrationsIdNotificationsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Notification
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyManagedDevicesIntegrationsIdNotificationsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ManagedDevicesIntegrationNotification>> {
            const localVarPath = this.basePath + '/company/managedDevicesIntegrations/{id}/notifications'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagedDevicesIntegrationsIdNotificationsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Notification
         * @param id
         * @param notificationID
         */
        public companyManagedDevicesIntegrationsIdNotificationsNotificationIDDelete (params: {  id: number; notificationID: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagedDevicesIntegrationNotification> {
            const localVarPath = this.basePath + '/company/managedDevicesIntegrations/{id}/notifications/{notificationID}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'notificationID' + '}', String(params.notificationID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagedDevicesIntegrationsIdNotificationsNotificationIDDelete');
            }
            // verify required parameter 'notificationID' is set
            if (params.notificationID == null) {
                throw new Error('Missing required parameter notificationID when calling companyManagedDevicesIntegrationsIdNotificationsNotificationIDDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Notification By Id
         * @param id
         * @param notificationID
         */
        public companyManagedDevicesIntegrationsIdNotificationsNotificationIDGet (params: {  id: number; notificationID: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagedDevicesIntegrationNotification> {
            const localVarPath = this.basePath + '/company/managedDevicesIntegrations/{id}/notifications/{notificationID}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'notificationID' + '}', String(params.notificationID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagedDevicesIntegrationsIdNotificationsNotificationIDGet');
            }
            // verify required parameter 'notificationID' is set
            if (params.notificationID == null) {
                throw new Error('Missing required parameter notificationID when calling companyManagedDevicesIntegrationsIdNotificationsNotificationIDGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Notification
         * @param id
         * @param notificationID
         * @param operations
         */
        public companyManagedDevicesIntegrationsIdNotificationsNotificationIDPatch (params: {  id: number; notificationID: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagedDevicesIntegrationNotification> {
            const localVarPath = this.basePath + '/company/managedDevicesIntegrations/{id}/notifications/{notificationID}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'notificationID' + '}', String(params.notificationID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagedDevicesIntegrationsIdNotificationsNotificationIDPatch');
            }
            // verify required parameter 'notificationID' is set
            if (params.notificationID == null) {
                throw new Error('Missing required parameter notificationID when calling companyManagedDevicesIntegrationsIdNotificationsNotificationIDPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyManagedDevicesIntegrationsIdNotificationsNotificationIDPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Notification
         * @param id
         * @param notificationID
         * @param notification
         */
        public companyManagedDevicesIntegrationsIdNotificationsNotificationIDPut (params: {  id: number; notificationID: number; notification: ManagedDevicesIntegrationNotification; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagedDevicesIntegrationNotification> {
            const localVarPath = this.basePath + '/company/managedDevicesIntegrations/{id}/notifications/{notificationID}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'notificationID' + '}', String(params.notificationID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagedDevicesIntegrationsIdNotificationsNotificationIDPut');
            }
            // verify required parameter 'notificationID' is set
            if (params.notificationID == null) {
                throw new Error('Missing required parameter notificationID when calling companyManagedDevicesIntegrationsIdNotificationsNotificationIDPut');
            }
            // verify required parameter 'notification' is set
            if (params.notification == null) {
                throw new Error('Missing required parameter notification when calling companyManagedDevicesIntegrationsIdNotificationsNotificationIDPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.notification),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Notification
         * @param id
         * @param notification
         */
        public companyManagedDevicesIntegrationsIdNotificationsPost (params: {  id: number; notification: ManagedDevicesIntegrationNotification; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagedDevicesIntegrationNotification> {
            const localVarPath = this.basePath + '/company/managedDevicesIntegrations/{id}/notifications'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagedDevicesIntegrationsIdNotificationsPost');
            }
            // verify required parameter 'notification' is set
            if (params.notification == null) {
                throw new Error('Missing required parameter notification when calling companyManagedDevicesIntegrationsIdNotificationsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.notification),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ManagedDevicesIntegrationsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Managed Devices Integrations Count
         * @param conditions
         */
        public companyManagedDevicesIntegrationsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/managedDevicesIntegrations/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Managed Devices Integrations
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyManagedDevicesIntegrationsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ManagedDevicesIntegration>> {
            const localVarPath = this.basePath + '/company/managedDevicesIntegrations';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Managed Devices Integration By Id
         * @param id
         */
        public companyManagedDevicesIntegrationsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/managedDevicesIntegrations/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagedDevicesIntegrationsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Managed Devices Integration By Id
         * @param id
         */
        public companyManagedDevicesIntegrationsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagedDevicesIntegration> {
            const localVarPath = this.basePath + '/company/managedDevicesIntegrations/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagedDevicesIntegrationsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Managed Devices Integration
         * @param id
         * @param operations
         */
        public companyManagedDevicesIntegrationsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagedDevicesIntegration> {
            const localVarPath = this.basePath + '/company/managedDevicesIntegrations/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagedDevicesIntegrationsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyManagedDevicesIntegrationsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Managed Devices Integration
         * @param id
         * @param managedDevicesIntegration
         */
        public companyManagedDevicesIntegrationsIdPut (params: {  id: number; managedDevicesIntegration: ManagedDevicesIntegration; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagedDevicesIntegration> {
            const localVarPath = this.basePath + '/company/managedDevicesIntegrations/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagedDevicesIntegrationsIdPut');
            }
            // verify required parameter 'managedDevicesIntegration' is set
            if (params.managedDevicesIntegration == null) {
                throw new Error('Missing required parameter managedDevicesIntegration when calling companyManagedDevicesIntegrationsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.managedDevicesIntegration),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Managed Devices Integration
         * @param managedDevicesIntegration
         */
        public companyManagedDevicesIntegrationsPost (params: {  managedDevicesIntegration: ManagedDevicesIntegration; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagedDevicesIntegration> {
            const localVarPath = this.basePath + '/company/managedDevicesIntegrations';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'managedDevicesIntegration' is set
            if (params.managedDevicesIntegration == null) {
                throw new Error('Missing required parameter managedDevicesIntegration when calling companyManagedDevicesIntegrationsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.managedDevicesIntegration),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ManagementBackupsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Management Backup Count
         * @param conditions
         */
        public companyManagementBackupsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/managementBackups/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Management Backup
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyManagementBackupsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ManagementBackup>> {
            const localVarPath = this.basePath + '/company/managementBackups';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Management Backup By Id
         * @param id
         */
        public companyManagementBackupsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/managementBackups/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagementBackupsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Management Backup By Id
         * @param id
         */
        public companyManagementBackupsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagementBackup> {
            const localVarPath = this.basePath + '/company/managementBackups/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagementBackupsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Management Backup
         * @param id
         * @param operations
         */
        public companyManagementBackupsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagementBackup> {
            const localVarPath = this.basePath + '/company/managementBackups/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagementBackupsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyManagementBackupsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Management Backup
         * @param id
         * @param managementBackup
         */
        public companyManagementBackupsIdPut (params: {  id: number; managementBackup: ManagementBackup; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagementBackup> {
            const localVarPath = this.basePath + '/company/managementBackups/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagementBackupsIdPut');
            }
            // verify required parameter 'managementBackup' is set
            if (params.managementBackup == null) {
                throw new Error('Missing required parameter managementBackup when calling companyManagementBackupsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.managementBackup),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Management Backup
         * @param managementBackup
         */
        public companyManagementBackupsPost (params: {  managementBackup: ManagementBackup; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagementBackup> {
            const localVarPath = this.basePath + '/company/managementBackups';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'managementBackup' is set
            if (params.managementBackup == null) {
                throw new Error('Missing required parameter managementBackup when calling companyManagementBackupsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.managementBackup),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ManagementEmailsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Management Email Count
         * @param conditions
         */
        public companyManagementEmailsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/managementEmails/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Management Email
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyManagementEmailsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ManagementEmail>> {
            const localVarPath = this.basePath + '/company/managementEmails';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Management Email By Id
         * @param id
         */
        public companyManagementEmailsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/managementEmails/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagementEmailsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Management Email By Id
         * @param id
         */
        public companyManagementEmailsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagementEmail> {
            const localVarPath = this.basePath + '/company/managementEmails/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagementEmailsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Management Email
         * @param id
         * @param operations
         */
        public companyManagementEmailsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagementEmail> {
            const localVarPath = this.basePath + '/company/managementEmails/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagementEmailsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyManagementEmailsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Management Email
         * @param id
         * @param managementEmail
         */
        public companyManagementEmailsIdPut (params: {  id: number; managementEmail: ManagementEmail; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagementEmail> {
            const localVarPath = this.basePath + '/company/managementEmails/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagementEmailsIdPut');
            }
            // verify required parameter 'managementEmail' is set
            if (params.managementEmail == null) {
                throw new Error('Missing required parameter managementEmail when calling companyManagementEmailsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.managementEmail),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Management Email
         * @param managementEmail
         */
        public companyManagementEmailsPost (params: {  managementEmail: ManagementEmail; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagementEmail> {
            const localVarPath = this.basePath + '/company/managementEmails';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'managementEmail' is set
            if (params.managementEmail == null) {
                throw new Error('Missing required parameter managementEmail when calling companyManagementEmailsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.managementEmail),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ManagementExecuteManagedItSyncsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Execute Managed It Sync
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyManagementIdExecuteManagedItSyncPost (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SuccessResponse> {
            const localVarPath = this.basePath + '/company/management/{id}/executeManagedItSync';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ManagementItSolutionAgreementInterfaceParametersApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Management Product Count
         * @param id
         * @param conditions
         */
        public companyManagementItSolutionsIdManagementProductsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/managementItSolutions/{id}/managementProducts/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagementItSolutionsIdManagementProductsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Management Product
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyManagementItSolutionsIdManagementProductsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ManagementItSolutionAgreementInterfaceParameter>> {
            const localVarPath = this.basePath + '/company/managementItSolutions/{id}/managementProducts'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagementItSolutionsIdManagementProductsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Management Product
         * @param id
         * @param managementProductID
         */
        public companyManagementItSolutionsIdManagementProductsManagementProductIDDelete (params: {  id: number; managementProductID: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagementItSolutionAgreementInterfaceParameter> {
            const localVarPath = this.basePath + '/company/managementItSolutions/{id}/managementProducts/{managementProductID}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'managementProductID' + '}', String(params.managementProductID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagementItSolutionsIdManagementProductsManagementProductIDDelete');
            }
            // verify required parameter 'managementProductID' is set
            if (params.managementProductID == null) {
                throw new Error('Missing required parameter managementProductID when calling companyManagementItSolutionsIdManagementProductsManagementProductIDDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Management Product By Id
         * @param id
         * @param managementProductID
         */
        public companyManagementItSolutionsIdManagementProductsManagementProductIDGet (params: {  id: number; managementProductID: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagementItSolutionAgreementInterfaceParameter> {
            const localVarPath = this.basePath + '/company/managementItSolutions/{id}/managementProducts/{managementProductID}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'managementProductID' + '}', String(params.managementProductID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagementItSolutionsIdManagementProductsManagementProductIDGet');
            }
            // verify required parameter 'managementProductID' is set
            if (params.managementProductID == null) {
                throw new Error('Missing required parameter managementProductID when calling companyManagementItSolutionsIdManagementProductsManagementProductIDGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Management Product
         * @param id
         * @param managementProductID
         * @param operations
         */
        public companyManagementItSolutionsIdManagementProductsManagementProductIDPatch (params: {  id: number; managementProductID: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagementItSolutionAgreementInterfaceParameter> {
            const localVarPath = this.basePath + '/company/managementItSolutions/{id}/managementProducts/{managementProductID}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'managementProductID' + '}', String(params.managementProductID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagementItSolutionsIdManagementProductsManagementProductIDPatch');
            }
            // verify required parameter 'managementProductID' is set
            if (params.managementProductID == null) {
                throw new Error('Missing required parameter managementProductID when calling companyManagementItSolutionsIdManagementProductsManagementProductIDPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyManagementItSolutionsIdManagementProductsManagementProductIDPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Management Product
         * @param id
         * @param managementProductID
         * @param managementProduct
         */
        public companyManagementItSolutionsIdManagementProductsManagementProductIDPut (params: {  id: number; managementProductID: number; managementProduct: ManagementItSolutionAgreementInterfaceParameter; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagementItSolutionAgreementInterfaceParameter> {
            const localVarPath = this.basePath + '/company/managementItSolutions/{id}/managementProducts/{managementProductID}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'managementProductID' + '}', String(params.managementProductID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagementItSolutionsIdManagementProductsManagementProductIDPut');
            }
            // verify required parameter 'managementProductID' is set
            if (params.managementProductID == null) {
                throw new Error('Missing required parameter managementProductID when calling companyManagementItSolutionsIdManagementProductsManagementProductIDPut');
            }
            // verify required parameter 'managementProduct' is set
            if (params.managementProduct == null) {
                throw new Error('Missing required parameter managementProduct when calling companyManagementItSolutionsIdManagementProductsManagementProductIDPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.managementProduct),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Management Product
         * @param id
         * @param managementProduct
         */
        public companyManagementItSolutionsIdManagementProductsPost (params: {  id: number; managementProduct: ManagementItSolutionAgreementInterfaceParameter; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagementItSolutionAgreementInterfaceParameter> {
            const localVarPath = this.basePath + '/company/managementItSolutions/{id}/managementProducts'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagementItSolutionsIdManagementProductsPost');
            }
            // verify required parameter 'managementProduct' is set
            if (params.managementProduct == null) {
                throw new Error('Missing required parameter managementProduct when calling companyManagementItSolutionsIdManagementProductsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.managementProduct),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ManagementItSolutionsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Management It Solutions Count
         * @param conditions
         */
        public companyManagementItSolutionsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/managementItSolutions/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Management It Solutions
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyManagementItSolutionsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ManagementItSolution>> {
            const localVarPath = this.basePath + '/company/managementItSolutions';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Management It Solution By Id
         * @param id
         */
        public companyManagementItSolutionsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/managementItSolutions/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagementItSolutionsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Management It Solution By Id
         * @param id
         */
        public companyManagementItSolutionsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagementItSolution> {
            const localVarPath = this.basePath + '/company/managementItSolutions/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagementItSolutionsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Management It Solution
         * @param id
         * @param operations
         */
        public companyManagementItSolutionsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagementItSolution> {
            const localVarPath = this.basePath + '/company/managementItSolutions/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagementItSolutionsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyManagementItSolutionsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Management It Solution
         * @param id
         * @param managementItSolution
         */
        public companyManagementItSolutionsIdPut (params: {  id: number; managementItSolution: ManagementItSolution; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagementItSolution> {
            const localVarPath = this.basePath + '/company/managementItSolutions/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagementItSolutionsIdPut');
            }
            // verify required parameter 'managementItSolution' is set
            if (params.managementItSolution == null) {
                throw new Error('Missing required parameter managementItSolution when calling companyManagementItSolutionsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.managementItSolution),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Management It Solution
         * @param managementItSolution
         */
        public companyManagementItSolutionsPost (params: {  managementItSolution: ManagementItSolution; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagementItSolution> {
            const localVarPath = this.basePath + '/company/managementItSolutions';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'managementItSolution' is set
            if (params.managementItSolution == null) {
                throw new Error('Missing required parameter managementItSolution when calling companyManagementItSolutionsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.managementItSolution),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ManagementLogsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Download Document
         * @param filePath
         */
        public companyManagementIdLogDownloadGet (params: {  filePath?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/management/{id}/log/download';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.filePath !== undefined) {
                queryParameters['filePath'] = params.filePath;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Management Execute Managed It Syncs
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyManagementIdLogsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ManagementLogDocumentInfo>> {
            const localVarPath = this.basePath + '/company/management/{id}/logs';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ManagementNetworksSecurityApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Management Network Security Count
         * @param conditions
         */
        public systemManagementNetworkSecuritiesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/managementNetworkSecurities/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Management Networks Security
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemManagementNetworkSecuritiesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ManagementNetworkSecurity>> {
            const localVarPath = this.basePath + '/system/managementNetworkSecurities';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Management Network Security By Id
         * @param id
         */
        public systemManagementNetworkSecuritiesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/managementNetworkSecurities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemManagementNetworkSecuritiesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Management Network Security By Id
         * @param id
         */
        public systemManagementNetworkSecuritiesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagementNetworkSecurity> {
            const localVarPath = this.basePath + '/system/managementNetworkSecurities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemManagementNetworkSecuritiesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Management Network Security
         * @param id
         * @param operations
         */
        public systemManagementNetworkSecuritiesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagementNetworkSecurity> {
            const localVarPath = this.basePath + '/system/managementNetworkSecurities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemManagementNetworkSecuritiesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemManagementNetworkSecuritiesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Management Network Security
         * @param id
         * @param managementNetworkSecurity
         */
        public systemManagementNetworkSecuritiesIdPut (params: {  id: number; managementNetworkSecurity: ManagementNetworkSecurity; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagementNetworkSecurity> {
            const localVarPath = this.basePath + '/system/managementNetworkSecurities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemManagementNetworkSecuritiesIdPut');
            }
            // verify required parameter 'managementNetworkSecurity' is set
            if (params.managementNetworkSecurity == null) {
                throw new Error('Missing required parameter managementNetworkSecurity when calling systemManagementNetworkSecuritiesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.managementNetworkSecurity),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Management Network Security
         * @param managementNetworkSecurity
         */
        public systemManagementNetworkSecuritiesPost (params: {  managementNetworkSecurity: ManagementNetworkSecurity; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagementNetworkSecurity> {
            const localVarPath = this.basePath + '/system/managementNetworkSecurities';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'managementNetworkSecurity' is set
            if (params.managementNetworkSecurity == null) {
                throw new Error('Missing required parameter managementNetworkSecurity when calling systemManagementNetworkSecuritiesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.managementNetworkSecurity),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Test Credentials
         * @param id
         */
        public systemManagementNetworkSecuritiesTestCredentialsGet (params: {  id?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SuccessResponse> {
            const localVarPath = this.basePath + '/system/managementNetworkSecurities/testCredentials';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.id !== undefined) {
                queryParameters['id'] = params.id;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ManagementReportNotificationsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Management Report Notifications Count
         * @param id
         * @param conditions
         */
        public companyManagementIdManagementReportNotificationsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/management/{id}/managementReportNotifications/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagementIdManagementReportNotificationsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Management Report Notifications
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyManagementIdManagementReportNotificationsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ManagementReportNotification>> {
            const localVarPath = this.basePath + '/company/management/{id}/managementReportNotifications'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagementIdManagementReportNotificationsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Management Report Notification By Id
         * @param id
         * @param managementReportNotificationId
         */
        public companyManagementIdManagementReportNotificationsManagementReportNotificationIdDelete (params: {  id: number; managementReportNotificationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/management/{id}/managementReportNotifications/{managementReportNotificationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'managementReportNotificationId' + '}', String(params.managementReportNotificationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagementIdManagementReportNotificationsManagementReportNotificationIdDelete');
            }
            // verify required parameter 'managementReportNotificationId' is set
            if (params.managementReportNotificationId == null) {
                throw new Error('Missing required parameter managementReportNotificationId when calling companyManagementIdManagementReportNotificationsManagementReportNotificationIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Management Report Notification By Id
         * @param id
         * @param managementReportNotificationId
         */
        public companyManagementIdManagementReportNotificationsManagementReportNotificationIdGet (params: {  id: number; managementReportNotificationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagementReportNotification> {
            const localVarPath = this.basePath + '/company/management/{id}/managementReportNotifications/{managementReportNotificationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'managementReportNotificationId' + '}', String(params.managementReportNotificationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagementIdManagementReportNotificationsManagementReportNotificationIdGet');
            }
            // verify required parameter 'managementReportNotificationId' is set
            if (params.managementReportNotificationId == null) {
                throw new Error('Missing required parameter managementReportNotificationId when calling companyManagementIdManagementReportNotificationsManagementReportNotificationIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Management Report Notification
         * @param id
         * @param managementReportNotificationId
         * @param operations
         */
        public companyManagementIdManagementReportNotificationsManagementReportNotificationIdPatch (params: {  id: number; managementReportNotificationId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagementReportNotification> {
            const localVarPath = this.basePath + '/company/management/{id}/managementReportNotifications/{managementReportNotificationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'managementReportNotificationId' + '}', String(params.managementReportNotificationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagementIdManagementReportNotificationsManagementReportNotificationIdPatch');
            }
            // verify required parameter 'managementReportNotificationId' is set
            if (params.managementReportNotificationId == null) {
                throw new Error('Missing required parameter managementReportNotificationId when calling companyManagementIdManagementReportNotificationsManagementReportNotificationIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyManagementIdManagementReportNotificationsManagementReportNotificationIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Management Report Notification
         * @param id
         * @param managementReportNotificationId
         * @param managementReportNotification
         */
        public companyManagementIdManagementReportNotificationsManagementReportNotificationIdPut (params: {  id: number; managementReportNotificationId: number; managementReportNotification: ManagementReportNotification; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagementReportNotification> {
            const localVarPath = this.basePath + '/company/management/{id}/managementReportNotifications/{managementReportNotificationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'managementReportNotificationId' + '}', String(params.managementReportNotificationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagementIdManagementReportNotificationsManagementReportNotificationIdPut');
            }
            // verify required parameter 'managementReportNotificationId' is set
            if (params.managementReportNotificationId == null) {
                throw new Error('Missing required parameter managementReportNotificationId when calling companyManagementIdManagementReportNotificationsManagementReportNotificationIdPut');
            }
            // verify required parameter 'managementReportNotification' is set
            if (params.managementReportNotification == null) {
                throw new Error('Missing required parameter managementReportNotification when calling companyManagementIdManagementReportNotificationsManagementReportNotificationIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.managementReportNotification),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Management Report Notification
         * @param id
         * @param managementReportNotification
         */
        public companyManagementIdManagementReportNotificationsPost (params: {  id: number; managementReportNotification: ManagementReportNotification; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagementReportNotification> {
            const localVarPath = this.basePath + '/company/management/{id}/managementReportNotifications'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagementIdManagementReportNotificationsPost');
            }
            // verify required parameter 'managementReportNotification' is set
            if (params.managementReportNotification == null) {
                throw new Error('Missing required parameter managementReportNotification when calling companyManagementIdManagementReportNotificationsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.managementReportNotification),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ManagementsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Managements Count
         * @param conditions
         */
        public companyManagementCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/management/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Managements
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyManagementGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Management>> {
            const localVarPath = this.basePath + '/company/management';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Management By Id
         * @param id
         */
        public companyManagementIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Management> {
            const localVarPath = this.basePath + '/company/management/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagementIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Management
         * @param id
         * @param operations
         */
        public companyManagementIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Management> {
            const localVarPath = this.basePath + '/company/management/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagementIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyManagementIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Management
         * @param id
         * @param management
         */
        public companyManagementIdPut (params: {  id: number; management: Management; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Management> {
            const localVarPath = this.basePath + '/company/management/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyManagementIdPut');
            }
            // verify required parameter 'management' is set
            if (params.management == null) {
                throw new Error('Missing required parameter management when calling companyManagementIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.management),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ManufacturersApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Manufacturers Count
         * @param conditions
         */
        public procurementManufacturersCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/manufacturers/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Manufacturers
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementManufacturersGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Manufacturer>> {
            const localVarPath = this.basePath + '/procurement/manufacturers';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Manufacturer By Id
         * @param id
         */
        public procurementManufacturersIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/manufacturers/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementManufacturersIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Manufacturer By Id
         * @param id
         */
        public procurementManufacturersIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Manufacturer> {
            const localVarPath = this.basePath + '/procurement/manufacturers/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementManufacturersIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Manufacturer
         * @param id
         * @param operations
         */
        public procurementManufacturersIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Manufacturer> {
            const localVarPath = this.basePath + '/procurement/manufacturers/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementManufacturersIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementManufacturersIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Manufacturer
         * @param id
         * @param manufacturer
         */
        public procurementManufacturersIdPut (params: {  id: number; manufacturer: Manufacturer; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Manufacturer> {
            const localVarPath = this.basePath + '/procurement/manufacturers/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementManufacturersIdPut');
            }
            // verify required parameter 'manufacturer' is set
            if (params.manufacturer == null) {
                throw new Error('Missing required parameter manufacturer when calling procurementManufacturersIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.manufacturer),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Manufacturer
         * @param manufacturer
         */
        public procurementManufacturersPost (params: {  manufacturer: Manufacturer; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Manufacturer> {
            const localVarPath = this.basePath + '/procurement/manufacturers';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'manufacturer' is set
            if (params.manufacturer == null) {
                throw new Error('Missing required parameter manufacturer when calling procurementManufacturersPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.manufacturer),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class MarketDescriptionsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Market Description Count
         * @param conditions
         */
        public companyMarketDescriptionsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/marketDescriptions/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Market Description
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyMarketDescriptionsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<MarketDescription>> {
            const localVarPath = this.basePath + '/company/marketDescriptions';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Market Description By Id
         * @param id
         */
        public companyMarketDescriptionsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/marketDescriptions/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyMarketDescriptionsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Market Description By Id
         * @param id
         */
        public companyMarketDescriptionsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MarketDescription> {
            const localVarPath = this.basePath + '/company/marketDescriptions/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyMarketDescriptionsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Market Description
         * @param id
         * @param operations
         */
        public companyMarketDescriptionsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MarketDescription> {
            const localVarPath = this.basePath + '/company/marketDescriptions/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyMarketDescriptionsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyMarketDescriptionsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Market Description
         * @param id
         * @param marketDescription
         */
        public companyMarketDescriptionsIdPut (params: {  id: number; marketDescription: MarketDescription; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MarketDescription> {
            const localVarPath = this.basePath + '/company/marketDescriptions/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyMarketDescriptionsIdPut');
            }
            // verify required parameter 'marketDescription' is set
            if (params.marketDescription == null) {
                throw new Error('Missing required parameter marketDescription when calling companyMarketDescriptionsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.marketDescription),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Market Description
         * @param marketDescription
         */
        public companyMarketDescriptionsPost (params: {  marketDescription: MarketDescription; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MarketDescription> {
            const localVarPath = this.basePath + '/company/marketDescriptions';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'marketDescription' is set
            if (params.marketDescription == null) {
                throw new Error('Missing required parameter marketDescription when calling companyMarketDescriptionsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.marketDescription),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class MemberAccrualsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Delete Member Accrual By Id
         * @param id
         * @param accrualId
         */
        public systemMembersIdAccrualsAccrualIdDelete (params: {  id: number; accrualId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/members/{id}/accruals/{accrualId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'accrualId' + '}', String(params.accrualId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersIdAccrualsAccrualIdDelete');
            }
            // verify required parameter 'accrualId' is set
            if (params.accrualId == null) {
                throw new Error('Missing required parameter accrualId when calling systemMembersIdAccrualsAccrualIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Member Accrual By Id
         * @param id
         * @param accrualId
         */
        public systemMembersIdAccrualsAccrualIdGet (params: {  id: number; accrualId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MemberAccrual> {
            const localVarPath = this.basePath + '/system/members/{id}/accruals/{accrualId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'accrualId' + '}', String(params.accrualId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersIdAccrualsAccrualIdGet');
            }
            // verify required parameter 'accrualId' is set
            if (params.accrualId == null) {
                throw new Error('Missing required parameter accrualId when calling systemMembersIdAccrualsAccrualIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Member Accrual
         * @param id
         * @param accrualId
         * @param operations
         */
        public systemMembersIdAccrualsAccrualIdPatch (params: {  id: number; accrualId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MemberAccrual> {
            const localVarPath = this.basePath + '/system/members/{id}/accruals/{accrualId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'accrualId' + '}', String(params.accrualId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersIdAccrualsAccrualIdPatch');
            }
            // verify required parameter 'accrualId' is set
            if (params.accrualId == null) {
                throw new Error('Missing required parameter accrualId when calling systemMembersIdAccrualsAccrualIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemMembersIdAccrualsAccrualIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Member Accrual
         * @param id
         * @param accrualId
         * @param memberAccrual
         */
        public systemMembersIdAccrualsAccrualIdPut (params: {  id: number; accrualId: number; memberAccrual: MemberAccrual; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MemberAccrual> {
            const localVarPath = this.basePath + '/system/members/{id}/accruals/{accrualId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'accrualId' + '}', String(params.accrualId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersIdAccrualsAccrualIdPut');
            }
            // verify required parameter 'accrualId' is set
            if (params.accrualId == null) {
                throw new Error('Missing required parameter accrualId when calling systemMembersIdAccrualsAccrualIdPut');
            }
            // verify required parameter 'memberAccrual' is set
            if (params.memberAccrual == null) {
                throw new Error('Missing required parameter memberAccrual when calling systemMembersIdAccrualsAccrualIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.memberAccrual),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Member Accruals Count
         * @param id
         * @param conditions
         */
        public systemMembersIdAccrualsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/members/{id}/accruals/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersIdAccrualsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Member Accruals
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemMembersIdAccrualsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<MemberAccrual>> {
            const localVarPath = this.basePath + '/system/members/{id}/accruals'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersIdAccrualsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Member Accrual
         * @param id
         * @param memberAccrual
         */
        public systemMembersIdAccrualsPost (params: {  id: number; memberAccrual: MemberAccrual; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MemberAccrual> {
            const localVarPath = this.basePath + '/system/members/{id}/accruals'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersIdAccrualsPost');
            }
            // verify required parameter 'memberAccrual' is set
            if (params.memberAccrual == null) {
                throw new Error('Missing required parameter memberAccrual when calling systemMembersIdAccrualsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.memberAccrual),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class MemberCertificationsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Delete Member Certification By Id
         * @param id
         * @param certId
         */
        public systemMembersIdCertificationsCertIdDelete (params: {  id: number; certId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/members/{id}/certifications/{certId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'certId' + '}', String(params.certId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersIdCertificationsCertIdDelete');
            }
            // verify required parameter 'certId' is set
            if (params.certId == null) {
                throw new Error('Missing required parameter certId when calling systemMembersIdCertificationsCertIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Member Certification By Id
         * @param id
         * @param certId
         */
        public systemMembersIdCertificationsCertIdGet (params: {  id: number; certId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MemberCertification> {
            const localVarPath = this.basePath + '/system/members/{id}/certifications/{certId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'certId' + '}', String(params.certId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersIdCertificationsCertIdGet');
            }
            // verify required parameter 'certId' is set
            if (params.certId == null) {
                throw new Error('Missing required parameter certId when calling systemMembersIdCertificationsCertIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Member Certification
         * @param id
         * @param certId
         * @param operations
         */
        public systemMembersIdCertificationsCertIdPatch (params: {  id: number; certId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MemberCertification> {
            const localVarPath = this.basePath + '/system/members/{id}/certifications/{certId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'certId' + '}', String(params.certId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersIdCertificationsCertIdPatch');
            }
            // verify required parameter 'certId' is set
            if (params.certId == null) {
                throw new Error('Missing required parameter certId when calling systemMembersIdCertificationsCertIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemMembersIdCertificationsCertIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Member Certification
         * @param id
         * @param certId
         * @param memberCertification
         */
        public systemMembersIdCertificationsCertIdPut (params: {  id: number; certId: number; memberCertification: MemberCertification; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MemberCertification> {
            const localVarPath = this.basePath + '/system/members/{id}/certifications/{certId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'certId' + '}', String(params.certId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersIdCertificationsCertIdPut');
            }
            // verify required parameter 'certId' is set
            if (params.certId == null) {
                throw new Error('Missing required parameter certId when calling systemMembersIdCertificationsCertIdPut');
            }
            // verify required parameter 'memberCertification' is set
            if (params.memberCertification == null) {
                throw new Error('Missing required parameter memberCertification when calling systemMembersIdCertificationsCertIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.memberCertification),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Member Certifications Count
         * @param id
         * @param conditions
         */
        public systemMembersIdCertificationsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/members/{id}/certifications/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersIdCertificationsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Member Certifications
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemMembersIdCertificationsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<MemberCertification>> {
            const localVarPath = this.basePath + '/system/members/{id}/certifications'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersIdCertificationsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Member Certification
         * @param id
         * @param memberCertification
         */
        public systemMembersIdCertificationsPost (params: {  id: number; memberCertification: MemberCertification; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MemberCertification> {
            const localVarPath = this.basePath + '/system/members/{id}/certifications'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersIdCertificationsPost');
            }
            // verify required parameter 'memberCertification' is set
            if (params.memberCertification == null) {
                throw new Error('Missing required parameter memberCertification when calling systemMembersIdCertificationsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.memberCertification),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class MemberDelegationsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Member Delegations Count
         * @param id
         * @param conditions
         */
        public systemMembersIdDelegationsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/members/{id}/delegations/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersIdDelegationsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Member Delegation By Id
         * @param id
         * @param delegationId
         */
        public systemMembersIdDelegationsDelegationIdDelete (params: {  id: number; delegationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/members/{id}/delegations/{delegationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'delegationId' + '}', String(params.delegationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersIdDelegationsDelegationIdDelete');
            }
            // verify required parameter 'delegationId' is set
            if (params.delegationId == null) {
                throw new Error('Missing required parameter delegationId when calling systemMembersIdDelegationsDelegationIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Member Delegation By Id
         * @param id
         * @param delegationId
         */
        public systemMembersIdDelegationsDelegationIdGet (params: {  id: number; delegationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MemberDelegation> {
            const localVarPath = this.basePath + '/system/members/{id}/delegations/{delegationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'delegationId' + '}', String(params.delegationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersIdDelegationsDelegationIdGet');
            }
            // verify required parameter 'delegationId' is set
            if (params.delegationId == null) {
                throw new Error('Missing required parameter delegationId when calling systemMembersIdDelegationsDelegationIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Member Delegation
         * @param id
         * @param delegationId
         * @param operations
         */
        public systemMembersIdDelegationsDelegationIdPatch (params: {  id: number; delegationId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MemberDelegation> {
            const localVarPath = this.basePath + '/system/members/{id}/delegations/{delegationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'delegationId' + '}', String(params.delegationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersIdDelegationsDelegationIdPatch');
            }
            // verify required parameter 'delegationId' is set
            if (params.delegationId == null) {
                throw new Error('Missing required parameter delegationId when calling systemMembersIdDelegationsDelegationIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemMembersIdDelegationsDelegationIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Member Delegation
         * @param id
         * @param delegationId
         * @param memberDelegation
         */
        public systemMembersIdDelegationsDelegationIdPut (params: {  id: number; delegationId: number; memberDelegation: MemberDelegation; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MemberDelegation> {
            const localVarPath = this.basePath + '/system/members/{id}/delegations/{delegationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'delegationId' + '}', String(params.delegationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersIdDelegationsDelegationIdPut');
            }
            // verify required parameter 'delegationId' is set
            if (params.delegationId == null) {
                throw new Error('Missing required parameter delegationId when calling systemMembersIdDelegationsDelegationIdPut');
            }
            // verify required parameter 'memberDelegation' is set
            if (params.memberDelegation == null) {
                throw new Error('Missing required parameter memberDelegation when calling systemMembersIdDelegationsDelegationIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.memberDelegation),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Member Delegations
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemMembersIdDelegationsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<MemberDelegation>> {
            const localVarPath = this.basePath + '/system/members/{id}/delegations'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersIdDelegationsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Member Delegation
         * @param id
         * @param memberDelegation
         */
        public systemMembersIdDelegationsPost (params: {  id: number; memberDelegation: MemberDelegation; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MemberDelegation> {
            const localVarPath = this.basePath + '/system/members/{id}/delegations'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersIdDelegationsPost');
            }
            // verify required parameter 'memberDelegation' is set
            if (params.memberDelegation == null) {
                throw new Error('Missing required parameter memberDelegation when calling systemMembersIdDelegationsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.memberDelegation),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class MemberSkillsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Member Skill Count
         * @param id
         * @param conditions
         */
        public systemMembersIdSkillsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/members/{id}/skills/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersIdSkillsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Member Skill
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemMembersIdSkillsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<MemberSkill>> {
            const localVarPath = this.basePath + '/system/members/{id}/skills'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersIdSkillsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Member Skill
         * @param id
         * @param memberSkill
         */
        public systemMembersIdSkillsPost (params: {  id: number; memberSkill: MemberSkill; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MemberSkill> {
            const localVarPath = this.basePath + '/system/members/{id}/skills'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersIdSkillsPost');
            }
            // verify required parameter 'memberSkill' is set
            if (params.memberSkill == null) {
                throw new Error('Missing required parameter memberSkill when calling systemMembersIdSkillsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.memberSkill),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Member Skill By Id
         * @param id
         * @param skillId
         */
        public systemMembersIdSkillsSkillIdDelete (params: {  id: number; skillId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/members/{id}/skills/{skillId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'skillId' + '}', String(params.skillId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersIdSkillsSkillIdDelete');
            }
            // verify required parameter 'skillId' is set
            if (params.skillId == null) {
                throw new Error('Missing required parameter skillId when calling systemMembersIdSkillsSkillIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Member Skill By Id
         * @param id
         * @param skillId
         */
        public systemMembersIdSkillsSkillIdGet (params: {  id: number; skillId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MemberSkill> {
            const localVarPath = this.basePath + '/system/members/{id}/skills/{skillId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'skillId' + '}', String(params.skillId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersIdSkillsSkillIdGet');
            }
            // verify required parameter 'skillId' is set
            if (params.skillId == null) {
                throw new Error('Missing required parameter skillId when calling systemMembersIdSkillsSkillIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Member Skill
         * @param id
         * @param skillId
         * @param operations
         */
        public systemMembersIdSkillsSkillIdPatch (params: {  id: number; skillId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MemberSkill> {
            const localVarPath = this.basePath + '/system/members/{id}/skills/{skillId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'skillId' + '}', String(params.skillId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersIdSkillsSkillIdPatch');
            }
            // verify required parameter 'skillId' is set
            if (params.skillId == null) {
                throw new Error('Missing required parameter skillId when calling systemMembersIdSkillsSkillIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemMembersIdSkillsSkillIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Member Skill
         * @param id
         * @param skillId
         * @param memberSkill
         */
        public systemMembersIdSkillsSkillIdPut (params: {  id: number; skillId: number; memberSkill: MemberSkill; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MemberSkill> {
            const localVarPath = this.basePath + '/system/members/{id}/skills/{skillId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'skillId' + '}', String(params.skillId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersIdSkillsSkillIdPut');
            }
            // verify required parameter 'skillId' is set
            if (params.skillId == null) {
                throw new Error('Missing required parameter skillId when calling systemMembersIdSkillsSkillIdPut');
            }
            // verify required parameter 'memberSkill' is set
            if (params.memberSkill == null) {
                throw new Error('Missing required parameter memberSkill when calling systemMembersIdSkillsSkillIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.memberSkill),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class MemberTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Type Count
         * @param conditions
         */
        public systemMembersTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/members/types/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Type
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemMembersTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Type>> {
            const localVarPath = this.basePath + '/system/members/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Type By Id
         * @param id
         */
        public systemMembersTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/members/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersTypesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Type By Id
         * @param id
         */
        public systemMembersTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Type> {
            const localVarPath = this.basePath + '/system/members/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersTypesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Type
         * @param id
         * @param operations
         */
        public systemMembersTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Type> {
            const localVarPath = this.basePath + '/system/members/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersTypesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemMembersTypesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Type
         * @param id
         * @param type
         */
        public systemMembersTypesIdPut (params: {  id: number; type: Type; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Type> {
            const localVarPath = this.basePath + '/system/members/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersTypesIdPut');
            }
            // verify required parameter 'type' is set
            if (params.type == null) {
                throw new Error('Missing required parameter type when calling systemMembersTypesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.type),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Type
         * @param type
         */
        public systemMembersTypesPost (params: {  type: Type; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Type> {
            const localVarPath = this.basePath + '/system/members/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'type' is set
            if (params.type == null) {
                throw new Error('Missing required parameter type when calling systemMembersTypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.type),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class MembersApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Members Count
         * @param conditions
         */
        public systemMembersCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/members/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Members
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemMembersGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Member>> {
            const localVarPath = this.basePath + '/system/members';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Deactivatemember
         * @param id
         * @param item
         */
        public systemMembersIdDeactivatePost (params: {  id: number; item: MemberDeactivation; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MemberDeactivation> {
            const localVarPath = this.basePath + '/system/members/{id}/deactivate'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersIdDeactivatePost');
            }
            // verify required parameter 'item' is set
            if (params.item == null) {
                throw new Error('Missing required parameter item when calling systemMembersIdDeactivatePost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.item),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Member By Id
         * @param id
         */
        public systemMembersIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Member> {
            const localVarPath = this.basePath + '/system/members/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Member
         * @param id
         * @param operations
         */
        public systemMembersIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Member> {
            const localVarPath = this.basePath + '/system/members/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemMembersIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Member
         * @param id
         * @param member
         */
        public systemMembersIdPut (params: {  id: number; member: Member; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Member> {
            const localVarPath = this.basePath + '/system/members/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersIdPut');
            }
            // verify required parameter 'member' is set
            if (params.member == null) {
                throw new Error('Missing required parameter member when calling systemMembersIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.member),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Member Unused Time Sheets
         * @param id
         */
        public systemMembersIdUnusedTimeSheetsDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/members/{id}/unusedTimeSheets'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMembersIdUnusedTimeSheetsDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Token By Member Identifier
         * @param memberIdentifier
         */
        public systemMembersMemberIdentifierTokensPost (params: {  memberIdentifier: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Token> {
            const localVarPath = this.basePath + '/system/members/{memberIdentifier}/tokens'
                .replace('{' + 'memberIdentifier' + '}', String(params.memberIdentifier));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'memberIdentifier' is set
            if (params.memberIdentifier == null) {
                throw new Error('Missing required parameter memberIdentifier when calling systemMembersMemberIdentifierTokensPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Member
         * @param member
         */
        public systemMembersPost (params: {  member: Member; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Member> {
            const localVarPath = this.basePath + '/system/members';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'member' is set
            if (params.member == null) {
                throw new Error('Missing required parameter member when calling systemMembersPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.member),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class MenuEntriesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Menu Entries Count
         * @param conditions
         */
        public systemMenuentriesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/menuentries/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Menu Entries
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemMenuentriesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<MenuEntry>> {
            const localVarPath = this.basePath + '/system/menuentries';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Menu Entry By Id
         * @param id
         */
        public systemMenuentriesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/menuentries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMenuentriesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Menu Entry By Id
         * @param id
         */
        public systemMenuentriesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MenuEntry> {
            const localVarPath = this.basePath + '/system/menuentries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMenuentriesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Menu Entry Image
         * @param id
         * @param lastmodified
         * @param largeFlag
         */
        public systemMenuentriesIdImageGet (params: {  id: number; lastmodified?: string; largeFlag?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/menuentries/{id}/image'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMenuentriesIdImageGet');
            }
            if (params.lastmodified !== undefined) {
                queryParameters['lastmodified'] = params.lastmodified;
            }

            if (params.largeFlag !== undefined) {
                queryParameters['largeFlag'] = params.largeFlag;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Upload Menu Entry Image
         * @param id
         * @param file File to upload
         */
        public systemMenuentriesIdImagePost (params: {  id: number; file?: any; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/menuentries/{id}/image'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            let formParams: any = {};
            headerParams['Content-Type'] = 'application/x-www-form-urlencoded';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMenuentriesIdImagePost');
            }
            formParams['file'] = params.file;

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                                body: querystring.stringify(formParams),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Menu Entry
         * @param id
         * @param operations
         */
        public systemMenuentriesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MenuEntry> {
            const localVarPath = this.basePath + '/system/menuentries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMenuentriesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemMenuentriesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Menu Entry
         * @param id
         * @param menuEntry
         */
        public systemMenuentriesIdPut (params: {  id: number; menuEntry: MenuEntry; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MenuEntry> {
            const localVarPath = this.basePath + '/system/menuentries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMenuentriesIdPut');
            }
            // verify required parameter 'menuEntry' is set
            if (params.menuEntry == null) {
                throw new Error('Missing required parameter menuEntry when calling systemMenuentriesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.menuEntry),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Menu Entry
         * @param menuEntry
         */
        public systemMenuentriesPost (params: {  menuEntry: MenuEntry; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MenuEntry> {
            const localVarPath = this.basePath + '/system/menuentries';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'menuEntry' is set
            if (params.menuEntry == null) {
                throw new Error('Missing required parameter menuEntry when calling systemMenuentriesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.menuEntry),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class MenuEntryLocationsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Menu Entry Location Count
         * @param id
         * @param conditions
         */
        public systemMenuEntriesIdLocationsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/menuEntries/{id}/locations/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMenuEntriesIdLocationsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Menu Entry Location
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemMenuEntriesIdLocationsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<MenuEntryLocation>> {
            const localVarPath = this.basePath + '/system/menuEntries/{id}/locations'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMenuEntriesIdLocationsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Menu Entry Location By Id
         * @param id
         * @param locationId
         */
        public systemMenuEntriesIdLocationsLocationIdDelete (params: {  id: number; locationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/menuEntries/{id}/locations/{locationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'locationId' + '}', String(params.locationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMenuEntriesIdLocationsLocationIdDelete');
            }
            // verify required parameter 'locationId' is set
            if (params.locationId == null) {
                throw new Error('Missing required parameter locationId when calling systemMenuEntriesIdLocationsLocationIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Menu Entry Location By Id
         * @param id
         * @param locationId
         */
        public systemMenuEntriesIdLocationsLocationIdGet (params: {  id: number; locationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MenuEntryLocation> {
            const localVarPath = this.basePath + '/system/menuEntries/{id}/locations/{locationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'locationId' + '}', String(params.locationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMenuEntriesIdLocationsLocationIdGet');
            }
            // verify required parameter 'locationId' is set
            if (params.locationId == null) {
                throw new Error('Missing required parameter locationId when calling systemMenuEntriesIdLocationsLocationIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Menu Entry Location
         * @param id
         * @param menuEntryLocation
         */
        public systemMenuEntriesIdLocationsPost (params: {  id: number; menuEntryLocation: MenuEntryLocation; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MenuEntryLocation> {
            const localVarPath = this.basePath + '/system/menuEntries/{id}/locations'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMenuEntriesIdLocationsPost');
            }
            // verify required parameter 'menuEntryLocation' is set
            if (params.menuEntryLocation == null) {
                throw new Error('Missing required parameter menuEntryLocation when calling systemMenuEntriesIdLocationsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.menuEntryLocation),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class MyCompanyPurchasingsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get My Company Purchasings Count
         * @param conditions
         */
        public systemMycompanyPurchasingCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/mycompany/purchasing/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get My Company Purchasings
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemMycompanyPurchasingGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Purchasing>> {
            const localVarPath = this.basePath + '/system/mycompany/purchasing';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get My Company Purchasing By Id
         * @param id
         */
        public systemMycompanyPurchasingIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Purchasing> {
            const localVarPath = this.basePath + '/system/mycompany/purchasing/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMycompanyPurchasingIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update My Company Purchasing
         * @param id
         * @param operations
         */
        public systemMycompanyPurchasingIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Purchasing> {
            const localVarPath = this.basePath + '/system/mycompany/purchasing/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMycompanyPurchasingIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemMycompanyPurchasingIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace My Company Purchasing
         * @param id
         * @param purchasing
         */
        public systemMycompanyPurchasingIdPut (params: {  id: number; purchasing: Purchasing; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Purchasing> {
            const localVarPath = this.basePath + '/system/mycompany/purchasing/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMycompanyPurchasingIdPut');
            }
            // verify required parameter 'purchasing' is set
            if (params.purchasing == null) {
                throw new Error('Missing required parameter purchasing when calling systemMycompanyPurchasingIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.purchasing),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class NotificationRecipientsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Notification Recipients Count
         * @param conditions
         */
        public systemNotificationRecipientsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/notificationRecipients/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Notification Recipients
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemNotificationRecipientsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<NotificationRecipient>> {
            const localVarPath = this.basePath + '/system/notificationRecipients';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Notification Recipient By Id
         * @param id
         */
        public systemNotificationRecipientsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<NotificationRecipient> {
            const localVarPath = this.basePath + '/system/notificationRecipients/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemNotificationRecipientsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class OpportunitiesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Opportunities Count
         * @param conditions
         * @param customFieldConditions
         */
        public salesOpportunitiesCountGet (params: {  conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/sales/opportunities/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.customFieldConditions !== undefined) {
                queryParameters['customFieldConditions'] = params.customFieldConditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Opportunities
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public salesOpportunitiesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Opportunity>> {
            const localVarPath = this.basePath + '/sales/opportunities';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Convert Opportunity To Agreement
         * @param id
         * @param conversion
         */
        public salesOpportunitiesIdConvertToAgreementPost (params: {  id: number; conversion: OpportunityToAgreementConversion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Agreement> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/convertToAgreement'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdConvertToAgreementPost');
            }
            // verify required parameter 'conversion' is set
            if (params.conversion == null) {
                throw new Error('Missing required parameter conversion when calling salesOpportunitiesIdConvertToAgreementPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.conversion),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Convert Opportunity To Project
         * @param id
         * @param conversion
         */
        public salesOpportunitiesIdConvertToProjectPost (params: {  id: number; conversion: OpportunityToProjectConversion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Project> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/convertToProject'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdConvertToProjectPost');
            }
            // verify required parameter 'conversion' is set
            if (params.conversion == null) {
                throw new Error('Missing required parameter conversion when calling salesOpportunitiesIdConvertToProjectPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.conversion),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Convert Opportunity To Sales Order
         * @param id
         * @param conversion
         */
        public salesOpportunitiesIdConvertToSalesOrderPost (params: {  id: number; conversion: OpportunityToSalesOrderConversion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Order> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/convertToSalesOrder'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdConvertToSalesOrderPost');
            }
            // verify required parameter 'conversion' is set
            if (params.conversion == null) {
                throw new Error('Missing required parameter conversion when calling salesOpportunitiesIdConvertToSalesOrderPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.conversion),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Convert Opportunity To Service Ticket
         * @param id
         * @param conversion
         */
        public salesOpportunitiesIdConvertToServiceTicketPost (params: {  id: number; conversion: OpportunityToServiceTicketConversion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Ticket> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/convertToServiceTicket'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdConvertToServiceTicketPost');
            }
            // verify required parameter 'conversion' is set
            if (params.conversion == null) {
                throw new Error('Missing required parameter conversion when calling salesOpportunitiesIdConvertToServiceTicketPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.conversion),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Opportunity By Id
         * @param id
         */
        public salesOpportunitiesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Opportunity By Id
         * @param id
         */
        public salesOpportunitiesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Opportunity> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Opportunity
         * @param id
         * @param operations
         */
        public salesOpportunitiesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Opportunity> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling salesOpportunitiesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Opportunity
         * @param id
         * @param opportunity
         */
        public salesOpportunitiesIdPut (params: {  id: number; opportunity: Opportunity; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Opportunity> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdPut');
            }
            // verify required parameter 'opportunity' is set
            if (params.opportunity == null) {
                throw new Error('Missing required parameter opportunity when calling salesOpportunitiesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.opportunity),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Opportunity
         * @param opportunity
         */
        public salesOpportunitiesPost (params: {  opportunity: Opportunity; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Opportunity> {
            const localVarPath = this.basePath + '/sales/opportunities';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'opportunity' is set
            if (params.opportunity == null) {
                throw new Error('Missing required parameter opportunity when calling salesOpportunitiesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.opportunity),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class OpportunityContactsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Delete Opportunity Contact By Id
         * @param id
         * @param contactId
         */
        public salesOpportunitiesIdContactsContactIdDelete (params: {  id: number; contactId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/contacts/{contactId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'contactId' + '}', String(params.contactId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdContactsContactIdDelete');
            }
            // verify required parameter 'contactId' is set
            if (params.contactId == null) {
                throw new Error('Missing required parameter contactId when calling salesOpportunitiesIdContactsContactIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Opportunity Contact By Id
         * @param id
         * @param contactId
         */
        public salesOpportunitiesIdContactsContactIdGet (params: {  id: number; contactId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityContact> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/contacts/{contactId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'contactId' + '}', String(params.contactId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdContactsContactIdGet');
            }
            // verify required parameter 'contactId' is set
            if (params.contactId == null) {
                throw new Error('Missing required parameter contactId when calling salesOpportunitiesIdContactsContactIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Opportunity Contact
         * @param id
         * @param contactId
         * @param operations
         */
        public salesOpportunitiesIdContactsContactIdPatch (params: {  id: number; contactId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityContact> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/contacts/{contactId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'contactId' + '}', String(params.contactId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdContactsContactIdPatch');
            }
            // verify required parameter 'contactId' is set
            if (params.contactId == null) {
                throw new Error('Missing required parameter contactId when calling salesOpportunitiesIdContactsContactIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling salesOpportunitiesIdContactsContactIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Opportunity Contact
         * @param id
         * @param contactId
         * @param opportunityContact
         */
        public salesOpportunitiesIdContactsContactIdPut (params: {  id: number; contactId: number; opportunityContact: OpportunityContact; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityContact> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/contacts/{contactId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'contactId' + '}', String(params.contactId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdContactsContactIdPut');
            }
            // verify required parameter 'contactId' is set
            if (params.contactId == null) {
                throw new Error('Missing required parameter contactId when calling salesOpportunitiesIdContactsContactIdPut');
            }
            // verify required parameter 'opportunityContact' is set
            if (params.opportunityContact == null) {
                throw new Error('Missing required parameter opportunityContact when calling salesOpportunitiesIdContactsContactIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.opportunityContact),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Opportunity Contacts Count
         * @param id
         * @param conditions
         */
        public salesOpportunitiesIdContactsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/contacts/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdContactsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Opportunity Contacts
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public salesOpportunitiesIdContactsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<OpportunityContact>> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/contacts'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdContactsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Opportunity Contact
         * @param id
         * @param opportunityContact
         */
        public salesOpportunitiesIdContactsPost (params: {  id: number; opportunityContact: OpportunityContact; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityContact> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/contacts'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdContactsPost');
            }
            // verify required parameter 'opportunityContact' is set
            if (params.opportunityContact == null) {
                throw new Error('Missing required parameter opportunityContact when calling salesOpportunitiesIdContactsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.opportunityContact),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class OpportunityForecastsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Forecasts Count
         * @param id
         * @param conditions
         */
        public salesOpportunitiesIdForecastCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/forecast/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdForecastCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Forecast By Id
         * @param id
         * @param forecastId
         */
        public salesOpportunitiesIdForecastForecastIdDelete (params: {  id: number; forecastId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/forecast/{forecastId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'forecastId' + '}', String(params.forecastId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdForecastForecastIdDelete');
            }
            // verify required parameter 'forecastId' is set
            if (params.forecastId == null) {
                throw new Error('Missing required parameter forecastId when calling salesOpportunitiesIdForecastForecastIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Forecast By Id
         * @param id
         * @param forecastId
         */
        public salesOpportunitiesIdForecastForecastIdGet (params: {  id: number; forecastId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Forecast> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/forecast/{forecastId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'forecastId' + '}', String(params.forecastId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdForecastForecastIdGet');
            }
            // verify required parameter 'forecastId' is set
            if (params.forecastId == null) {
                throw new Error('Missing required parameter forecastId when calling salesOpportunitiesIdForecastForecastIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Forecast
         * @param id
         * @param forecastId
         * @param operations
         */
        public salesOpportunitiesIdForecastForecastIdPatch (params: {  id: number; forecastId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Forecast> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/forecast/{forecastId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'forecastId' + '}', String(params.forecastId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdForecastForecastIdPatch');
            }
            // verify required parameter 'forecastId' is set
            if (params.forecastId == null) {
                throw new Error('Missing required parameter forecastId when calling salesOpportunitiesIdForecastForecastIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling salesOpportunitiesIdForecastForecastIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Forecast
         * @param id
         * @param forecastId
         * @param forecast
         */
        public salesOpportunitiesIdForecastForecastIdPut (params: {  id: number; forecastId: number; forecast: Forecast; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Forecast> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/forecast/{forecastId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'forecastId' + '}', String(params.forecastId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdForecastForecastIdPut');
            }
            // verify required parameter 'forecastId' is set
            if (params.forecastId == null) {
                throw new Error('Missing required parameter forecastId when calling salesOpportunitiesIdForecastForecastIdPut');
            }
            // verify required parameter 'forecast' is set
            if (params.forecast == null) {
                throw new Error('Missing required parameter forecast when calling salesOpportunitiesIdForecastForecastIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.forecast),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Forecasts
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public salesOpportunitiesIdForecastGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Forecast>> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/forecast'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdForecastGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Forecast
         * @param id
         * @param forecast
         */
        public salesOpportunitiesIdForecastPost (params: {  id: number; forecast: Forecast; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Forecast> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/forecast'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdForecastPost');
            }
            // verify required parameter 'forecast' is set
            if (params.forecast == null) {
                throw new Error('Missing required parameter forecast when calling salesOpportunitiesIdForecastPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.forecast),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class OpportunityNotesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Opportunity Notes Count
         * @param id
         * @param conditions
         */
        public salesOpportunitiesIdNotesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<OpportunityNote>> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/notes/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdNotesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Opportunity Notes
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public salesOpportunitiesIdNotesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<OpportunityNote>> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/notes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdNotesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Opportunity Note By Id
         * @param id
         * @param noteId
         */
        public salesOpportunitiesIdNotesNoteIdDelete (params: {  id: number; noteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdNotesNoteIdDelete');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling salesOpportunitiesIdNotesNoteIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Opportunity Note By Id
         * @param id
         * @param noteId
         */
        public salesOpportunitiesIdNotesNoteIdGet (params: {  id: number; noteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityNote> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdNotesNoteIdGet');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling salesOpportunitiesIdNotesNoteIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Opportunity Note
         * @param id
         * @param noteId
         * @param operations
         */
        public salesOpportunitiesIdNotesNoteIdPatch (params: {  id: number; noteId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityNote> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdNotesNoteIdPatch');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling salesOpportunitiesIdNotesNoteIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling salesOpportunitiesIdNotesNoteIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Opportunity Note
         * @param id
         * @param noteId
         * @param note
         */
        public salesOpportunitiesIdNotesNoteIdPut (params: {  id: number; noteId: number; note: OpportunityNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityNote> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdNotesNoteIdPut');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling salesOpportunitiesIdNotesNoteIdPut');
            }
            // verify required parameter 'note' is set
            if (params.note == null) {
                throw new Error('Missing required parameter note when calling salesOpportunitiesIdNotesNoteIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.note),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Opportunity Note
         * @param id
         * @param note
         */
        public salesOpportunitiesIdNotesPost (params: {  id: number; note: OpportunityNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityNote> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/notes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdNotesPost');
            }
            // verify required parameter 'note' is set
            if (params.note == null) {
                throw new Error('Missing required parameter note when calling salesOpportunitiesIdNotesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.note),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class OpportunityRatingsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Opportunity Ratings Count
         * @param conditions
         */
        public salesOpportunitiesRatingsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/sales/opportunities/ratings/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Opportunity Ratings
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public salesOpportunitiesRatingsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<OpportunityRating>> {
            const localVarPath = this.basePath + '/sales/opportunities/ratings';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Opportunity Rating By Id
         * @param id
         */
        public salesOpportunitiesRatingsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/sales/opportunities/ratings/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesRatingsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Opportunity Rating By Id
         * @param id
         */
        public salesOpportunitiesRatingsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityRating> {
            const localVarPath = this.basePath + '/sales/opportunities/ratings/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesRatingsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Opportunity Rating
         * @param id
         * @param operations
         */
        public salesOpportunitiesRatingsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityRating> {
            const localVarPath = this.basePath + '/sales/opportunities/ratings/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesRatingsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling salesOpportunitiesRatingsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Opportunity Rating
         * @param id
         * @param opportunityRating
         */
        public salesOpportunitiesRatingsIdPut (params: {  id: number; opportunityRating: OpportunityRating; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityRating> {
            const localVarPath = this.basePath + '/sales/opportunities/ratings/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesRatingsIdPut');
            }
            // verify required parameter 'opportunityRating' is set
            if (params.opportunityRating == null) {
                throw new Error('Missing required parameter opportunityRating when calling salesOpportunitiesRatingsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.opportunityRating),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Opportunity Rating
         * @param opportunityRating
         */
        public salesOpportunitiesRatingsPost (params: {  opportunityRating: OpportunityRating; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityRating> {
            const localVarPath = this.basePath + '/sales/opportunities/ratings';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'opportunityRating' is set
            if (params.opportunityRating == null) {
                throw new Error('Missing required parameter opportunityRating when calling salesOpportunitiesRatingsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.opportunityRating),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class OpportunityStagesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Stage Count
         * @param conditions
         */
        public salesStagesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/sales/stages/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Stage
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public salesStagesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<OpportunityStage>> {
            const localVarPath = this.basePath + '/sales/stages';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Stage By Id
         * @param id
         */
        public salesStagesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/sales/stages/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesStagesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Stage By Id
         * @param id
         */
        public salesStagesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityStage> {
            const localVarPath = this.basePath + '/sales/stages/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesStagesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Stage
         * @param id
         * @param operations
         */
        public salesStagesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityStage> {
            const localVarPath = this.basePath + '/sales/stages/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesStagesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling salesStagesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Stage
         * @param id
         * @param stage
         */
        public salesStagesIdPut (params: {  id: number; stage: OpportunityStage; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityStage> {
            const localVarPath = this.basePath + '/sales/stages/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesStagesIdPut');
            }
            // verify required parameter 'stage' is set
            if (params.stage == null) {
                throw new Error('Missing required parameter stage when calling salesStagesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.stage),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Stage
         * @param stage
         */
        public salesStagesPost (params: {  stage: OpportunityStage; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityStage> {
            const localVarPath = this.basePath + '/sales/stages';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'stage' is set
            if (params.stage == null) {
                throw new Error('Missing required parameter stage when calling salesStagesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.stage),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class OpportunityStatusesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Statuses Count
         * @param conditions
         */
        public salesOpportunitiesStatusesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/sales/opportunities/statuses/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Statuses
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public salesOpportunitiesStatusesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<OpportunityStatus>> {
            const localVarPath = this.basePath + '/sales/opportunities/statuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Status By Id
         * @param id
         */
        public salesOpportunitiesStatusesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/sales/opportunities/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesStatusesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Status By Id
         * @param id
         */
        public salesOpportunitiesStatusesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityStatus> {
            const localVarPath = this.basePath + '/sales/opportunities/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesStatusesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Status
         * @param id
         * @param operations
         */
        public salesOpportunitiesStatusesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityStatus> {
            const localVarPath = this.basePath + '/sales/opportunities/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesStatusesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling salesOpportunitiesStatusesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Status
         * @param id
         * @param status
         */
        public salesOpportunitiesStatusesIdPut (params: {  id: number; status: OpportunityStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityStatus> {
            const localVarPath = this.basePath + '/sales/opportunities/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesStatusesIdPut');
            }
            // verify required parameter 'status' is set
            if (params.status == null) {
                throw new Error('Missing required parameter status when calling salesOpportunitiesStatusesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.status),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Status
         * @param status
         */
        public salesOpportunitiesStatusesPost (params: {  status: OpportunityStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityStatus> {
            const localVarPath = this.basePath + '/sales/opportunities/statuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'status' is set
            if (params.status == null) {
                throw new Error('Missing required parameter status when calling salesOpportunitiesStatusesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.status),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class OpportunityTeamsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Teams Count
         * @param id
         * @param conditions
         */
        public salesOpportunitiesIdTeamCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/team/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdTeamCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Teams
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public salesOpportunitiesIdTeamGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Team>> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/team'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdTeamGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Team
         * @param id
         * @param team
         */
        public salesOpportunitiesIdTeamPost (params: {  id: number; team: Team; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Team> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/team'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdTeamPost');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling salesOpportunitiesIdTeamPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.team),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Team By Id
         * @param id
         * @param teamId
         */
        public salesOpportunitiesIdTeamTeamIdDelete (params: {  id: number; teamId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/team/{teamId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'teamId' + '}', String(params.teamId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdTeamTeamIdDelete');
            }
            // verify required parameter 'teamId' is set
            if (params.teamId == null) {
                throw new Error('Missing required parameter teamId when calling salesOpportunitiesIdTeamTeamIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Team By Id
         * @param id
         * @param teamId
         */
        public salesOpportunitiesIdTeamTeamIdGet (params: {  id: number; teamId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Team> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/team/{teamId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'teamId' + '}', String(params.teamId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdTeamTeamIdGet');
            }
            // verify required parameter 'teamId' is set
            if (params.teamId == null) {
                throw new Error('Missing required parameter teamId when calling salesOpportunitiesIdTeamTeamIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Team
         * @param id
         * @param teamId
         * @param operations
         */
        public salesOpportunitiesIdTeamTeamIdPatch (params: {  id: number; teamId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Team> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/team/{teamId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'teamId' + '}', String(params.teamId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdTeamTeamIdPatch');
            }
            // verify required parameter 'teamId' is set
            if (params.teamId == null) {
                throw new Error('Missing required parameter teamId when calling salesOpportunitiesIdTeamTeamIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling salesOpportunitiesIdTeamTeamIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Team
         * @param id
         * @param teamId
         * @param team
         */
        public salesOpportunitiesIdTeamTeamIdPut (params: {  id: number; teamId: number; team: Team; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Team> {
            const localVarPath = this.basePath + '/sales/opportunities/{id}/team/{teamId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'teamId' + '}', String(params.teamId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesIdTeamTeamIdPut');
            }
            // verify required parameter 'teamId' is set
            if (params.teamId == null) {
                throw new Error('Missing required parameter teamId when calling salesOpportunitiesIdTeamTeamIdPut');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling salesOpportunitiesIdTeamTeamIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.team),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class OpportunityTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Opportunity Types Count
         * @param conditions
         */
        public salesOpportunitiesTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/sales/opportunities/types/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Opportunity Types
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public salesOpportunitiesTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<OpportunityType>> {
            const localVarPath = this.basePath + '/sales/opportunities/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Opportunity Type By Id
         * @param id
         */
        public salesOpportunitiesTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/sales/opportunities/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesTypesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Opportunity Type By Id
         * @param id
         */
        public salesOpportunitiesTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityType> {
            const localVarPath = this.basePath + '/sales/opportunities/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesTypesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Opportunity Type
         * @param id
         * @param operations
         */
        public salesOpportunitiesTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityType> {
            const localVarPath = this.basePath + '/sales/opportunities/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesTypesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling salesOpportunitiesTypesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Opportunity Type
         * @param id
         * @param opportunityType
         */
        public salesOpportunitiesTypesIdPut (params: {  id: number; opportunityType: OpportunityType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityType> {
            const localVarPath = this.basePath + '/sales/opportunities/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOpportunitiesTypesIdPut');
            }
            // verify required parameter 'opportunityType' is set
            if (params.opportunityType == null) {
                throw new Error('Missing required parameter opportunityType when calling salesOpportunitiesTypesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.opportunityType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Opportunity Type
         * @param opportunityType
         */
        public salesOpportunitiesTypesPost (params: {  opportunityType: OpportunityType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityType> {
            const localVarPath = this.basePath + '/sales/opportunities/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'opportunityType' is set
            if (params.opportunityType == null) {
                throw new Error('Missing required parameter opportunityType when calling salesOpportunitiesTypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.opportunityType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class OrderStatusNotificationsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Order Status Notifications Count
         * @param id
         * @param conditions
         */
        public salesOrdersStatusesIdNotificationsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/sales/orders/statuses/{id}/notifications/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOrdersStatusesIdNotificationsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Order Status Notifications
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public salesOrdersStatusesIdNotificationsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<OrderStatusNotification>> {
            const localVarPath = this.basePath + '/sales/orders/statuses/{id}/notifications'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOrdersStatusesIdNotificationsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Order Status Notification By Id
         * @param id
         * @param notificationId
         */
        public salesOrdersStatusesIdNotificationsNotificationIdDelete (params: {  id: number; notificationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/sales/orders/statuses/{id}/notifications/{notificationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'notificationId' + '}', String(params.notificationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOrdersStatusesIdNotificationsNotificationIdDelete');
            }
            // verify required parameter 'notificationId' is set
            if (params.notificationId == null) {
                throw new Error('Missing required parameter notificationId when calling salesOrdersStatusesIdNotificationsNotificationIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Order Status Notification By Id
         * @param id
         * @param notificationId
         */
        public salesOrdersStatusesIdNotificationsNotificationIdGet (params: {  id: number; notificationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OrderStatusNotification> {
            const localVarPath = this.basePath + '/sales/orders/statuses/{id}/notifications/{notificationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'notificationId' + '}', String(params.notificationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOrdersStatusesIdNotificationsNotificationIdGet');
            }
            // verify required parameter 'notificationId' is set
            if (params.notificationId == null) {
                throw new Error('Missing required parameter notificationId when calling salesOrdersStatusesIdNotificationsNotificationIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Order Status Notification
         * @param id
         * @param notificationId
         * @param operations
         */
        public salesOrdersStatusesIdNotificationsNotificationIdPatch (params: {  id: number; notificationId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OrderStatusNotification> {
            const localVarPath = this.basePath + '/sales/orders/statuses/{id}/notifications/{notificationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'notificationId' + '}', String(params.notificationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOrdersStatusesIdNotificationsNotificationIdPatch');
            }
            // verify required parameter 'notificationId' is set
            if (params.notificationId == null) {
                throw new Error('Missing required parameter notificationId when calling salesOrdersStatusesIdNotificationsNotificationIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling salesOrdersStatusesIdNotificationsNotificationIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Order Status Notification
         * @param id
         * @param notificationId
         * @param orderStatusNotification
         */
        public salesOrdersStatusesIdNotificationsNotificationIdPut (params: {  id: number; notificationId: number; orderStatusNotification: OrderStatusNotification; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OrderStatusNotification> {
            const localVarPath = this.basePath + '/sales/orders/statuses/{id}/notifications/{notificationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'notificationId' + '}', String(params.notificationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOrdersStatusesIdNotificationsNotificationIdPut');
            }
            // verify required parameter 'notificationId' is set
            if (params.notificationId == null) {
                throw new Error('Missing required parameter notificationId when calling salesOrdersStatusesIdNotificationsNotificationIdPut');
            }
            // verify required parameter 'orderStatusNotification' is set
            if (params.orderStatusNotification == null) {
                throw new Error('Missing required parameter orderStatusNotification when calling salesOrdersStatusesIdNotificationsNotificationIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.orderStatusNotification),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Order Status Notification
         * @param id
         * @param orderStatusNotification
         */
        public salesOrdersStatusesIdNotificationsPost (params: {  id: number; orderStatusNotification: OrderStatusNotification; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OrderStatusNotification> {
            const localVarPath = this.basePath + '/sales/orders/statuses/{id}/notifications'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOrdersStatusesIdNotificationsPost');
            }
            // verify required parameter 'orderStatusNotification' is set
            if (params.orderStatusNotification == null) {
                throw new Error('Missing required parameter orderStatusNotification when calling salesOrdersStatusesIdNotificationsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.orderStatusNotification),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class OrderStatusesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Order Statuses Count
         * @param conditions
         */
        public salesOrdersStatusesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/sales/orders/statuses/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Order Statuses
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public salesOrdersStatusesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<OrderStatus>> {
            const localVarPath = this.basePath + '/sales/orders/statuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Order Status By Id
         * @param id
         */
        public salesOrdersStatusesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/sales/orders/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOrdersStatusesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Order Status By Id
         * @param id
         */
        public salesOrdersStatusesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OrderStatus> {
            const localVarPath = this.basePath + '/sales/orders/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOrdersStatusesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Order Status
         * @param id
         * @param operations
         */
        public salesOrdersStatusesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OrderStatus> {
            const localVarPath = this.basePath + '/sales/orders/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOrdersStatusesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling salesOrdersStatusesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Order Status
         * @param id
         * @param status
         */
        public salesOrdersStatusesIdPut (params: {  id: number; status: OrderStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OrderStatus> {
            const localVarPath = this.basePath + '/sales/orders/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOrdersStatusesIdPut');
            }
            // verify required parameter 'status' is set
            if (params.status == null) {
                throw new Error('Missing required parameter status when calling salesOrdersStatusesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.status),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Order Status
         * @param status
         */
        public salesOrdersStatusesPost (params: {  status: OrderStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<OrderStatus>> {
            const localVarPath = this.basePath + '/sales/orders/statuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'status' is set
            if (params.status == null) {
                throw new Error('Missing required parameter status when calling salesOrdersStatusesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.status),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class OrderStatusesEmailTemplateApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Order Status Email Template Count
         * @param orderStatus
         * @param conditions
         */
        public salesOrdersStatusesIdEmailtemplatesCountGet (params: {  orderStatus: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/sales/orders/statuses/{id}/emailtemplates/count'
                .replace('{' + 'OrderStatus' + '}', String(params.orderStatus));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'orderStatus' is set
            if (params.orderStatus == null) {
                throw new Error('Missing required parameter orderStatus when calling salesOrdersStatusesIdEmailtemplatesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Order Status Email Template By Id
         * @param id
         * @param emailTemplateId
         */
        public salesOrdersStatusesIdEmailtemplatesEmailTemplateIdDelete (params: {  id: number; emailTemplateId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/sales/orders/statuses/{id}/emailtemplates/{emailTemplateId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'emailTemplateId' + '}', String(params.emailTemplateId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOrdersStatusesIdEmailtemplatesEmailTemplateIdDelete');
            }
            // verify required parameter 'emailTemplateId' is set
            if (params.emailTemplateId == null) {
                throw new Error('Missing required parameter emailTemplateId when calling salesOrdersStatusesIdEmailtemplatesEmailTemplateIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Order Status Email Template By Id
         * @param id
         * @param emailTemplateId
         */
        public salesOrdersStatusesIdEmailtemplatesEmailTemplateIdGet (params: {  id: number; emailTemplateId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OrderStatusEmailTemplate> {
            const localVarPath = this.basePath + '/sales/orders/statuses/{id}/emailtemplates/{emailTemplateId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'emailTemplateId' + '}', String(params.emailTemplateId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOrdersStatusesIdEmailtemplatesEmailTemplateIdGet');
            }
            // verify required parameter 'emailTemplateId' is set
            if (params.emailTemplateId == null) {
                throw new Error('Missing required parameter emailTemplateId when calling salesOrdersStatusesIdEmailtemplatesEmailTemplateIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Order Status Email Template
         * @param id
         * @param emailTemplateId
         * @param operations
         */
        public salesOrdersStatusesIdEmailtemplatesEmailTemplateIdPatch (params: {  id: number; emailTemplateId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OrderStatusEmailTemplate> {
            const localVarPath = this.basePath + '/sales/orders/statuses/{id}/emailtemplates/{emailTemplateId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'emailTemplateId' + '}', String(params.emailTemplateId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOrdersStatusesIdEmailtemplatesEmailTemplateIdPatch');
            }
            // verify required parameter 'emailTemplateId' is set
            if (params.emailTemplateId == null) {
                throw new Error('Missing required parameter emailTemplateId when calling salesOrdersStatusesIdEmailtemplatesEmailTemplateIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling salesOrdersStatusesIdEmailtemplatesEmailTemplateIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Order Status Email Template
         * @param id
         * @param emailTemplateId
         * @param orderStatusEmailTemplate
         */
        public salesOrdersStatusesIdEmailtemplatesEmailTemplateIdPut (params: {  id: number; emailTemplateId: number; orderStatusEmailTemplate: OrderStatusEmailTemplate; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OrderStatusEmailTemplate> {
            const localVarPath = this.basePath + '/sales/orders/statuses/{id}/emailtemplates/{emailTemplateId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'emailTemplateId' + '}', String(params.emailTemplateId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOrdersStatusesIdEmailtemplatesEmailTemplateIdPut');
            }
            // verify required parameter 'emailTemplateId' is set
            if (params.emailTemplateId == null) {
                throw new Error('Missing required parameter emailTemplateId when calling salesOrdersStatusesIdEmailtemplatesEmailTemplateIdPut');
            }
            // verify required parameter 'orderStatusEmailTemplate' is set
            if (params.orderStatusEmailTemplate == null) {
                throw new Error('Missing required parameter orderStatusEmailTemplate when calling salesOrdersStatusesIdEmailtemplatesEmailTemplateIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.orderStatusEmailTemplate),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Order Status Email Template
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public salesOrdersStatusesIdEmailtemplatesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<OrderStatusEmailTemplate>> {
            const localVarPath = this.basePath + '/sales/orders/statuses/{id}/emailtemplates'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOrdersStatusesIdEmailtemplatesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Order Status Email Template
         * @param id
         * @param orderStatusEmailTemplate
         */
        public salesOrdersStatusesIdEmailtemplatesPost (params: {  id: number; orderStatusEmailTemplate: OrderStatusEmailTemplate; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OrderStatusEmailTemplate> {
            const localVarPath = this.basePath + '/sales/orders/statuses/{id}/emailtemplates'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOrdersStatusesIdEmailtemplatesPost');
            }
            // verify required parameter 'orderStatusEmailTemplate' is set
            if (params.orderStatusEmailTemplate == null) {
                throw new Error('Missing required parameter orderStatusEmailTemplate when calling salesOrdersStatusesIdEmailtemplatesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.orderStatusEmailTemplate),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class OrdersApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Sales Orders Count
         * @param conditions
         * @param customFieldConditions
         */
        public salesOrdersCountGet (params: {  conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/sales/orders/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.customFieldConditions !== undefined) {
                queryParameters['customFieldConditions'] = params.customFieldConditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Sales Orders
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public salesOrdersGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Order>> {
            const localVarPath = this.basePath + '/sales/orders';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Sales Order By Id
         * @param id
         */
        public salesOrdersIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/sales/orders/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOrdersIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Sales Order By Id
         * @param id
         */
        public salesOrdersIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Order> {
            const localVarPath = this.basePath + '/sales/orders/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOrdersIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Sales Order
         * @param id
         * @param operations
         */
        public salesOrdersIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Order> {
            const localVarPath = this.basePath + '/sales/orders/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOrdersIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling salesOrdersIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Sales Order
         * @param id
         * @param order
         */
        public salesOrdersIdPut (params: {  id: number; order: Order; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Order> {
            const localVarPath = this.basePath + '/sales/orders/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesOrdersIdPut');
            }
            // verify required parameter 'order' is set
            if (params.order == null) {
                throw new Error('Missing required parameter order when calling salesOrdersIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.order),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Sales Order
         * @param order
         */
        public salesOrdersPost (params: {  order: Order; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Order>> {
            const localVarPath = this.basePath + '/sales/orders';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'order' is set
            if (params.order == null) {
                throw new Error('Missing required parameter order when calling salesOrdersPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.order),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class OthersApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Others Count
         * @param conditions
         */
        public systemMyCompanyOtherCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/myCompany/other/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Others
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemMyCompanyOtherGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Other>> {
            const localVarPath = this.basePath + '/system/myCompany/other';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Other By Id
         * @param id
         */
        public systemMyCompanyOtherIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Other> {
            const localVarPath = this.basePath + '/system/myCompany/other/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMyCompanyOtherIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Other
         * @param id
         * @param operations
         */
        public systemMyCompanyOtherIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Other> {
            const localVarPath = this.basePath + '/system/myCompany/other/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMyCompanyOtherIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemMyCompanyOtherIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Other
         * @param id
         * @param other
         */
        public systemMyCompanyOtherIdPut (params: {  id: number; other: Other; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Other> {
            const localVarPath = this.basePath + '/system/myCompany/other/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMyCompanyOtherIdPut');
            }
            // verify required parameter 'other' is set
            if (params.other == null) {
                throw new Error('Missing required parameter other when calling systemMyCompanyOtherIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.other),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class OwnershipTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Ownership Type Count
         * @param conditions
         */
        public companyOwnershipTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/ownershipTypes/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Ownership Type
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyOwnershipTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<OwnershipType>> {
            const localVarPath = this.basePath + '/company/ownershipTypes';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Ownership Type By Id
         * @param id
         */
        public companyOwnershipTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/ownershipTypes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyOwnershipTypesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Ownership Type By Id
         * @param id
         */
        public companyOwnershipTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OwnershipType> {
            const localVarPath = this.basePath + '/company/ownershipTypes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyOwnershipTypesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Ownership Type
         * @param id
         * @param operations
         */
        public companyOwnershipTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OwnershipType> {
            const localVarPath = this.basePath + '/company/ownershipTypes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyOwnershipTypesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyOwnershipTypesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Ownership Type
         * @param id
         * @param ownershipType
         */
        public companyOwnershipTypesIdPut (params: {  id: number; ownershipType: OwnershipType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OwnershipType> {
            const localVarPath = this.basePath + '/company/ownershipTypes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyOwnershipTypesIdPut');
            }
            // verify required parameter 'ownershipType' is set
            if (params.ownershipType == null) {
                throw new Error('Missing required parameter ownershipType when calling companyOwnershipTypesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.ownershipType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Ownership Type
         * @param ownershipType
         */
        public companyOwnershipTypesPost (params: {  ownershipType: OwnershipType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OwnershipType> {
            const localVarPath = this.basePath + '/company/ownershipTypes';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'ownershipType' is set
            if (params.ownershipType == null) {
                throw new Error('Missing required parameter ownershipType when calling companyOwnershipTypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.ownershipType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ParsingTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Parsing Type Count
         * @param conditions
         */
        public systemParsingTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/parsingTypes/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Parsing Parsing Types
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemParsingTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ParsingType>> {
            const localVarPath = this.basePath + '/system/parsingTypes';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Parsing Type By Id
         * @param id
         */
        public systemParsingTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ParsingType> {
            const localVarPath = this.basePath + '/system/parsingTypes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemParsingTypesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ParsingVariablesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Parsing Variable Count
         * @param conditions
         */
        public systemParsingVariablesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/parsingVariables/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Parsing Variables
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemParsingVariablesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ParsingVariable>> {
            const localVarPath = this.basePath + '/system/parsingVariables';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Parsing Variable By Id
         * @param id
         */
        public systemParsingVariablesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ParsingVariable> {
            const localVarPath = this.basePath + '/system/parsingVariables/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemParsingVariablesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PaymentTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Payment Type Count
         * @param conditions
         */
        public expensePaymentTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/expense/paymentTypes/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Payment Type
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public expensePaymentTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<PaymentType>> {
            const localVarPath = this.basePath + '/expense/paymentTypes';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Payment Type By Id
         * @param id
         */
        public expensePaymentTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/expense/paymentTypes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling expensePaymentTypesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Payment Type By Id
         * @param id
         */
        public expensePaymentTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PaymentType> {
            const localVarPath = this.basePath + '/expense/paymentTypes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling expensePaymentTypesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Payment Type
         * @param id
         * @param operations
         */
        public expensePaymentTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PaymentType> {
            const localVarPath = this.basePath + '/expense/paymentTypes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling expensePaymentTypesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling expensePaymentTypesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Payment Type
         * @param id
         * @param paymentType
         */
        public expensePaymentTypesIdPut (params: {  id: number; paymentType: PaymentType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PaymentType> {
            const localVarPath = this.basePath + '/expense/paymentTypes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling expensePaymentTypesIdPut');
            }
            // verify required parameter 'paymentType' is set
            if (params.paymentType == null) {
                throw new Error('Missing required parameter paymentType when calling expensePaymentTypesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.paymentType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Payment Type
         * @param paymentType
         */
        public expensePaymentTypesPost (params: {  paymentType: PaymentType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PaymentType> {
            const localVarPath = this.basePath + '/expense/paymentTypes';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'paymentType' is set
            if (params.paymentType == null) {
                throw new Error('Missing required parameter paymentType when calling expensePaymentTypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.paymentType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PortalCalendarsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Portal Calendars Count
         * @param conditions
         */
        public systemMycompanyPortalcalendarsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/mycompany/portalcalendars/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Portal Calendars
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemMycompanyPortalcalendarsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<PortalCalendar>> {
            const localVarPath = this.basePath + '/system/mycompany/portalcalendars';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Portal Calendar By Id
         * @param id
         */
        public systemMycompanyPortalcalendarsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PortalCalendar> {
            const localVarPath = this.basePath + '/system/mycompany/portalcalendars/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMycompanyPortalcalendarsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Portal Calendar
         * @param id
         * @param operations
         */
        public systemMycompanyPortalcalendarsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PortalCalendar> {
            const localVarPath = this.basePath + '/system/mycompany/portalcalendars/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMycompanyPortalcalendarsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemMycompanyPortalcalendarsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Portal Calendar
         * @param id
         * @param portalCalendar
         */
        public systemMycompanyPortalcalendarsIdPut (params: {  id: number; portalCalendar: PortalCalendar; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PortalCalendar> {
            const localVarPath = this.basePath + '/system/mycompany/portalcalendars/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMycompanyPortalcalendarsIdPut');
            }
            // verify required parameter 'portalCalendar' is set
            if (params.portalCalendar == null) {
                throw new Error('Missing required parameter portalCalendar when calling systemMycompanyPortalcalendarsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.portalCalendar),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PortalConfigurationInvoiceSetupsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Portal Configuration Invoice Setup Count
         * @param id
         * @param conditions
         */
        public systemPortalConfigurationsIdInvoiceSetupsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/portalConfigurations/{id}/invoiceSetups/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalConfigurationsIdInvoiceSetupsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Portal Configuration Invoice Setup
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemPortalConfigurationsIdInvoiceSetupsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<PortalConfigurationInvoiceSetup>> {
            const localVarPath = this.basePath + '/system/portalConfigurations/{id}/invoiceSetups'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalConfigurationsIdInvoiceSetupsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Portal Configuration Invoice Setup By Id
         * @param id
         * @param invoiceSetupId
         */
        public systemPortalConfigurationsIdInvoiceSetupsInvoiceSetupIdGet (params: {  id: number; invoiceSetupId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PortalConfigurationInvoiceSetup> {
            const localVarPath = this.basePath + '/system/portalConfigurations/{id}/invoiceSetups/{invoiceSetupId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'invoiceSetupId' + '}', String(params.invoiceSetupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalConfigurationsIdInvoiceSetupsInvoiceSetupIdGet');
            }
            // verify required parameter 'invoiceSetupId' is set
            if (params.invoiceSetupId == null) {
                throw new Error('Missing required parameter invoiceSetupId when calling systemPortalConfigurationsIdInvoiceSetupsInvoiceSetupIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Portal Configuration Invoice Setup
         * @param id
         * @param invoiceSetupId
         * @param operations
         */
        public systemPortalConfigurationsIdInvoiceSetupsInvoiceSetupIdPatch (params: {  id: number; invoiceSetupId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PortalConfigurationInvoiceSetup> {
            const localVarPath = this.basePath + '/system/portalConfigurations/{id}/invoiceSetups/{invoiceSetupId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'invoiceSetupId' + '}', String(params.invoiceSetupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalConfigurationsIdInvoiceSetupsInvoiceSetupIdPatch');
            }
            // verify required parameter 'invoiceSetupId' is set
            if (params.invoiceSetupId == null) {
                throw new Error('Missing required parameter invoiceSetupId when calling systemPortalConfigurationsIdInvoiceSetupsInvoiceSetupIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemPortalConfigurationsIdInvoiceSetupsInvoiceSetupIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Portal Configuration Invoice Setup
         * @param id
         * @param invoiceSetupId
         * @param portalConfigurationInvoiceSetup
         */
        public systemPortalConfigurationsIdInvoiceSetupsInvoiceSetupIdPut (params: {  id: number; invoiceSetupId: number; portalConfigurationInvoiceSetup: PortalConfigurationInvoiceSetup; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PortalConfigurationInvoiceSetup> {
            const localVarPath = this.basePath + '/system/portalConfigurations/{id}/invoiceSetups/{invoiceSetupId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'invoiceSetupId' + '}', String(params.invoiceSetupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalConfigurationsIdInvoiceSetupsInvoiceSetupIdPut');
            }
            // verify required parameter 'invoiceSetupId' is set
            if (params.invoiceSetupId == null) {
                throw new Error('Missing required parameter invoiceSetupId when calling systemPortalConfigurationsIdInvoiceSetupsInvoiceSetupIdPut');
            }
            // verify required parameter 'portalConfigurationInvoiceSetup' is set
            if (params.portalConfigurationInvoiceSetup == null) {
                throw new Error('Missing required parameter portalConfigurationInvoiceSetup when calling systemPortalConfigurationsIdInvoiceSetupsInvoiceSetupIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.portalConfigurationInvoiceSetup),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Test Transaction
         * @param id
         * @param invoiceSetupId
         * @param portalConfigurationInvoiceSetup
         */
        public systemPortalConfigurationsIdInvoiceSetupsInvoiceSetupIdTestTransactionPost (params: {  id: number; invoiceSetupId: number; portalConfigurationInvoiceSetup: PortalConfigurationInvoiceSetup; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SuccessResponse> {
            const localVarPath = this.basePath + '/system/portalConfigurations/{id}/invoiceSetups/{invoiceSetupId}/testTransaction'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'invoiceSetupId' + '}', String(params.invoiceSetupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalConfigurationsIdInvoiceSetupsInvoiceSetupIdTestTransactionPost');
            }
            // verify required parameter 'invoiceSetupId' is set
            if (params.invoiceSetupId == null) {
                throw new Error('Missing required parameter invoiceSetupId when calling systemPortalConfigurationsIdInvoiceSetupsInvoiceSetupIdTestTransactionPost');
            }
            // verify required parameter 'portalConfigurationInvoiceSetup' is set
            if (params.portalConfigurationInvoiceSetup == null) {
                throw new Error('Missing required parameter portalConfigurationInvoiceSetup when calling systemPortalConfigurationsIdInvoiceSetupsInvoiceSetupIdTestTransactionPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.portalConfigurationInvoiceSetup),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PortalConfigurationOpportunitySetupsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Portal Configuration Opportunity Setup
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemPortalConfigurationsIdOpportunitySetupsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<PortalConfigurationOpportunitySetup>> {
            const localVarPath = this.basePath + '/system/portalConfigurations/{id}/opportunitySetups'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalConfigurationsIdOpportunitySetupsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Portal Configuration Opportunity Setup
         * @param id
         * @param operations
         */
        public systemPortalConfigurationsIdOpportunitySetupsPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PortalConfigurationOpportunitySetup> {
            const localVarPath = this.basePath + '/system/portalConfigurations/{id}/opportunitySetups'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalConfigurationsIdOpportunitySetupsPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemPortalConfigurationsIdOpportunitySetupsPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Portal Configuration Opportunity Setup By Id
         * @param id
         * @param portalConfigurationId
         */
        public systemPortalConfigurationsIdOpportunitySetupsPortalConfigurationIdGet (params: {  id: number; portalConfigurationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PortalConfigurationOpportunitySetup> {
            const localVarPath = this.basePath + '/system/portalConfigurations/{id}/opportunitySetups/{portalConfigurationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'portalConfigurationId' + '}', String(params.portalConfigurationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalConfigurationsIdOpportunitySetupsPortalConfigurationIdGet');
            }
            // verify required parameter 'portalConfigurationId' is set
            if (params.portalConfigurationId == null) {
                throw new Error('Missing required parameter portalConfigurationId when calling systemPortalConfigurationsIdOpportunitySetupsPortalConfigurationIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Portal Configuration Opportunity Setup By Id
         * @param id
         * @param portalConfigurationId
         * @param operations
         */
        public systemPortalConfigurationsIdOpportunitySetupsPortalConfigurationIdPatch (params: {  id: number; portalConfigurationId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PortalConfigurationOpportunitySetup> {
            const localVarPath = this.basePath + '/system/portalConfigurations/{id}/opportunitySetups/{portalConfigurationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'portalConfigurationId' + '}', String(params.portalConfigurationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalConfigurationsIdOpportunitySetupsPortalConfigurationIdPatch');
            }
            // verify required parameter 'portalConfigurationId' is set
            if (params.portalConfigurationId == null) {
                throw new Error('Missing required parameter portalConfigurationId when calling systemPortalConfigurationsIdOpportunitySetupsPortalConfigurationIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemPortalConfigurationsIdOpportunitySetupsPortalConfigurationIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Portal Configuration Opportunity Setup
         * @param id
         * @param opportunitySetup
         */
        public systemPortalConfigurationsIdOpportunitySetupsPut (params: {  id: number; opportunitySetup: PortalConfigurationOpportunitySetup; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PortalConfigurationOpportunitySetup> {
            const localVarPath = this.basePath + '/system/portalConfigurations/{id}/opportunitySetups'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalConfigurationsIdOpportunitySetupsPut');
            }
            // verify required parameter 'opportunitySetup' is set
            if (params.opportunitySetup == null) {
                throw new Error('Missing required parameter opportunitySetup when calling systemPortalConfigurationsIdOpportunitySetupsPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.opportunitySetup),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PortalConfigurationPasswordEmailSetupsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Portal Configuration Password Email Setup
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemPortalConfigurationsIdPasswordEmailSetupsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<PortalConfigurationPasswordEmailSetup>> {
            const localVarPath = this.basePath + '/system/portalConfigurations/{id}/passwordEmailSetups'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalConfigurationsIdPasswordEmailSetupsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Portal Configuration Password Email Setup
         * @param id
         * @param passwordEmailSetupId
         */
        public systemPortalConfigurationsIdPasswordEmailSetupsPasswordEmailSetupIdGet (params: {  id: number; passwordEmailSetupId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PortalConfigurationPasswordEmailSetup> {
            const localVarPath = this.basePath + '/system/portalConfigurations/{id}/passwordEmailSetups/{passwordEmailSetupId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'passwordEmailSetupId' + '}', String(params.passwordEmailSetupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalConfigurationsIdPasswordEmailSetupsPasswordEmailSetupIdGet');
            }
            // verify required parameter 'passwordEmailSetupId' is set
            if (params.passwordEmailSetupId == null) {
                throw new Error('Missing required parameter passwordEmailSetupId when calling systemPortalConfigurationsIdPasswordEmailSetupsPasswordEmailSetupIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Portal Configuration Password Email Setup
         * @param id
         * @param passwordEmailSetupId
         * @param operations
         */
        public systemPortalConfigurationsIdPasswordEmailSetupsPasswordEmailSetupIdPatch (params: {  id: number; passwordEmailSetupId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PortalConfigurationPasswordEmailSetup> {
            const localVarPath = this.basePath + '/system/portalConfigurations/{id}/passwordEmailSetups/{passwordEmailSetupId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'passwordEmailSetupId' + '}', String(params.passwordEmailSetupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalConfigurationsIdPasswordEmailSetupsPasswordEmailSetupIdPatch');
            }
            // verify required parameter 'passwordEmailSetupId' is set
            if (params.passwordEmailSetupId == null) {
                throw new Error('Missing required parameter passwordEmailSetupId when calling systemPortalConfigurationsIdPasswordEmailSetupsPasswordEmailSetupIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemPortalConfigurationsIdPasswordEmailSetupsPasswordEmailSetupIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Portal Configuration Password Email Setup
         * @param id
         * @param passwordEmailSetupId
         * @param passwordEmailSetup
         */
        public systemPortalConfigurationsIdPasswordEmailSetupsPasswordEmailSetupIdPut (params: {  id: number; passwordEmailSetupId: number; passwordEmailSetup: PortalConfigurationPasswordEmailSetup; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PortalConfigurationPasswordEmailSetup> {
            const localVarPath = this.basePath + '/system/portalConfigurations/{id}/passwordEmailSetups/{passwordEmailSetupId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'passwordEmailSetupId' + '}', String(params.passwordEmailSetupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalConfigurationsIdPasswordEmailSetupsPasswordEmailSetupIdPut');
            }
            // verify required parameter 'passwordEmailSetupId' is set
            if (params.passwordEmailSetupId == null) {
                throw new Error('Missing required parameter passwordEmailSetupId when calling systemPortalConfigurationsIdPasswordEmailSetupsPasswordEmailSetupIdPut');
            }
            // verify required parameter 'passwordEmailSetup' is set
            if (params.passwordEmailSetup == null) {
                throw new Error('Missing required parameter passwordEmailSetup when calling systemPortalConfigurationsIdPasswordEmailSetupsPasswordEmailSetupIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.passwordEmailSetup),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PortalConfigurationProjectSetupsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Portal Configuration Project Setups Count
         * @param id
         * @param conditions
         */
        public systemPortalConfigurationsIdProjectSetupsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/portalConfigurations/{id}/projectSetups/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalConfigurationsIdProjectSetupsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Portal Configuration Project Setups
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemPortalConfigurationsIdProjectSetupsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<PortalConfigurationProjectSetup>> {
            const localVarPath = this.basePath + '/system/portalConfigurations/{id}/projectSetups'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalConfigurationsIdProjectSetupsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Portal Configuration Project Setup By Id
         * @param id
         * @param portalConfigurationId
         */
        public systemPortalConfigurationsIdProjectSetupsPortalConfigurationIdGet (params: {  id: number; portalConfigurationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PortalConfigurationProjectSetup> {
            const localVarPath = this.basePath + '/system/portalConfigurations/{id}/projectSetups/{portalConfigurationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'portalConfigurationId' + '}', String(params.portalConfigurationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalConfigurationsIdProjectSetupsPortalConfigurationIdGet');
            }
            // verify required parameter 'portalConfigurationId' is set
            if (params.portalConfigurationId == null) {
                throw new Error('Missing required parameter portalConfigurationId when calling systemPortalConfigurationsIdProjectSetupsPortalConfigurationIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Portal Configuration Project Setup
         * @param id
         * @param portalConfigurationId
         * @param operations
         */
        public systemPortalConfigurationsIdProjectSetupsPortalConfigurationIdPatch (params: {  id: number; portalConfigurationId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PortalConfigurationProjectSetup> {
            const localVarPath = this.basePath + '/system/portalConfigurations/{id}/projectSetups/{portalConfigurationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'portalConfigurationId' + '}', String(params.portalConfigurationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalConfigurationsIdProjectSetupsPortalConfigurationIdPatch');
            }
            // verify required parameter 'portalConfigurationId' is set
            if (params.portalConfigurationId == null) {
                throw new Error('Missing required parameter portalConfigurationId when calling systemPortalConfigurationsIdProjectSetupsPortalConfigurationIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemPortalConfigurationsIdProjectSetupsPortalConfigurationIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Portal Configuration Project Setup
         * @param id
         * @param portalConfigurationId
         * @param portalConfigurationProjectSetup
         */
        public systemPortalConfigurationsIdProjectSetupsPortalConfigurationIdPut (params: {  id: number; portalConfigurationId: number; portalConfigurationProjectSetup: PortalConfigurationProjectSetup; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PortalConfigurationProjectSetup> {
            const localVarPath = this.basePath + '/system/portalConfigurations/{id}/projectSetups/{portalConfigurationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'portalConfigurationId' + '}', String(params.portalConfigurationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalConfigurationsIdProjectSetupsPortalConfigurationIdPut');
            }
            // verify required parameter 'portalConfigurationId' is set
            if (params.portalConfigurationId == null) {
                throw new Error('Missing required parameter portalConfigurationId when calling systemPortalConfigurationsIdProjectSetupsPortalConfigurationIdPut');
            }
            // verify required parameter 'portalConfigurationProjectSetup' is set
            if (params.portalConfigurationProjectSetup == null) {
                throw new Error('Missing required parameter portalConfigurationProjectSetup when calling systemPortalConfigurationsIdProjectSetupsPortalConfigurationIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.portalConfigurationProjectSetup),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PortalConfigurationServiceSetupsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Service Setups Count
         * @param id
         * @param conditions
         */
        public systemPortalConfigurationsIdServiceSetupsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/portalConfigurations/{id}/serviceSetups/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalConfigurationsIdServiceSetupsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Service Setups
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemPortalConfigurationsIdServiceSetupsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<PortalConfigurationServiceSetup>> {
            const localVarPath = this.basePath + '/system/portalConfigurations/{id}/serviceSetups'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalConfigurationsIdServiceSetupsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Service Setup By Id
         * @param id
         * @param serviceSetupId
         */
        public systemPortalConfigurationsIdServiceSetupsServiceSetupIdGet (params: {  id: number; serviceSetupId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PortalConfigurationServiceSetup> {
            const localVarPath = this.basePath + '/system/portalConfigurations/{id}/serviceSetups/{serviceSetupId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'serviceSetupId' + '}', String(params.serviceSetupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalConfigurationsIdServiceSetupsServiceSetupIdGet');
            }
            // verify required parameter 'serviceSetupId' is set
            if (params.serviceSetupId == null) {
                throw new Error('Missing required parameter serviceSetupId when calling systemPortalConfigurationsIdServiceSetupsServiceSetupIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Service Setup
         * @param id
         * @param serviceSetupId
         * @param operations
         */
        public systemPortalConfigurationsIdServiceSetupsServiceSetupIdPatch (params: {  id: number; serviceSetupId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PortalConfigurationServiceSetup> {
            const localVarPath = this.basePath + '/system/portalConfigurations/{id}/serviceSetups/{serviceSetupId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'serviceSetupId' + '}', String(params.serviceSetupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalConfigurationsIdServiceSetupsServiceSetupIdPatch');
            }
            // verify required parameter 'serviceSetupId' is set
            if (params.serviceSetupId == null) {
                throw new Error('Missing required parameter serviceSetupId when calling systemPortalConfigurationsIdServiceSetupsServiceSetupIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemPortalConfigurationsIdServiceSetupsServiceSetupIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Service Setup
         * @param id
         * @param serviceSetupId
         * @param portalConfigurationServiceSetup
         */
        public systemPortalConfigurationsIdServiceSetupsServiceSetupIdPut (params: {  id: number; serviceSetupId: number; portalConfigurationServiceSetup: PortalConfigurationServiceSetup; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PortalConfigurationServiceSetup> {
            const localVarPath = this.basePath + '/system/portalConfigurations/{id}/serviceSetups/{serviceSetupId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'serviceSetupId' + '}', String(params.serviceSetupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalConfigurationsIdServiceSetupsServiceSetupIdPut');
            }
            // verify required parameter 'serviceSetupId' is set
            if (params.serviceSetupId == null) {
                throw new Error('Missing required parameter serviceSetupId when calling systemPortalConfigurationsIdServiceSetupsServiceSetupIdPut');
            }
            // verify required parameter 'portalConfigurationServiceSetup' is set
            if (params.portalConfigurationServiceSetup == null) {
                throw new Error('Missing required parameter portalConfigurationServiceSetup when calling systemPortalConfigurationsIdServiceSetupsServiceSetupIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.portalConfigurationServiceSetup),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PortalConfigurationsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Portal Configurations Count
         * @param conditions
         */
        public systemPortalConfigurationsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/portalConfigurations/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Portal Configurations
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemPortalConfigurationsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<PortalConfiguration>> {
            const localVarPath = this.basePath + '/system/portalConfigurations';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Portal Configuration By Id
         * @param id
         */
        public systemPortalConfigurationsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/portalConfigurations/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalConfigurationsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Portal Configuration By Id
         * @param id
         */
        public systemPortalConfigurationsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PortalConfiguration> {
            const localVarPath = this.basePath + '/system/portalConfigurations/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalConfigurationsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Portal Configuration
         * @param id
         * @param operations
         */
        public systemPortalConfigurationsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PortalConfiguration> {
            const localVarPath = this.basePath + '/system/portalConfigurations/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalConfigurationsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemPortalConfigurationsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Portal Image
         * @param id
         * @param lastUpdated
         */
        public systemPortalConfigurationsIdPortalImageGet (params: {  id: number; lastUpdated?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/portalConfigurations/{id}/portalImage'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalConfigurationsIdPortalImageGet');
            }
            if (params.lastUpdated !== undefined) {
                queryParameters['lastUpdated'] = params.lastUpdated;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Portal Configuration
         * @param id
         * @param portalConfiguration
         */
        public systemPortalConfigurationsIdPut (params: {  id: number; portalConfiguration: PortalConfiguration; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PortalConfiguration> {
            const localVarPath = this.basePath + '/system/portalConfigurations/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalConfigurationsIdPut');
            }
            // verify required parameter 'portalConfiguration' is set
            if (params.portalConfiguration == null) {
                throw new Error('Missing required parameter portalConfiguration when calling systemPortalConfigurationsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.portalConfiguration),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Report Image
         * @param id
         * @param lastUpdated
         */
        public systemPortalConfigurationsIdReportImageGet (params: {  id: number; lastUpdated?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/portalConfigurations/{id}/reportImage'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalConfigurationsIdReportImageGet');
            }
            if (params.lastUpdated !== undefined) {
                queryParameters['lastUpdated'] = params.lastUpdated;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Portal Configuration
         * @param portalConfiguration
         */
        public systemPortalConfigurationsPost (params: {  portalConfiguration: PortalConfiguration; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PortalConfiguration> {
            const localVarPath = this.basePath + '/system/portalConfigurations';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'portalConfiguration' is set
            if (params.portalConfiguration == null) {
                throw new Error('Missing required parameter portalConfiguration when calling systemPortalConfigurationsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.portalConfiguration),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PortalReportsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Portal Reports Count
         * @param conditions
         */
        public systemPortalReportsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/portalReports/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Portal Reports
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemPortalReportsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<PortalReport>> {
            const localVarPath = this.basePath + '/system/portalReports';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Portal Report By Id
         * @param id
         */
        public systemPortalReportsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/portalReports/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalReportsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Portal Report By Id
         * @param id
         */
        public systemPortalReportsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PortalReport> {
            const localVarPath = this.basePath + '/system/portalReports/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalReportsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Portal Report
         * @param id
         * @param operations
         */
        public systemPortalReportsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PortalReport> {
            const localVarPath = this.basePath + '/system/portalReports/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalReportsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemPortalReportsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Portal Report
         * @param id
         * @param portalReport
         */
        public systemPortalReportsIdPut (params: {  id: number; portalReport: PortalReport; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PortalReport> {
            const localVarPath = this.basePath + '/system/portalReports/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalReportsIdPut');
            }
            // verify required parameter 'portalReport' is set
            if (params.portalReport == null) {
                throw new Error('Missing required parameter portalReport when calling systemPortalReportsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.portalReport),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Portal Report
         * @param portalReport
         */
        public systemPortalReportsPost (params: {  portalReport: PortalReport; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PortalReport> {
            const localVarPath = this.basePath + '/system/portalReports';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'portalReport' is set
            if (params.portalReport == null) {
                throw new Error('Missing required parameter portalReport when calling systemPortalReportsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.portalReport),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PortalSecuritiesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Portal Securities Count
         * @param conditions
         */
        public systemPortalSecuritiesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/portalSecurities/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Portal Securities
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemPortalSecuritiesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<PortalSecurity>> {
            const localVarPath = this.basePath + '/system/portalSecurities';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Portal Security By Id
         * @param id
         */
        public systemPortalSecuritiesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PortalSecurity> {
            const localVarPath = this.basePath + '/system/portalSecurities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalSecuritiesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Portal Security
         * @param id
         * @param operations
         */
        public systemPortalSecuritiesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PortalSecurity> {
            const localVarPath = this.basePath + '/system/portalSecurities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalSecuritiesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemPortalSecuritiesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Portal Security
         * @param id
         * @param portalSecurity
         */
        public systemPortalSecuritiesIdPut (params: {  id: number; portalSecurity: PortalSecurity; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PortalSecurity> {
            const localVarPath = this.basePath + '/system/portalSecurities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalSecuritiesIdPut');
            }
            // verify required parameter 'portalSecurity' is set
            if (params.portalSecurity == null) {
                throw new Error('Missing required parameter portalSecurity when calling systemPortalSecuritiesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.portalSecurity),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PortalSecurityLevelsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Portal Security Level Captions Count
         * @param conditions
         */
        public systemPortalSecurityLevelsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/portalSecurityLevels/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Portal Security Level Captions
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemPortalSecurityLevelsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<PortalSecurityLevel>> {
            const localVarPath = this.basePath + '/system/portalSecurityLevels';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Portal Security Level Caption By Id
         * @param id
         */
        public systemPortalSecurityLevelsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PortalSecurityLevel> {
            const localVarPath = this.basePath + '/system/portalSecurityLevels/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalSecurityLevelsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Portal Security Level Caption
         * @param id
         * @param operations
         */
        public systemPortalSecurityLevelsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PortalSecurityLevel> {
            const localVarPath = this.basePath + '/system/portalSecurityLevels/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalSecurityLevelsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemPortalSecurityLevelsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Portal Security Level Caption
         * @param id
         * @param portalSecurityLevel
         */
        public systemPortalSecurityLevelsIdPut (params: {  id: number; portalSecurityLevel: PortalSecurityLevel; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PortalSecurityLevel> {
            const localVarPath = this.basePath + '/system/portalSecurityLevels/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemPortalSecurityLevelsIdPut');
            }
            // verify required parameter 'portalSecurityLevel' is set
            if (params.portalSecurityLevel == null) {
                throw new Error('Missing required parameter portalSecurityLevel when calling systemPortalSecurityLevelsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.portalSecurityLevel),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PricingBreaksApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Delete Pricing Break By Id
         * @param schedId
         * @param detailId
         * @param breakId
         */
        public procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdDelete (params: {  schedId: number; detailId: number; breakId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{schedId}/details/{detailId}/breaks/{breakId}'
                .replace('{' + 'schedId' + '}', String(params.schedId))
                .replace('{' + 'detailId' + '}', String(params.detailId))
                .replace('{' + 'breakId' + '}', String(params.breakId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'schedId' is set
            if (params.schedId == null) {
                throw new Error('Missing required parameter schedId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdDelete');
            }
            // verify required parameter 'detailId' is set
            if (params.detailId == null) {
                throw new Error('Missing required parameter detailId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdDelete');
            }
            // verify required parameter 'breakId' is set
            if (params.breakId == null) {
                throw new Error('Missing required parameter breakId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Pricing Break By Id
         * @param schedId
         * @param detailId
         * @param breakId
         */
        public procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdGet (params: {  schedId: number; detailId: number; breakId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingBreak> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{schedId}/details/{detailId}/breaks/{breakId}'
                .replace('{' + 'schedId' + '}', String(params.schedId))
                .replace('{' + 'detailId' + '}', String(params.detailId))
                .replace('{' + 'breakId' + '}', String(params.breakId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'schedId' is set
            if (params.schedId == null) {
                throw new Error('Missing required parameter schedId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdGet');
            }
            // verify required parameter 'detailId' is set
            if (params.detailId == null) {
                throw new Error('Missing required parameter detailId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdGet');
            }
            // verify required parameter 'breakId' is set
            if (params.breakId == null) {
                throw new Error('Missing required parameter breakId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Pricing Break
         * @param schedId
         * @param detailId
         * @param breakId
         * @param operations
         */
        public procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdPatch (params: {  schedId: number; detailId: number; breakId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingBreak> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{schedId}/details/{detailId}/breaks/{breakId}'
                .replace('{' + 'schedId' + '}', String(params.schedId))
                .replace('{' + 'detailId' + '}', String(params.detailId))
                .replace('{' + 'breakId' + '}', String(params.breakId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'schedId' is set
            if (params.schedId == null) {
                throw new Error('Missing required parameter schedId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdPatch');
            }
            // verify required parameter 'detailId' is set
            if (params.detailId == null) {
                throw new Error('Missing required parameter detailId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdPatch');
            }
            // verify required parameter 'breakId' is set
            if (params.breakId == null) {
                throw new Error('Missing required parameter breakId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Pricing Break
         * @param schedId
         * @param detailId
         * @param breakId
         * @param pricingBreak
         */
        public procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdPut (params: {  schedId: number; detailId: number; breakId: number; pricingBreak: PricingBreak; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingBreak> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{schedId}/details/{detailId}/breaks/{breakId}'
                .replace('{' + 'schedId' + '}', String(params.schedId))
                .replace('{' + 'detailId' + '}', String(params.detailId))
                .replace('{' + 'breakId' + '}', String(params.breakId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'schedId' is set
            if (params.schedId == null) {
                throw new Error('Missing required parameter schedId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdPut');
            }
            // verify required parameter 'detailId' is set
            if (params.detailId == null) {
                throw new Error('Missing required parameter detailId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdPut');
            }
            // verify required parameter 'breakId' is set
            if (params.breakId == null) {
                throw new Error('Missing required parameter breakId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdPut');
            }
            // verify required parameter 'pricingBreak' is set
            if (params.pricingBreak == null) {
                throw new Error('Missing required parameter pricingBreak when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.pricingBreak),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Pricing Break Count
         * @param schedId
         * @param detailId
         * @param conditions
         */
        public procurementPricingschedulesSchedIdDetailsDetailIdBreaksCountGet (params: {  schedId: number; detailId: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{schedId}/details/{detailId}/breaks/count'
                .replace('{' + 'schedId' + '}', String(params.schedId))
                .replace('{' + 'detailId' + '}', String(params.detailId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'schedId' is set
            if (params.schedId == null) {
                throw new Error('Missing required parameter schedId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksCountGet');
            }
            // verify required parameter 'detailId' is set
            if (params.detailId == null) {
                throw new Error('Missing required parameter detailId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Pricing Break
         * @param schedId
         * @param detailId
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementPricingschedulesSchedIdDetailsDetailIdBreaksGet (params: {  schedId: number; detailId: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<PricingBreak>> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{schedId}/details/{detailId}/breaks'
                .replace('{' + 'schedId' + '}', String(params.schedId))
                .replace('{' + 'detailId' + '}', String(params.detailId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'schedId' is set
            if (params.schedId == null) {
                throw new Error('Missing required parameter schedId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksGet');
            }
            // verify required parameter 'detailId' is set
            if (params.detailId == null) {
                throw new Error('Missing required parameter detailId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Pricing Break
         * @param schedId
         * @param detailId
         * @param pricingBreak
         */
        public procurementPricingschedulesSchedIdDetailsDetailIdBreaksPost (params: {  schedId: number; detailId: number; pricingBreak: PricingBreak; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingBreak> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{schedId}/details/{detailId}/breaks'
                .replace('{' + 'schedId' + '}', String(params.schedId))
                .replace('{' + 'detailId' + '}', String(params.detailId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'schedId' is set
            if (params.schedId == null) {
                throw new Error('Missing required parameter schedId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksPost');
            }
            // verify required parameter 'detailId' is set
            if (params.detailId == null) {
                throw new Error('Missing required parameter detailId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksPost');
            }
            // verify required parameter 'pricingBreak' is set
            if (params.pricingBreak == null) {
                throw new Error('Missing required parameter pricingBreak when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.pricingBreak),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PricingDetailsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Pricing Detail Count
         * @param id
         * @param conditions
         */
        public procurementPricingschedulesIdDetailsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{id}/details/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPricingschedulesIdDetailsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Pricing Detail By Id
         * @param id
         * @param detailID
         */
        public procurementPricingschedulesIdDetailsDetailIDDelete (params: {  id: number; detailID: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{id}/details/{detailID}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'detailID' + '}', String(params.detailID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPricingschedulesIdDetailsDetailIDDelete');
            }
            // verify required parameter 'detailID' is set
            if (params.detailID == null) {
                throw new Error('Missing required parameter detailID when calling procurementPricingschedulesIdDetailsDetailIDDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Pricing Detail By Id
         * @param id
         * @param detailID
         */
        public procurementPricingschedulesIdDetailsDetailIDGet (params: {  id: number; detailID: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingDetail> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{id}/details/{detailID}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'detailID' + '}', String(params.detailID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPricingschedulesIdDetailsDetailIDGet');
            }
            // verify required parameter 'detailID' is set
            if (params.detailID == null) {
                throw new Error('Missing required parameter detailID when calling procurementPricingschedulesIdDetailsDetailIDGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Pricing Detail
         * @param id
         * @param detailID
         * @param operations
         */
        public procurementPricingschedulesIdDetailsDetailIDPatch (params: {  id: number; detailID: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingDetail> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{id}/details/{detailID}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'detailID' + '}', String(params.detailID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPricingschedulesIdDetailsDetailIDPatch');
            }
            // verify required parameter 'detailID' is set
            if (params.detailID == null) {
                throw new Error('Missing required parameter detailID when calling procurementPricingschedulesIdDetailsDetailIDPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementPricingschedulesIdDetailsDetailIDPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Pricing Detail
         * @param id
         * @param detailID
         * @param pricingDetail
         */
        public procurementPricingschedulesIdDetailsDetailIDPut (params: {  id: number; detailID: number; pricingDetail: PricingDetail; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingDetail> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{id}/details/{detailID}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'detailID' + '}', String(params.detailID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPricingschedulesIdDetailsDetailIDPut');
            }
            // verify required parameter 'detailID' is set
            if (params.detailID == null) {
                throw new Error('Missing required parameter detailID when calling procurementPricingschedulesIdDetailsDetailIDPut');
            }
            // verify required parameter 'pricingDetail' is set
            if (params.pricingDetail == null) {
                throw new Error('Missing required parameter pricingDetail when calling procurementPricingschedulesIdDetailsDetailIDPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.pricingDetail),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Pricing Detail
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementPricingschedulesIdDetailsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<PricingDetail>> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{id}/details'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPricingschedulesIdDetailsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Pricing Detail
         * @param id
         * @param pricingDetail
         */
        public procurementPricingschedulesIdDetailsPost (params: {  id: number; pricingDetail: PricingDetail; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingDetail> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{id}/details'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPricingschedulesIdDetailsPost');
            }
            // verify required parameter 'pricingDetail' is set
            if (params.pricingDetail == null) {
                throw new Error('Missing required parameter pricingDetail when calling procurementPricingschedulesIdDetailsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.pricingDetail),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PricingSchedulesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Pricing Schedules Count
         * @param conditions
         */
        public procurementPricingschedulesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Pricing Schedules
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementPricingschedulesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<PricingSchedule>> {
            const localVarPath = this.basePath + '/procurement/pricingschedules';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Pricing Schedule By Id
         * @param id
         */
        public procurementPricingschedulesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPricingschedulesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Pricing Schedule By Id
         * @param id
         */
        public procurementPricingschedulesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingSchedule> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPricingschedulesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Pricing Schedule
         * @param id
         * @param operations
         */
        public procurementPricingschedulesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingSchedule> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPricingschedulesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementPricingschedulesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Pricing Schedule
         * @param id
         * @param pricingSchedule
         */
        public procurementPricingschedulesIdPut (params: {  id: number; pricingSchedule: PricingSchedule; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingSchedule> {
            const localVarPath = this.basePath + '/procurement/pricingschedules/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPricingschedulesIdPut');
            }
            // verify required parameter 'pricingSchedule' is set
            if (params.pricingSchedule == null) {
                throw new Error('Missing required parameter pricingSchedule when calling procurementPricingschedulesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.pricingSchedule),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Pricing Schedule
         * @param pricingSchedule
         */
        public procurementPricingschedulesPost (params: {  pricingSchedule: PricingSchedule; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingSchedule> {
            const localVarPath = this.basePath + '/procurement/pricingschedules';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'pricingSchedule' is set
            if (params.pricingSchedule == null) {
                throw new Error('Missing required parameter pricingSchedule when calling procurementPricingschedulesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.pricingSchedule),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PrioritiesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Create Priorities Count
         * @param conditions
         */
        public servicePrioritiesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/priorities/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Priorities
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public servicePrioritiesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Priority>> {
            const localVarPath = this.basePath + '/service/priorities';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Priority By Id
         * @param id
         */
        public servicePrioritiesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/priorities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling servicePrioritiesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Priority By Id
         * @param id
         */
        public servicePrioritiesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Priority> {
            const localVarPath = this.basePath + '/service/priorities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling servicePrioritiesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Priority Image
         * @param id
         * @param useDefaultFlag
         * @param lastModified
         */
        public servicePrioritiesIdImageGet (params: {  id: number; useDefaultFlag?: boolean; lastModified?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/priorities/{id}/image'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling servicePrioritiesIdImageGet');
            }
            if (params.useDefaultFlag !== undefined) {
                queryParameters['useDefaultFlag'] = params.useDefaultFlag;
            }

            if (params.lastModified !== undefined) {
                queryParameters['lastModified'] = params.lastModified;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Priority
         * @param id
         * @param operations
         */
        public servicePrioritiesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Priority> {
            const localVarPath = this.basePath + '/service/priorities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling servicePrioritiesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling servicePrioritiesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Priority
         * @param id
         * @param priority
         */
        public servicePrioritiesIdPut (params: {  id: number; priority: Priority; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Priority> {
            const localVarPath = this.basePath + '/service/priorities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling servicePrioritiesIdPut');
            }
            // verify required parameter 'priority' is set
            if (params.priority == null) {
                throw new Error('Missing required parameter priority when calling servicePrioritiesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.priority),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Priority
         * @param priority
         */
        public servicePrioritiesPost (params: {  priority: Priority; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Priority> {
            const localVarPath = this.basePath + '/service/priorities';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'priority' is set
            if (params.priority == null) {
                throw new Error('Missing required parameter priority when calling servicePrioritiesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.priority),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ProductComponentsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Delete Product Component By Id
         * @param id
         * @param componentId
         */
        public procurementProductsIdComponentsComponentIdDelete (params: {  id: number; componentId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/products/{id}/components/{componentId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'componentId' + '}', String(params.componentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdComponentsComponentIdDelete');
            }
            // verify required parameter 'componentId' is set
            if (params.componentId == null) {
                throw new Error('Missing required parameter componentId when calling procurementProductsIdComponentsComponentIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Product Component By Id
         * @param id
         * @param componentId
         */
        public procurementProductsIdComponentsComponentIdGet (params: {  id: number; componentId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductComponent>> {
            const localVarPath = this.basePath + '/procurement/products/{id}/components/{componentId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'componentId' + '}', String(params.componentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdComponentsComponentIdGet');
            }
            // verify required parameter 'componentId' is set
            if (params.componentId == null) {
                throw new Error('Missing required parameter componentId when calling procurementProductsIdComponentsComponentIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Product Component
         * @param id
         * @param componentId
         * @param operations
         */
        public procurementProductsIdComponentsComponentIdPatch (params: {  id: number; componentId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductComponent>> {
            const localVarPath = this.basePath + '/procurement/products/{id}/components/{componentId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'componentId' + '}', String(params.componentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdComponentsComponentIdPatch');
            }
            // verify required parameter 'componentId' is set
            if (params.componentId == null) {
                throw new Error('Missing required parameter componentId when calling procurementProductsIdComponentsComponentIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementProductsIdComponentsComponentIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Product Component
         * @param id
         * @param componentId
         * @param productComponent
         */
        public procurementProductsIdComponentsComponentIdPut (params: {  id: number; componentId: number; productComponent: ProductComponent; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductComponent>> {
            const localVarPath = this.basePath + '/procurement/products/{id}/components/{componentId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'componentId' + '}', String(params.componentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdComponentsComponentIdPut');
            }
            // verify required parameter 'componentId' is set
            if (params.componentId == null) {
                throw new Error('Missing required parameter componentId when calling procurementProductsIdComponentsComponentIdPut');
            }
            // verify required parameter 'productComponent' is set
            if (params.productComponent == null) {
                throw new Error('Missing required parameter productComponent when calling procurementProductsIdComponentsComponentIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.productComponent),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Product Components Count
         * @param id
         * @param conditions
         */
        public procurementProductsIdComponentsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/products/{id}/components/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdComponentsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Product Components
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementProductsIdComponentsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductComponent>> {
            const localVarPath = this.basePath + '/procurement/products/{id}/components'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdComponentsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Product Component
         * @param id
         * @param productComponent
         */
        public procurementProductsIdComponentsPost (params: {  id: number; productComponent: ProductComponent; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductComponent>> {
            const localVarPath = this.basePath + '/procurement/products/{id}/components'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdComponentsPost');
            }
            // verify required parameter 'productComponent' is set
            if (params.productComponent == null) {
                throw new Error('Missing required parameter productComponent when calling procurementProductsIdComponentsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.productComponent),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ProductPickingShippingDetailsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Product Picking Shipping Details Count
         * @param id
         * @param conditions
         */
        public procurementProductsIdPickingShippingDetailsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/products/{id}/pickingShippingDetails/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdPickingShippingDetailsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Product Picking Shipping Details
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementProductsIdPickingShippingDetailsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductPickingShippingDetail>> {
            const localVarPath = this.basePath + '/procurement/products/{id}/pickingShippingDetails'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdPickingShippingDetailsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Products By Id
         * @param id
         * @param pickingShippingDetailId
         */
        public procurementProductsIdPickingShippingDetailsPickingShippingDetailIdDelete (params: {  id: number; pickingShippingDetailId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/products/{id}/pickingShippingDetails/{pickingShippingDetailId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'pickingShippingDetailId' + '}', String(params.pickingShippingDetailId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdPickingShippingDetailsPickingShippingDetailIdDelete');
            }
            // verify required parameter 'pickingShippingDetailId' is set
            if (params.pickingShippingDetailId == null) {
                throw new Error('Missing required parameter pickingShippingDetailId when calling procurementProductsIdPickingShippingDetailsPickingShippingDetailIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Products By Id
         * @param id
         * @param pickingShippingDetailId
         */
        public procurementProductsIdPickingShippingDetailsPickingShippingDetailIdGet (params: {  id: number; pickingShippingDetailId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductPickingShippingDetail>> {
            const localVarPath = this.basePath + '/procurement/products/{id}/pickingShippingDetails/{pickingShippingDetailId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'pickingShippingDetailId' + '}', String(params.pickingShippingDetailId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdPickingShippingDetailsPickingShippingDetailIdGet');
            }
            // verify required parameter 'pickingShippingDetailId' is set
            if (params.pickingShippingDetailId == null) {
                throw new Error('Missing required parameter pickingShippingDetailId when calling procurementProductsIdPickingShippingDetailsPickingShippingDetailIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Products
         * @param id
         * @param pickingShippingDetailId
         * @param operations
         */
        public procurementProductsIdPickingShippingDetailsPickingShippingDetailIdPatch (params: {  id: number; pickingShippingDetailId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductPickingShippingDetail>> {
            const localVarPath = this.basePath + '/procurement/products/{id}/pickingShippingDetails/{pickingShippingDetailId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'pickingShippingDetailId' + '}', String(params.pickingShippingDetailId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdPickingShippingDetailsPickingShippingDetailIdPatch');
            }
            // verify required parameter 'pickingShippingDetailId' is set
            if (params.pickingShippingDetailId == null) {
                throw new Error('Missing required parameter pickingShippingDetailId when calling procurementProductsIdPickingShippingDetailsPickingShippingDetailIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementProductsIdPickingShippingDetailsPickingShippingDetailIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Products
         * @param id
         * @param pickingShippingDetailId
         * @param productPickingShippingDetails
         */
        public procurementProductsIdPickingShippingDetailsPickingShippingDetailIdPut (params: {  id: number; pickingShippingDetailId: number; productPickingShippingDetails: ProductPickingShippingDetail; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductPickingShippingDetail>> {
            const localVarPath = this.basePath + '/procurement/products/{id}/pickingShippingDetails/{pickingShippingDetailId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'pickingShippingDetailId' + '}', String(params.pickingShippingDetailId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdPickingShippingDetailsPickingShippingDetailIdPut');
            }
            // verify required parameter 'pickingShippingDetailId' is set
            if (params.pickingShippingDetailId == null) {
                throw new Error('Missing required parameter pickingShippingDetailId when calling procurementProductsIdPickingShippingDetailsPickingShippingDetailIdPut');
            }
            // verify required parameter 'productPickingShippingDetails' is set
            if (params.productPickingShippingDetails == null) {
                throw new Error('Missing required parameter productPickingShippingDetails when calling procurementProductsIdPickingShippingDetailsPickingShippingDetailIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.productPickingShippingDetails),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Product Picking Shipping Detail
         * @param id
         * @param productPickingShippingDetails
         */
        public procurementProductsIdPickingShippingDetailsPost (params: {  id: number; productPickingShippingDetails: ProductPickingShippingDetail; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductPickingShippingDetail>> {
            const localVarPath = this.basePath + '/procurement/products/{id}/pickingShippingDetails'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdPickingShippingDetailsPost');
            }
            // verify required parameter 'productPickingShippingDetails' is set
            if (params.productPickingShippingDetails == null) {
                throw new Error('Missing required parameter productPickingShippingDetails when calling procurementProductsIdPickingShippingDetailsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.productPickingShippingDetails),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ProductTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Product Typess Count
         * @param conditions
         */
        public procurementTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/types/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Product Typess
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductType>> {
            const localVarPath = this.basePath + '/procurement/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Product Types By Id
         * @param id
         */
        public procurementTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementTypesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Product Types By Id
         * @param id
         */
        public procurementTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProductType> {
            const localVarPath = this.basePath + '/procurement/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementTypesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Product Types
         * @param id
         * @param operations
         */
        public procurementTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProductType> {
            const localVarPath = this.basePath + '/procurement/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementTypesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementTypesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Product Types
         * @param id
         * @param productTypes
         */
        public procurementTypesIdPut (params: {  id: number; productTypes: ProductType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProductType> {
            const localVarPath = this.basePath + '/procurement/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementTypesIdPut');
            }
            // verify required parameter 'productTypes' is set
            if (params.productTypes == null) {
                throw new Error('Missing required parameter productTypes when calling procurementTypesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.productTypes),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Product Types
         * @param productTypes
         */
        public procurementTypesPost (params: {  productTypes: ProductType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProductType> {
            const localVarPath = this.basePath + '/procurement/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'productTypes' is set
            if (params.productTypes == null) {
                throw new Error('Missing required parameter productTypes when calling procurementTypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.productTypes),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ProductsItemApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Products Count
         * @param conditions
         */
        public procurementProductsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/products/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Products
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementProductsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductItem>> {
            const localVarPath = this.basePath + '/procurement/products';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Product By Id
         * @param id
         */
        public procurementProductsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/products/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Product By Id
         * @param id
         */
        public procurementProductsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProductItem> {
            const localVarPath = this.basePath + '/procurement/products/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Product
         * @param id
         * @param operations
         */
        public procurementProductsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProductItem> {
            const localVarPath = this.basePath + '/procurement/products/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementProductsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Product
         * @param id
         * @param productItem
         */
        public procurementProductsIdPut (params: {  id: number; productItem: ProductItem; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProductItem> {
            const localVarPath = this.basePath + '/procurement/products/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementProductsIdPut');
            }
            // verify required parameter 'productItem' is set
            if (params.productItem == null) {
                throw new Error('Missing required parameter productItem when calling procurementProductsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.productItem),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Product
         * @param productItem
         */
        public procurementProductsPost (params: {  productItem: ProductItem; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProductItem> {
            const localVarPath = this.basePath + '/procurement/products';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'productItem' is set
            if (params.productItem == null) {
                throw new Error('Missing required parameter productItem when calling procurementProductsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.productItem),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ProjectContactsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Delete Project Contact By Id
         * @param id
         * @param contactId
         */
        public projectProjectsIdContactsContactIdDelete (params: {  id: number; contactId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/project/projects/{id}/contacts/{contactId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'contactId' + '}', String(params.contactId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdContactsContactIdDelete');
            }
            // verify required parameter 'contactId' is set
            if (params.contactId == null) {
                throw new Error('Missing required parameter contactId when calling projectProjectsIdContactsContactIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Project Contact By Id
         * @param id
         * @param contactId
         */
        public projectProjectsIdContactsContactIdGet (params: {  id: number; contactId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectContact> {
            const localVarPath = this.basePath + '/project/projects/{id}/contacts/{contactId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'contactId' + '}', String(params.contactId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdContactsContactIdGet');
            }
            // verify required parameter 'contactId' is set
            if (params.contactId == null) {
                throw new Error('Missing required parameter contactId when calling projectProjectsIdContactsContactIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Project Contacts
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public projectProjectsIdContactsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProjectContact>> {
            const localVarPath = this.basePath + '/project/projects/{id}/contacts'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdContactsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Project Contact
         * @param id
         * @param contact
         */
        public projectProjectsIdContactsPost (params: {  id: number; contact: ProjectContact; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectContact> {
            const localVarPath = this.basePath + '/project/projects/{id}/contacts'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdContactsPost');
            }
            // verify required parameter 'contact' is set
            if (params.contact == null) {
                throw new Error('Missing required parameter contact when calling projectProjectsIdContactsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.contact),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ProjectNotesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Project Notes Count
         * @param id
         * @param conditions
         */
        public projectProjectsIdNotesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/project/projects/{id}/notes/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdNotesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Project Notes
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public projectProjectsIdNotesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProjectNote>> {
            const localVarPath = this.basePath + '/project/projects/{id}/notes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdNotesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Project Note By Id
         * @param id
         * @param noteId
         */
        public projectProjectsIdNotesNoteIdDelete (params: {  id: number; noteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/project/projects/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdNotesNoteIdDelete');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling projectProjectsIdNotesNoteIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Project Note By Id
         * @param id
         * @param noteId
         */
        public projectProjectsIdNotesNoteIdGet (params: {  id: number; noteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectNote> {
            const localVarPath = this.basePath + '/project/projects/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdNotesNoteIdGet');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling projectProjectsIdNotesNoteIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Project Note
         * @param id
         * @param noteId
         * @param operations
         */
        public projectProjectsIdNotesNoteIdPatch (params: {  id: number; noteId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectNote> {
            const localVarPath = this.basePath + '/project/projects/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdNotesNoteIdPatch');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling projectProjectsIdNotesNoteIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling projectProjectsIdNotesNoteIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Project Note
         * @param id
         * @param noteId
         * @param note
         */
        public projectProjectsIdNotesNoteIdPut (params: {  id: number; noteId: number; note: ProjectNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectNote> {
            const localVarPath = this.basePath + '/project/projects/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdNotesNoteIdPut');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling projectProjectsIdNotesNoteIdPut');
            }
            // verify required parameter 'note' is set
            if (params.note == null) {
                throw new Error('Missing required parameter note when calling projectProjectsIdNotesNoteIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.note),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Project Note
         * @param id
         * @param note
         */
        public projectProjectsIdNotesPost (params: {  id: number; note: ProjectNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectNote> {
            const localVarPath = this.basePath + '/project/projects/{id}/notes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdNotesPost');
            }
            // verify required parameter 'note' is set
            if (params.note == null) {
                throw new Error('Missing required parameter note when calling projectProjectsIdNotesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.note),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ProjectPhasesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Project Phases Count
         * @param id
         * @param conditions
         */
        public projectProjectsIdPhasesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/project/projects/{id}/phases/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdPhasesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Project Phases
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public projectProjectsIdPhasesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProjectPhase>> {
            const localVarPath = this.basePath + '/project/projects/{id}/phases'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdPhasesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Project Phase By Id
         * @param id
         * @param phaseId
         */
        public projectProjectsIdPhasesPhaseIdDelete (params: {  id: number; phaseId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/project/projects/{id}/phases/{phaseId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'phaseId' + '}', String(params.phaseId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdPhasesPhaseIdDelete');
            }
            // verify required parameter 'phaseId' is set
            if (params.phaseId == null) {
                throw new Error('Missing required parameter phaseId when calling projectProjectsIdPhasesPhaseIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Project Phase By Id
         * @param id
         * @param phaseId
         */
        public projectProjectsIdPhasesPhaseIdGet (params: {  id: number; phaseId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectPhase> {
            const localVarPath = this.basePath + '/project/projects/{id}/phases/{phaseId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'phaseId' + '}', String(params.phaseId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdPhasesPhaseIdGet');
            }
            // verify required parameter 'phaseId' is set
            if (params.phaseId == null) {
                throw new Error('Missing required parameter phaseId when calling projectProjectsIdPhasesPhaseIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Project Phase
         * @param id
         * @param phaseId
         * @param operations
         */
        public projectProjectsIdPhasesPhaseIdPatch (params: {  id: number; phaseId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectPhase> {
            const localVarPath = this.basePath + '/project/projects/{id}/phases/{phaseId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'phaseId' + '}', String(params.phaseId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdPhasesPhaseIdPatch');
            }
            // verify required parameter 'phaseId' is set
            if (params.phaseId == null) {
                throw new Error('Missing required parameter phaseId when calling projectProjectsIdPhasesPhaseIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling projectProjectsIdPhasesPhaseIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Project Phase
         * @param id
         * @param phaseId
         * @param projectPhase
         */
        public projectProjectsIdPhasesPhaseIdPut (params: {  id: number; phaseId: number; projectPhase: ProjectPhase; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectPhase> {
            const localVarPath = this.basePath + '/project/projects/{id}/phases/{phaseId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'phaseId' + '}', String(params.phaseId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdPhasesPhaseIdPut');
            }
            // verify required parameter 'phaseId' is set
            if (params.phaseId == null) {
                throw new Error('Missing required parameter phaseId when calling projectProjectsIdPhasesPhaseIdPut');
            }
            // verify required parameter 'projectPhase' is set
            if (params.projectPhase == null) {
                throw new Error('Missing required parameter projectPhase when calling projectProjectsIdPhasesPhaseIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.projectPhase),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Project Phase
         * @param id
         * @param projectPhase
         */
        public projectProjectsIdPhasesPost (params: {  id: number; projectPhase: ProjectPhase; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectPhase> {
            const localVarPath = this.basePath + '/project/projects/{id}/phases'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdPhasesPost');
            }
            // verify required parameter 'projectPhase' is set
            if (params.projectPhase == null) {
                throw new Error('Missing required parameter projectPhase when calling projectProjectsIdPhasesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.projectPhase),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ProjectSecurityRoleSettingsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Project Security Role Setting Count
         * @param id
         * @param conditions
         */
        public systemProjectSecurityRolesIdSettingsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/projectSecurityRoles/{id}/settings/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemProjectSecurityRolesIdSettingsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Project Security Role Settings
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemProjectSecurityRolesIdSettingsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProjectSecurityRoleSetting>> {
            const localVarPath = this.basePath + '/system/projectSecurityRoles/{id}/settings'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemProjectSecurityRolesIdSettingsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Project Security Role Setting By Id
         * @param id
         * @param settingId
         */
        public systemProjectSecurityRolesIdSettingsSettingIdGet (params: {  id: number; settingId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectSecurityRoleSetting> {
            const localVarPath = this.basePath + '/system/projectSecurityRoles/{id}/settings/{settingId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'settingId' + '}', String(params.settingId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemProjectSecurityRolesIdSettingsSettingIdGet');
            }
            // verify required parameter 'settingId' is set
            if (params.settingId == null) {
                throw new Error('Missing required parameter settingId when calling systemProjectSecurityRolesIdSettingsSettingIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Project Security Role Setting
         * @param id
         * @param settingId
         * @param operations
         */
        public systemProjectSecurityRolesIdSettingsSettingIdPatch (params: {  id: number; settingId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectSecurityRoleSetting> {
            const localVarPath = this.basePath + '/system/projectSecurityRoles/{id}/settings/{settingId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'settingId' + '}', String(params.settingId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemProjectSecurityRolesIdSettingsSettingIdPatch');
            }
            // verify required parameter 'settingId' is set
            if (params.settingId == null) {
                throw new Error('Missing required parameter settingId when calling systemProjectSecurityRolesIdSettingsSettingIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemProjectSecurityRolesIdSettingsSettingIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Project Security Role Setting
         * @param id
         * @param settingId
         * @param projectSecurityRoleSetting
         */
        public systemProjectSecurityRolesIdSettingsSettingIdPut (params: {  id: number; settingId: number; projectSecurityRoleSetting: ProjectSecurityRoleSetting; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectSecurityRoleSetting> {
            const localVarPath = this.basePath + '/system/projectSecurityRoles/{id}/settings/{settingId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'settingId' + '}', String(params.settingId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemProjectSecurityRolesIdSettingsSettingIdPut');
            }
            // verify required parameter 'settingId' is set
            if (params.settingId == null) {
                throw new Error('Missing required parameter settingId when calling systemProjectSecurityRolesIdSettingsSettingIdPut');
            }
            // verify required parameter 'projectSecurityRoleSetting' is set
            if (params.projectSecurityRoleSetting == null) {
                throw new Error('Missing required parameter projectSecurityRoleSetting when calling systemProjectSecurityRolesIdSettingsSettingIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.projectSecurityRoleSetting),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ProjectSecurityRolesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Project Security Role Count
         * @param conditions
         */
        public systemProjectSecurityRolesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/projectSecurityRoles/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Project Security Roles
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemProjectSecurityRolesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProjectSecurityRole>> {
            const localVarPath = this.basePath + '/system/projectSecurityRoles';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Project Security Roley By Id
         * @param id
         */
        public systemProjectSecurityRolesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/projectSecurityRoles/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemProjectSecurityRolesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Project Security Role By Id
         * @param id
         */
        public systemProjectSecurityRolesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectSecurityRole> {
            const localVarPath = this.basePath + '/system/projectSecurityRoles/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemProjectSecurityRolesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Project Security Role
         * @param id
         * @param operations
         */
        public systemProjectSecurityRolesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectSecurityRole> {
            const localVarPath = this.basePath + '/system/projectSecurityRoles/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemProjectSecurityRolesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemProjectSecurityRolesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Project Security Role
         * @param id
         * @param projectSecurityRole
         */
        public systemProjectSecurityRolesIdPut (params: {  id: number; projectSecurityRole: ProjectSecurityRole; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectSecurityRole> {
            const localVarPath = this.basePath + '/system/projectSecurityRoles/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemProjectSecurityRolesIdPut');
            }
            // verify required parameter 'projectSecurityRole' is set
            if (params.projectSecurityRole == null) {
                throw new Error('Missing required parameter projectSecurityRole when calling systemProjectSecurityRolesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.projectSecurityRole),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Project Security Role
         * @param projectSecurityRole
         */
        public systemProjectSecurityRolesPost (params: {  projectSecurityRole: ProjectSecurityRole; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectSecurityRole> {
            const localVarPath = this.basePath + '/system/projectSecurityRoles';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'projectSecurityRole' is set
            if (params.projectSecurityRole == null) {
                throw new Error('Missing required parameter projectSecurityRole when calling systemProjectSecurityRolesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.projectSecurityRole),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ProjectStatusesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Project Statuses Count
         * @param conditions
         */
        public projectStatusesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/project/statuses/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Project Statuses
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public projectStatusesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProjectStatus>> {
            const localVarPath = this.basePath + '/project/statuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Project Status By Id
         * @param id
         */
        public projectStatusesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/project/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectStatusesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Project Status By Id
         * @param id
         */
        public projectStatusesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectStatus> {
            const localVarPath = this.basePath + '/project/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectStatusesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Project Status
         * @param id
         * @param operations
         */
        public projectStatusesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectStatus> {
            const localVarPath = this.basePath + '/project/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectStatusesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling projectStatusesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Project Status
         * @param id
         * @param projectStatus
         */
        public projectStatusesIdPut (params: {  id: number; projectStatus: ProjectStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectStatus> {
            const localVarPath = this.basePath + '/project/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectStatusesIdPut');
            }
            // verify required parameter 'projectStatus' is set
            if (params.projectStatus == null) {
                throw new Error('Missing required parameter projectStatus when calling projectStatusesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.projectStatus),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Project Status
         * @param projectStatus
         */
        public projectStatusesPost (params: {  projectStatus: ProjectStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectStatus> {
            const localVarPath = this.basePath + '/project/statuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'projectStatus' is set
            if (params.projectStatus == null) {
                throw new Error('Missing required parameter projectStatus when calling projectStatusesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.projectStatus),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ProjectTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Project Type Count
         * @param conditions
         */
        public systemProjectTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/projectTypes/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Project Type
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemProjectTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProjectType>> {
            const localVarPath = this.basePath + '/system/projectTypes';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Project Type By Id
         * @param id
         */
        public systemProjectTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectType> {
            const localVarPath = this.basePath + '/system/projectTypes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemProjectTypesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ProjectsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Projects Count
         * @param conditions
         * @param customFieldConditions
         */
        public projectProjectsCountGet (params: {  conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/project/projects/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.customFieldConditions !== undefined) {
                queryParameters['customFieldConditions'] = params.customFieldConditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Projects
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public projectProjectsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Project>> {
            const localVarPath = this.basePath + '/project/projects';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Project By Id
         * @param id
         */
        public projectProjectsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/project/projects/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Project By Id
         * @param id
         */
        public projectProjectsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Project> {
            const localVarPath = this.basePath + '/project/projects/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Project
         * @param id
         * @param operations
         */
        public projectProjectsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Project> {
            const localVarPath = this.basePath + '/project/projects/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling projectProjectsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Project
         * @param id
         * @param project
         */
        public projectProjectsIdPut (params: {  id: number; project: Project; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Project> {
            const localVarPath = this.basePath + '/project/projects/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdPut');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling projectProjectsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.project),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Project
         * @param project
         */
        public projectProjectsPost (params: {  project: Project; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Project> {
            const localVarPath = this.basePath + '/project/projects';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling projectProjectsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.project),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ProjectsTeammembersApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Team Members Count
         * @param id
         * @param conditions
         */
        public projectProjectsIdTeamMembersCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/project/projects/{id}/teamMembers/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdTeamMembersCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Team Members
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public projectProjectsIdTeamMembersGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProjectTeammember>> {
            const localVarPath = this.basePath + '/project/projects/{id}/teamMembers'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdTeamMembersGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Team Member
         * @param id
         * @param teamMember
         */
        public projectProjectsIdTeamMembersPost (params: {  id: number; teamMember: ProjectTeammember; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectTeammember> {
            const localVarPath = this.basePath + '/project/projects/{id}/teamMembers'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdTeamMembersPost');
            }
            // verify required parameter 'teamMember' is set
            if (params.teamMember == null) {
                throw new Error('Missing required parameter teamMember when calling projectProjectsIdTeamMembersPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.teamMember),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Team Member By Id
         * @param id
         * @param teamMemberId
         */
        public projectProjectsIdTeamMembersTeamMemberIdDelete (params: {  id: number; teamMemberId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/project/projects/{id}/teamMembers/{teamMemberId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'teamMemberId' + '}', String(params.teamMemberId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdTeamMembersTeamMemberIdDelete');
            }
            // verify required parameter 'teamMemberId' is set
            if (params.teamMemberId == null) {
                throw new Error('Missing required parameter teamMemberId when calling projectProjectsIdTeamMembersTeamMemberIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Team Member By Id
         * @param id
         * @param teamMemberId
         */
        public projectProjectsIdTeamMembersTeamMemberIdGet (params: {  id: number; teamMemberId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectTeammember> {
            const localVarPath = this.basePath + '/project/projects/{id}/teamMembers/{teamMemberId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'teamMemberId' + '}', String(params.teamMemberId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdTeamMembersTeamMemberIdGet');
            }
            // verify required parameter 'teamMemberId' is set
            if (params.teamMemberId == null) {
                throw new Error('Missing required parameter teamMemberId when calling projectProjectsIdTeamMembersTeamMemberIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Team Member
         * @param id
         * @param teamMemberId
         * @param operations
         */
        public projectProjectsIdTeamMembersTeamMemberIdPatch (params: {  id: number; teamMemberId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectTeammember> {
            const localVarPath = this.basePath + '/project/projects/{id}/teamMembers/{teamMemberId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'teamMemberId' + '}', String(params.teamMemberId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdTeamMembersTeamMemberIdPatch');
            }
            // verify required parameter 'teamMemberId' is set
            if (params.teamMemberId == null) {
                throw new Error('Missing required parameter teamMemberId when calling projectProjectsIdTeamMembersTeamMemberIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling projectProjectsIdTeamMembersTeamMemberIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Team Member
         * @param id
         * @param teamMemberId
         * @param teamMember
         */
        public projectProjectsIdTeamMembersTeamMemberIdPut (params: {  id: number; teamMemberId: number; teamMember: ProjectTeammember; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectTeammember> {
            const localVarPath = this.basePath + '/project/projects/{id}/teamMembers/{teamMemberId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'teamMemberId' + '}', String(params.teamMemberId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling projectProjectsIdTeamMembersTeamMemberIdPut');
            }
            // verify required parameter 'teamMemberId' is set
            if (params.teamMemberId == null) {
                throw new Error('Missing required parameter teamMemberId when calling projectProjectsIdTeamMembersTeamMemberIdPut');
            }
            // verify required parameter 'teamMember' is set
            if (params.teamMember == null) {
                throw new Error('Missing required parameter teamMember when calling projectProjectsIdTeamMembersTeamMemberIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.teamMember),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PurchaseOrderLineItemsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Purchase Order Line Items Count
         * @param id
         * @param conditions
         */
        public procurementPurchaseordersIdLineitemsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/purchaseorders/{id}/lineitems/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseordersIdLineitemsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Purchase Order Line Items
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementPurchaseordersIdLineitemsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<PurchaseOrderLineItem>> {
            const localVarPath = this.basePath + '/procurement/purchaseorders/{id}/lineitems'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseordersIdLineitemsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Purchase Order Line Item By Id
         * @param id
         * @param lineItemId
         */
        public procurementPurchaseordersIdLineitemsLineItemIdDelete (params: {  id: number; lineItemId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/purchaseorders/{id}/lineitems/{lineItemId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'lineItemId' + '}', String(params.lineItemId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseordersIdLineitemsLineItemIdDelete');
            }
            // verify required parameter 'lineItemId' is set
            if (params.lineItemId == null) {
                throw new Error('Missing required parameter lineItemId when calling procurementPurchaseordersIdLineitemsLineItemIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Purchase Order Line Item By Id
         * @param id
         * @param lineItemId
         */
        public procurementPurchaseordersIdLineitemsLineItemIdGet (params: {  id: number; lineItemId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrderLineItem> {
            const localVarPath = this.basePath + '/procurement/purchaseorders/{id}/lineitems/{lineItemId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'lineItemId' + '}', String(params.lineItemId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseordersIdLineitemsLineItemIdGet');
            }
            // verify required parameter 'lineItemId' is set
            if (params.lineItemId == null) {
                throw new Error('Missing required parameter lineItemId when calling procurementPurchaseordersIdLineitemsLineItemIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Purchase Order Line Item
         * @param id
         * @param lineItemId
         * @param operations
         */
        public procurementPurchaseordersIdLineitemsLineItemIdPatch (params: {  id: number; lineItemId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrderLineItem> {
            const localVarPath = this.basePath + '/procurement/purchaseorders/{id}/lineitems/{lineItemId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'lineItemId' + '}', String(params.lineItemId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseordersIdLineitemsLineItemIdPatch');
            }
            // verify required parameter 'lineItemId' is set
            if (params.lineItemId == null) {
                throw new Error('Missing required parameter lineItemId when calling procurementPurchaseordersIdLineitemsLineItemIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementPurchaseordersIdLineitemsLineItemIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Purchase Order Line Item
         * @param id
         * @param lineItemId
         * @param purchaseOrderLineItem
         */
        public procurementPurchaseordersIdLineitemsLineItemIdPut (params: {  id: number; lineItemId: number; purchaseOrderLineItem: PurchaseOrderLineItem; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrderLineItem> {
            const localVarPath = this.basePath + '/procurement/purchaseorders/{id}/lineitems/{lineItemId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'lineItemId' + '}', String(params.lineItemId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseordersIdLineitemsLineItemIdPut');
            }
            // verify required parameter 'lineItemId' is set
            if (params.lineItemId == null) {
                throw new Error('Missing required parameter lineItemId when calling procurementPurchaseordersIdLineitemsLineItemIdPut');
            }
            // verify required parameter 'purchaseOrderLineItem' is set
            if (params.purchaseOrderLineItem == null) {
                throw new Error('Missing required parameter purchaseOrderLineItem when calling procurementPurchaseordersIdLineitemsLineItemIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.purchaseOrderLineItem),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Purchase Order Line Item
         * @param id
         * @param purchaseOrderLineItem
         */
        public procurementPurchaseordersIdLineitemsPost (params: {  id: number; purchaseOrderLineItem: PurchaseOrderLineItem; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrderLineItem> {
            const localVarPath = this.basePath + '/procurement/purchaseorders/{id}/lineitems'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseordersIdLineitemsPost');
            }
            // verify required parameter 'purchaseOrderLineItem' is set
            if (params.purchaseOrderLineItem == null) {
                throw new Error('Missing required parameter purchaseOrderLineItem when calling procurementPurchaseordersIdLineitemsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.purchaseOrderLineItem),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PurchaseOrderStatusEmailTemplatesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Purchase Order Status Email Templates Count
         * @param id
         * @param conditions
         */
        public procurementPurchaseorderstatusesIdEmailtemplatesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/purchaseorderstatuses/{id}/emailtemplates/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseorderstatusesIdEmailtemplatesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Purchase Order Status Email Template By Id
         * @param id
         * @param emailTemplateId
         */
        public procurementPurchaseorderstatusesIdEmailtemplatesEmailTemplateIdDelete (params: {  id: number; emailTemplateId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/purchaseorderstatuses/{id}/emailtemplates/{emailTemplateId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'emailTemplateId' + '}', String(params.emailTemplateId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseorderstatusesIdEmailtemplatesEmailTemplateIdDelete');
            }
            // verify required parameter 'emailTemplateId' is set
            if (params.emailTemplateId == null) {
                throw new Error('Missing required parameter emailTemplateId when calling procurementPurchaseorderstatusesIdEmailtemplatesEmailTemplateIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Purchase Order Status Email Template By Id
         * @param id
         * @param emailTemplateId
         */
        public procurementPurchaseorderstatusesIdEmailtemplatesEmailTemplateIdGet (params: {  id: number; emailTemplateId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrderStatusEmailTemplate> {
            const localVarPath = this.basePath + '/procurement/purchaseorderstatuses/{id}/emailtemplates/{emailTemplateId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'emailTemplateId' + '}', String(params.emailTemplateId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseorderstatusesIdEmailtemplatesEmailTemplateIdGet');
            }
            // verify required parameter 'emailTemplateId' is set
            if (params.emailTemplateId == null) {
                throw new Error('Missing required parameter emailTemplateId when calling procurementPurchaseorderstatusesIdEmailtemplatesEmailTemplateIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Purchase Order Status Email Template
         * @param id
         * @param emailTemplateId
         * @param operations
         */
        public procurementPurchaseorderstatusesIdEmailtemplatesEmailTemplateIdPatch (params: {  id: number; emailTemplateId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrderStatusEmailTemplate> {
            const localVarPath = this.basePath + '/procurement/purchaseorderstatuses/{id}/emailtemplates/{emailTemplateId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'emailTemplateId' + '}', String(params.emailTemplateId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseorderstatusesIdEmailtemplatesEmailTemplateIdPatch');
            }
            // verify required parameter 'emailTemplateId' is set
            if (params.emailTemplateId == null) {
                throw new Error('Missing required parameter emailTemplateId when calling procurementPurchaseorderstatusesIdEmailtemplatesEmailTemplateIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementPurchaseorderstatusesIdEmailtemplatesEmailTemplateIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Purchase Order Status Email Template
         * @param id
         * @param emailTemplateId
         * @param purchaseOrderStatusEmailTemplate
         */
        public procurementPurchaseorderstatusesIdEmailtemplatesEmailTemplateIdPut (params: {  id: number; emailTemplateId: number; purchaseOrderStatusEmailTemplate: PurchaseOrderStatusEmailTemplate; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrderStatusEmailTemplate> {
            const localVarPath = this.basePath + '/procurement/purchaseorderstatuses/{id}/emailtemplates/{emailTemplateId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'emailTemplateId' + '}', String(params.emailTemplateId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseorderstatusesIdEmailtemplatesEmailTemplateIdPut');
            }
            // verify required parameter 'emailTemplateId' is set
            if (params.emailTemplateId == null) {
                throw new Error('Missing required parameter emailTemplateId when calling procurementPurchaseorderstatusesIdEmailtemplatesEmailTemplateIdPut');
            }
            // verify required parameter 'purchaseOrderStatusEmailTemplate' is set
            if (params.purchaseOrderStatusEmailTemplate == null) {
                throw new Error('Missing required parameter purchaseOrderStatusEmailTemplate when calling procurementPurchaseorderstatusesIdEmailtemplatesEmailTemplateIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.purchaseOrderStatusEmailTemplate),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Purchase Order Status Email Templates
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementPurchaseorderstatusesIdEmailtemplatesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<PurchaseOrderStatusEmailTemplate>> {
            const localVarPath = this.basePath + '/procurement/purchaseorderstatuses/{id}/emailtemplates'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseorderstatusesIdEmailtemplatesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Purchase Order Status Email Template
         * @param id
         * @param purchaseOrderStatusEmailTemplate
         */
        public procurementPurchaseorderstatusesIdEmailtemplatesPost (params: {  id: number; purchaseOrderStatusEmailTemplate: PurchaseOrderStatusEmailTemplate; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrderStatusEmailTemplate> {
            const localVarPath = this.basePath + '/procurement/purchaseorderstatuses/{id}/emailtemplates'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseorderstatusesIdEmailtemplatesPost');
            }
            // verify required parameter 'purchaseOrderStatusEmailTemplate' is set
            if (params.purchaseOrderStatusEmailTemplate == null) {
                throw new Error('Missing required parameter purchaseOrderStatusEmailTemplate when calling procurementPurchaseorderstatusesIdEmailtemplatesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.purchaseOrderStatusEmailTemplate),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PurchaseOrderStatusNotificationsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Purchase Order Status Notifications Count
         * @param id
         * @param conditions
         */
        public procurementPurchaseorderstatusesIdNotificationsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/purchaseorderstatuses/{id}/notifications/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseorderstatusesIdNotificationsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Purchase Order Status Notifications
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementPurchaseorderstatusesIdNotificationsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<PurchaseOrderStatusNotification>> {
            const localVarPath = this.basePath + '/procurement/purchaseorderstatuses/{id}/notifications'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseorderstatusesIdNotificationsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Purchase Order Status Notification By Id
         * @param id
         * @param notificationId
         */
        public procurementPurchaseorderstatusesIdNotificationsNotificationIdDelete (params: {  id: number; notificationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/purchaseorderstatuses/{id}/notifications/{notificationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'notificationId' + '}', String(params.notificationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseorderstatusesIdNotificationsNotificationIdDelete');
            }
            // verify required parameter 'notificationId' is set
            if (params.notificationId == null) {
                throw new Error('Missing required parameter notificationId when calling procurementPurchaseorderstatusesIdNotificationsNotificationIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Purchase Order Status Notification By Id
         * @param id
         * @param notificationId
         */
        public procurementPurchaseorderstatusesIdNotificationsNotificationIdGet (params: {  id: number; notificationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrderStatusNotification> {
            const localVarPath = this.basePath + '/procurement/purchaseorderstatuses/{id}/notifications/{notificationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'notificationId' + '}', String(params.notificationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseorderstatusesIdNotificationsNotificationIdGet');
            }
            // verify required parameter 'notificationId' is set
            if (params.notificationId == null) {
                throw new Error('Missing required parameter notificationId when calling procurementPurchaseorderstatusesIdNotificationsNotificationIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Purchase Order Status Notification
         * @param id
         * @param notificationId
         * @param operations
         */
        public procurementPurchaseorderstatusesIdNotificationsNotificationIdPatch (params: {  id: number; notificationId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrderStatusNotification> {
            const localVarPath = this.basePath + '/procurement/purchaseorderstatuses/{id}/notifications/{notificationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'notificationId' + '}', String(params.notificationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseorderstatusesIdNotificationsNotificationIdPatch');
            }
            // verify required parameter 'notificationId' is set
            if (params.notificationId == null) {
                throw new Error('Missing required parameter notificationId when calling procurementPurchaseorderstatusesIdNotificationsNotificationIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementPurchaseorderstatusesIdNotificationsNotificationIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Purchase Order Status Notification
         * @param id
         * @param notificationId
         * @param purchaseOrderStatusNotification
         */
        public procurementPurchaseorderstatusesIdNotificationsNotificationIdPut (params: {  id: number; notificationId: number; purchaseOrderStatusNotification: PurchaseOrderStatusNotification; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrderStatusNotification> {
            const localVarPath = this.basePath + '/procurement/purchaseorderstatuses/{id}/notifications/{notificationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'notificationId' + '}', String(params.notificationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseorderstatusesIdNotificationsNotificationIdPut');
            }
            // verify required parameter 'notificationId' is set
            if (params.notificationId == null) {
                throw new Error('Missing required parameter notificationId when calling procurementPurchaseorderstatusesIdNotificationsNotificationIdPut');
            }
            // verify required parameter 'purchaseOrderStatusNotification' is set
            if (params.purchaseOrderStatusNotification == null) {
                throw new Error('Missing required parameter purchaseOrderStatusNotification when calling procurementPurchaseorderstatusesIdNotificationsNotificationIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.purchaseOrderStatusNotification),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Purchase Order Status Notification
         * @param id
         * @param purchaseOrderStatusNotification
         */
        public procurementPurchaseorderstatusesIdNotificationsPost (params: {  id: number; purchaseOrderStatusNotification: PurchaseOrderStatusNotification; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrderStatusNotification> {
            const localVarPath = this.basePath + '/procurement/purchaseorderstatuses/{id}/notifications'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseorderstatusesIdNotificationsPost');
            }
            // verify required parameter 'purchaseOrderStatusNotification' is set
            if (params.purchaseOrderStatusNotification == null) {
                throw new Error('Missing required parameter purchaseOrderStatusNotification when calling procurementPurchaseorderstatusesIdNotificationsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.purchaseOrderStatusNotification),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PurchaseOrderStatusesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Purchase Orders Statuses Count
         * @param conditions
         */
        public procurementPurchaseorderstatusesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/purchaseorderstatuses/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Purchase Order Statuses
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementPurchaseorderstatusesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<PurchaseOrderStatus>> {
            const localVarPath = this.basePath + '/procurement/purchaseorderstatuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Purchase Order Status
         * @param id
         */
        public procurementPurchaseorderstatusesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/purchaseorderstatuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseorderstatusesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Purchase Order Status By Id
         * @param id
         */
        public procurementPurchaseorderstatusesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrderStatus> {
            const localVarPath = this.basePath + '/procurement/purchaseorderstatuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseorderstatusesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Purchase Order Status
         * @param id
         * @param operations
         */
        public procurementPurchaseorderstatusesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrderStatus> {
            const localVarPath = this.basePath + '/procurement/purchaseorderstatuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseorderstatusesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementPurchaseorderstatusesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Purchase Order Status
         * @param id
         * @param purchaseOrderStatus
         */
        public procurementPurchaseorderstatusesIdPut (params: {  id: number; purchaseOrderStatus: PurchaseOrderStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrderStatus> {
            const localVarPath = this.basePath + '/procurement/purchaseorderstatuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseorderstatusesIdPut');
            }
            // verify required parameter 'purchaseOrderStatus' is set
            if (params.purchaseOrderStatus == null) {
                throw new Error('Missing required parameter purchaseOrderStatus when calling procurementPurchaseorderstatusesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.purchaseOrderStatus),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Purchase Order Status
         * @param poStatus
         */
        public procurementPurchaseorderstatusesPost (params: {  poStatus: PurchaseOrderStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrderStatus> {
            const localVarPath = this.basePath + '/procurement/purchaseorderstatuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'poStatus' is set
            if (params.poStatus == null) {
                throw new Error('Missing required parameter poStatus when calling procurementPurchaseorderstatusesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.poStatus),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PurchaseOrdersApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Purchase Orders Count
         * @param conditions
         */
        public procurementPurchaseordersCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/purchaseorders/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Purchase Orders
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementPurchaseordersGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<PurchaseOrder>> {
            const localVarPath = this.basePath + '/procurement/purchaseorders';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Purchase Order By Id
         * @param id
         */
        public procurementPurchaseordersIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/purchaseorders/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseordersIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Purchase Order By Id
         * @param id
         */
        public procurementPurchaseordersIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrder> {
            const localVarPath = this.basePath + '/procurement/purchaseorders/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseordersIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Purchase Order
         * @param id
         * @param operations
         */
        public procurementPurchaseordersIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrder> {
            const localVarPath = this.basePath + '/procurement/purchaseorders/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseordersIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementPurchaseordersIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Purchase Order
         * @param id
         * @param purchaseOrder
         */
        public procurementPurchaseordersIdPut (params: {  id: number; purchaseOrder: PurchaseOrder; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrder> {
            const localVarPath = this.basePath + '/procurement/purchaseorders/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementPurchaseordersIdPut');
            }
            // verify required parameter 'purchaseOrder' is set
            if (params.purchaseOrder == null) {
                throw new Error('Missing required parameter purchaseOrder when calling procurementPurchaseordersIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.purchaseOrder),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Purchase Order
         * @param purchaseOrder
         */
        public procurementPurchaseordersPost (params: {  purchaseOrder: PurchaseOrder; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrder> {
            const localVarPath = this.basePath + '/procurement/purchaseorders';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'purchaseOrder' is set
            if (params.purchaseOrder == null) {
                throw new Error('Missing required parameter purchaseOrder when calling procurementPurchaseordersPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.purchaseOrder),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class RMAActionsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get R M A Action Count
         * @param conditions
         */
        public procurementRmaActionsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/rmaActions/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get R M A Action
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementRmaActionsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<RMAAction>> {
            const localVarPath = this.basePath + '/procurement/rmaActions';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete R M A Action By Id
         * @param id
         */
        public procurementRmaActionsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/rmaActions/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementRmaActionsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get R M A Action By Id
         * @param id
         */
        public procurementRmaActionsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<RMAAction> {
            const localVarPath = this.basePath + '/procurement/rmaActions/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementRmaActionsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update R M A Action
         * @param id
         * @param operations
         */
        public procurementRmaActionsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<RMAAction> {
            const localVarPath = this.basePath + '/procurement/rmaActions/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementRmaActionsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementRmaActionsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace R M A Action
         * @param id
         * @param rmaAction
         */
        public procurementRmaActionsIdPut (params: {  id: number; rmaAction: RMAAction; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<RMAAction> {
            const localVarPath = this.basePath + '/procurement/rmaActions/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementRmaActionsIdPut');
            }
            // verify required parameter 'rmaAction' is set
            if (params.rmaAction == null) {
                throw new Error('Missing required parameter rmaAction when calling procurementRmaActionsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.rmaAction),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create R M A Action
         * @param rmaAction
         */
        public procurementRmaActionsPost (params: {  rmaAction: RMAAction; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<RMAAction> {
            const localVarPath = this.basePath + '/procurement/rmaActions';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'rmaAction' is set
            if (params.rmaAction == null) {
                throw new Error('Missing required parameter rmaAction when calling procurementRmaActionsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.rmaAction),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class RMADispositionsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get R M A Disposition Count
         * @param conditions
         */
        public procurementRMADispositionsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/RMADispositions/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get R M A Disposition
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementRMADispositionsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<RMADisposition>> {
            const localVarPath = this.basePath + '/procurement/RMADispositions';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete R M A Disposition By Id
         * @param id
         */
        public procurementRMADispositionsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/RMADispositions/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementRMADispositionsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get R M A Disposition By Id
         * @param id
         */
        public procurementRMADispositionsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<RMADisposition> {
            const localVarPath = this.basePath + '/procurement/RMADispositions/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementRMADispositionsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update R M A Disposition
         * @param id
         * @param operations
         */
        public procurementRMADispositionsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<RMADisposition> {
            const localVarPath = this.basePath + '/procurement/RMADispositions/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementRMADispositionsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementRMADispositionsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace R M A Disposition
         * @param id
         * @param rmaDisposition
         */
        public procurementRMADispositionsIdPut (params: {  id: number; rmaDisposition: RMADisposition; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<RMADisposition> {
            const localVarPath = this.basePath + '/procurement/RMADispositions/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementRMADispositionsIdPut');
            }
            // verify required parameter 'rmaDisposition' is set
            if (params.rmaDisposition == null) {
                throw new Error('Missing required parameter rmaDisposition when calling procurementRMADispositionsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.rmaDisposition),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create R M A Disposition
         * @param rmaDisposition
         */
        public procurementRMADispositionsPost (params: {  rmaDisposition: RMADisposition; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<RMADisposition> {
            const localVarPath = this.basePath + '/procurement/RMADispositions';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'rmaDisposition' is set
            if (params.rmaDisposition == null) {
                throw new Error('Missing required parameter rmaDisposition when calling procurementRMADispositionsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.rmaDisposition),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ReportCardDetailsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Report Card Detail Count
         * @param id
         * @param conditions
         */
        public systemReportCardsIdDetailsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/reportCards/{id}/details/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemReportCardsIdDetailsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Report Card Detail By Id
         * @param id
         * @param detailId
         */
        public systemReportCardsIdDetailsDetailIdDelete (params: {  id: number; detailId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/reportCards/{id}/details/{detailId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'detailId' + '}', String(params.detailId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemReportCardsIdDetailsDetailIdDelete');
            }
            // verify required parameter 'detailId' is set
            if (params.detailId == null) {
                throw new Error('Missing required parameter detailId when calling systemReportCardsIdDetailsDetailIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Report Card Detail By Id
         * @param id
         * @param detailId
         */
        public systemReportCardsIdDetailsDetailIdGet (params: {  id: number; detailId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ReportCardDetail> {
            const localVarPath = this.basePath + '/system/reportCards/{id}/details/{detailId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'detailId' + '}', String(params.detailId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemReportCardsIdDetailsDetailIdGet');
            }
            // verify required parameter 'detailId' is set
            if (params.detailId == null) {
                throw new Error('Missing required parameter detailId when calling systemReportCardsIdDetailsDetailIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Report Card Detail
         * @param id
         * @param detailId
         * @param operations
         */
        public systemReportCardsIdDetailsDetailIdPatch (params: {  id: number; detailId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ReportCardDetail> {
            const localVarPath = this.basePath + '/system/reportCards/{id}/details/{detailId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'detailId' + '}', String(params.detailId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemReportCardsIdDetailsDetailIdPatch');
            }
            // verify required parameter 'detailId' is set
            if (params.detailId == null) {
                throw new Error('Missing required parameter detailId when calling systemReportCardsIdDetailsDetailIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemReportCardsIdDetailsDetailIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Report Card Detail
         * @param id
         * @param detailId
         * @param reportCardDetail
         */
        public systemReportCardsIdDetailsDetailIdPut (params: {  id: number; detailId: number; reportCardDetail: ReportCardDetail; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ReportCardDetail> {
            const localVarPath = this.basePath + '/system/reportCards/{id}/details/{detailId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'detailId' + '}', String(params.detailId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemReportCardsIdDetailsDetailIdPut');
            }
            // verify required parameter 'detailId' is set
            if (params.detailId == null) {
                throw new Error('Missing required parameter detailId when calling systemReportCardsIdDetailsDetailIdPut');
            }
            // verify required parameter 'reportCardDetail' is set
            if (params.reportCardDetail == null) {
                throw new Error('Missing required parameter reportCardDetail when calling systemReportCardsIdDetailsDetailIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.reportCardDetail),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Report Card Detail
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemReportCardsIdDetailsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ReportCardDetail>> {
            const localVarPath = this.basePath + '/system/reportCards/{id}/details'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemReportCardsIdDetailsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Report Card Detail
         * @param id
         * @param reportCardDetail
         */
        public systemReportCardsIdDetailsPost (params: {  id: number; reportCardDetail: ReportCardDetail; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ReportCardDetail> {
            const localVarPath = this.basePath + '/system/reportCards/{id}/details'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemReportCardsIdDetailsPost');
            }
            // verify required parameter 'reportCardDetail' is set
            if (params.reportCardDetail == null) {
                throw new Error('Missing required parameter reportCardDetail when calling systemReportCardsIdDetailsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.reportCardDetail),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ReportCardsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Report Card Count
         * @param conditions
         */
        public systemReportCardsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/reportCards/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Report Card
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemReportCardsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ReportCard>> {
            const localVarPath = this.basePath + '/system/reportCards';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Report Card By Id
         * @param id
         */
        public systemReportCardsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/reportCards/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemReportCardsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Report Card By Id
         * @param id
         */
        public systemReportCardsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ReportCard> {
            const localVarPath = this.basePath + '/system/reportCards/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemReportCardsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Report Card
         * @param id
         * @param operations
         */
        public systemReportCardsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ReportCard> {
            const localVarPath = this.basePath + '/system/reportCards/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemReportCardsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemReportCardsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Report Card
         * @param id
         * @param reportCard
         */
        public systemReportCardsIdPut (params: {  id: number; reportCard: ReportCard; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ReportCard> {
            const localVarPath = this.basePath + '/system/reportCards/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemReportCardsIdPut');
            }
            // verify required parameter 'reportCard' is set
            if (params.reportCard == null) {
                throw new Error('Missing required parameter reportCard when calling systemReportCardsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.reportCard),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Report Card
         * @param reportCard
         */
        public systemReportCardsPost (params: {  reportCard: ReportCard; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ReportCard> {
            const localVarPath = this.basePath + '/system/reportCards';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'reportCard' is set
            if (params.reportCard == null) {
                throw new Error('Missing required parameter reportCard when calling systemReportCardsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.reportCard),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ReportingServicesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Reporting Services
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemMycompanyReportingServicesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ReportingService>> {
            const localVarPath = this.basePath + '/system/mycompany/reportingServices';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Reporting Service By Id
         * @param id
         */
        public systemMycompanyReportingServicesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ReportingService> {
            const localVarPath = this.basePath + '/system/mycompany/reportingServices/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMycompanyReportingServicesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Reporting Service
         * @param id
         * @param operations
         */
        public systemMycompanyReportingServicesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ReportingService> {
            const localVarPath = this.basePath + '/system/mycompany/reportingServices/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMycompanyReportingServicesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemMycompanyReportingServicesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Reporting Service
         * @param id
         * @param service
         */
        public systemMycompanyReportingServicesIdPut (params: {  id: number; service: ReportingService; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ReportingService> {
            const localVarPath = this.basePath + '/system/mycompany/reportingServices/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMycompanyReportingServicesIdPut');
            }
            // verify required parameter 'service' is set
            if (params.service == null) {
                throw new Error('Missing required parameter service when calling systemMycompanyReportingServicesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.service),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Test Reporting Service Connection
         * @param id
         */
        public systemMycompanyReportingServicesIdTestConnectionPost (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SuccessResponse> {
            const localVarPath = this.basePath + '/system/mycompany/reportingServices/{id}/testConnection'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMycompanyReportingServicesIdTestConnectionPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ReportsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Reports
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         */
        public systemReportsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Report>> {
            const localVarPath = this.basePath + '/system/reports';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Column Definitions
         * @param reportName
         */
        public systemReportsReportNameColumnsGet (params: {  reportName: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<JObject>> {
            const localVarPath = this.basePath + '/system/reports/{reportName}/columns'
                .replace('{' + 'reportName' + '}', String(params.reportName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'reportName' is set
            if (params.reportName == null) {
                throw new Error('Missing required parameter reportName when calling systemReportsReportNameColumnsGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Report Results Count
         * @param reportName
         * @param conditions
         */
        public systemReportsReportNameCountGet (params: {  reportName: string; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/reports/{reportName}/count'
                .replace('{' + 'reportName' + '}', String(params.reportName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'reportName' is set
            if (params.reportName == null) {
                throw new Error('Missing required parameter reportName when calling systemReportsReportNameCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Report Results
         * @param reportName
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         * @param columns
         */
        public systemReportsReportNameGet (params: {  reportName: string; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; columns?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ReportDataResponse> {
            const localVarPath = this.basePath + '/system/reports/{reportName}'
                .replace('{' + 'reportName' + '}', String(params.reportName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'reportName' is set
            if (params.reportName == null) {
                throw new Error('Missing required parameter reportName when calling systemReportsReportNameGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            if (params.columns !== undefined) {
                queryParameters['columns'] = params.columns;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class RmaStatusEmailTemplatesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Rma Status Email Templates
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementRmaStatusesIdEmailTemplatesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<RmaStatusEmailTemplate>> {
            const localVarPath = this.basePath + '/procurement/rmaStatuses/{id}/emailTemplates'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementRmaStatusesIdEmailTemplatesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Rma Status Email Templates Count
         * @param id
         * @param conditions
         */
        public procurementRmaStatusesIdEmailtemplatesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/rmaStatuses/{id}/emailtemplates/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementRmaStatusesIdEmailtemplatesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Rma Status Email Template By Id
         * @param id
         * @param emailTemplateId
         */
        public procurementRmaStatusesIdEmailtemplatesEmailTemplateIdDelete (params: {  id: number; emailTemplateId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/rmaStatuses/{id}/emailtemplates/{emailTemplateId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'emailTemplateId' + '}', String(params.emailTemplateId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementRmaStatusesIdEmailtemplatesEmailTemplateIdDelete');
            }
            // verify required parameter 'emailTemplateId' is set
            if (params.emailTemplateId == null) {
                throw new Error('Missing required parameter emailTemplateId when calling procurementRmaStatusesIdEmailtemplatesEmailTemplateIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Rma Status Email Template By Id
         * @param id
         * @param emailTemplateId
         */
        public procurementRmaStatusesIdEmailtemplatesEmailTemplateIdGet (params: {  id: number; emailTemplateId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<RmaStatusEmailTemplate> {
            const localVarPath = this.basePath + '/procurement/rmaStatuses/{id}/emailtemplates/{emailTemplateId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'emailTemplateId' + '}', String(params.emailTemplateId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementRmaStatusesIdEmailtemplatesEmailTemplateIdGet');
            }
            // verify required parameter 'emailTemplateId' is set
            if (params.emailTemplateId == null) {
                throw new Error('Missing required parameter emailTemplateId when calling procurementRmaStatusesIdEmailtemplatesEmailTemplateIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Rma Status Email Template
         * @param id
         * @param emailTemplateId
         * @param operations
         */
        public procurementRmaStatusesIdEmailtemplatesEmailTemplateIdPatch (params: {  id: number; emailTemplateId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<RmaStatusEmailTemplate> {
            const localVarPath = this.basePath + '/procurement/rmaStatuses/{id}/emailtemplates/{emailTemplateId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'emailTemplateId' + '}', String(params.emailTemplateId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementRmaStatusesIdEmailtemplatesEmailTemplateIdPatch');
            }
            // verify required parameter 'emailTemplateId' is set
            if (params.emailTemplateId == null) {
                throw new Error('Missing required parameter emailTemplateId when calling procurementRmaStatusesIdEmailtemplatesEmailTemplateIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementRmaStatusesIdEmailtemplatesEmailTemplateIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Rma Status Email Template
         * @param id
         * @param emailTemplateId
         * @param rmaStatusEmailTemplate
         */
        public procurementRmaStatusesIdEmailtemplatesEmailTemplateIdPut (params: {  id: number; emailTemplateId: number; rmaStatusEmailTemplate: RmaStatusEmailTemplate; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<RmaStatusEmailTemplate> {
            const localVarPath = this.basePath + '/procurement/rmaStatuses/{id}/emailtemplates/{emailTemplateId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'emailTemplateId' + '}', String(params.emailTemplateId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementRmaStatusesIdEmailtemplatesEmailTemplateIdPut');
            }
            // verify required parameter 'emailTemplateId' is set
            if (params.emailTemplateId == null) {
                throw new Error('Missing required parameter emailTemplateId when calling procurementRmaStatusesIdEmailtemplatesEmailTemplateIdPut');
            }
            // verify required parameter 'rmaStatusEmailTemplate' is set
            if (params.rmaStatusEmailTemplate == null) {
                throw new Error('Missing required parameter rmaStatusEmailTemplate when calling procurementRmaStatusesIdEmailtemplatesEmailTemplateIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.rmaStatusEmailTemplate),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Rma Status Email Template
         * @param id
         * @param rmaStatusEmailTemplate
         */
        public procurementRmaStatusesIdEmailtemplatesPost (params: {  id: number; rmaStatusEmailTemplate: RmaStatusEmailTemplate; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<RmaStatusEmailTemplate> {
            const localVarPath = this.basePath + '/procurement/rmaStatuses/{id}/emailtemplates'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementRmaStatusesIdEmailtemplatesPost');
            }
            // verify required parameter 'rmaStatusEmailTemplate' is set
            if (params.rmaStatusEmailTemplate == null) {
                throw new Error('Missing required parameter rmaStatusEmailTemplate when calling procurementRmaStatusesIdEmailtemplatesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.rmaStatusEmailTemplate),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class RmaStatusNotificationsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Rma Status Notifications Count
         * @param id
         * @param conditions
         */
        public procurementRmaStatusesIdNotificationsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/rmaStatuses/{id}/notifications/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementRmaStatusesIdNotificationsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Rma Status Notifications
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementRmaStatusesIdNotificationsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<RmaStatusNotification>> {
            const localVarPath = this.basePath + '/procurement/rmaStatuses/{id}/notifications'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementRmaStatusesIdNotificationsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Rma Status Notification By Id
         * @param id
         * @param notificationId
         */
        public procurementRmaStatusesIdNotificationsNotificationIdDelete (params: {  id: number; notificationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/rmaStatuses/{id}/notifications/{notificationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'notificationId' + '}', String(params.notificationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementRmaStatusesIdNotificationsNotificationIdDelete');
            }
            // verify required parameter 'notificationId' is set
            if (params.notificationId == null) {
                throw new Error('Missing required parameter notificationId when calling procurementRmaStatusesIdNotificationsNotificationIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Rma Status Notification By Id
         * @param id
         * @param notificationId
         */
        public procurementRmaStatusesIdNotificationsNotificationIdGet (params: {  id: number; notificationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<RmaStatusNotification> {
            const localVarPath = this.basePath + '/procurement/rmaStatuses/{id}/notifications/{notificationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'notificationId' + '}', String(params.notificationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementRmaStatusesIdNotificationsNotificationIdGet');
            }
            // verify required parameter 'notificationId' is set
            if (params.notificationId == null) {
                throw new Error('Missing required parameter notificationId when calling procurementRmaStatusesIdNotificationsNotificationIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Rma Status Notification
         * @param id
         * @param notificationId
         * @param operations
         */
        public procurementRmaStatusesIdNotificationsNotificationIdPatch (params: {  id: number; notificationId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<RmaStatusNotification> {
            const localVarPath = this.basePath + '/procurement/rmaStatuses/{id}/notifications/{notificationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'notificationId' + '}', String(params.notificationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementRmaStatusesIdNotificationsNotificationIdPatch');
            }
            // verify required parameter 'notificationId' is set
            if (params.notificationId == null) {
                throw new Error('Missing required parameter notificationId when calling procurementRmaStatusesIdNotificationsNotificationIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementRmaStatusesIdNotificationsNotificationIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Rma Status Notification
         * @param id
         * @param notificationId
         * @param rmaStatusNotification
         */
        public procurementRmaStatusesIdNotificationsNotificationIdPut (params: {  id: number; notificationId: number; rmaStatusNotification: RmaStatusNotification; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<RmaStatusNotification> {
            const localVarPath = this.basePath + '/procurement/rmaStatuses/{id}/notifications/{notificationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'notificationId' + '}', String(params.notificationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementRmaStatusesIdNotificationsNotificationIdPut');
            }
            // verify required parameter 'notificationId' is set
            if (params.notificationId == null) {
                throw new Error('Missing required parameter notificationId when calling procurementRmaStatusesIdNotificationsNotificationIdPut');
            }
            // verify required parameter 'rmaStatusNotification' is set
            if (params.rmaStatusNotification == null) {
                throw new Error('Missing required parameter rmaStatusNotification when calling procurementRmaStatusesIdNotificationsNotificationIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.rmaStatusNotification),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Rma Status Notification
         * @param id
         * @param rmaStatusNotification
         */
        public procurementRmaStatusesIdNotificationsPost (params: {  id: number; rmaStatusNotification: RmaStatusNotification; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<RmaStatusNotification> {
            const localVarPath = this.basePath + '/procurement/rmaStatuses/{id}/notifications'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementRmaStatusesIdNotificationsPost');
            }
            // verify required parameter 'rmaStatusNotification' is set
            if (params.rmaStatusNotification == null) {
                throw new Error('Missing required parameter rmaStatusNotification when calling procurementRmaStatusesIdNotificationsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.rmaStatusNotification),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class RmaStatusesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Rma Statuses Count
         * @param conditions
         */
        public procurementRmaStatusesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/rmaStatuses/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Rma Statuses
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementRmaStatusesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<RmaStatus>> {
            const localVarPath = this.basePath + '/procurement/rmaStatuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Rma Status By Id
         * @param id
         */
        public procurementRmaStatusesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/rmaStatuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementRmaStatusesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Rma Status By Id
         * @param id
         */
        public procurementRmaStatusesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<RmaStatus> {
            const localVarPath = this.basePath + '/procurement/rmaStatuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementRmaStatusesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Rma Status
         * @param id
         * @param operations
         */
        public procurementRmaStatusesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<RmaStatus> {
            const localVarPath = this.basePath + '/procurement/rmaStatuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementRmaStatusesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementRmaStatusesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Rma Status
         * @param id
         * @param rmaStatus
         */
        public procurementRmaStatusesIdPut (params: {  id: number; rmaStatus: RmaStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<RmaStatus> {
            const localVarPath = this.basePath + '/procurement/rmaStatuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementRmaStatusesIdPut');
            }
            // verify required parameter 'rmaStatus' is set
            if (params.rmaStatus == null) {
                throw new Error('Missing required parameter rmaStatus when calling procurementRmaStatusesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.rmaStatus),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Rma Status
         * @param rmaStatus
         */
        public procurementRmaStatusesPost (params: {  rmaStatus: RmaStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<RmaStatus> {
            const localVarPath = this.basePath + '/procurement/rmaStatuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'rmaStatus' is set
            if (params.rmaStatus == null) {
                throw new Error('Missing required parameter rmaStatus when calling procurementRmaStatusesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.rmaStatus),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class RolesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Role Count
         * @param conditions
         */
        public salesRolesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/sales/roles/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Role
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public salesRolesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Role>> {
            const localVarPath = this.basePath + '/sales/roles';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Role By Id
         * @param id
         */
        public salesRolesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/sales/roles/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesRolesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Role By Id
         * @param id
         */
        public salesRolesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Role> {
            const localVarPath = this.basePath + '/sales/roles/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesRolesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Role
         * @param id
         * @param operations
         */
        public salesRolesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Role> {
            const localVarPath = this.basePath + '/sales/roles/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesRolesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling salesRolesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Role
         * @param id
         * @param role
         */
        public salesRolesIdPut (params: {  id: number; role: Role; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Role> {
            const localVarPath = this.basePath + '/sales/roles/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesRolesIdPut');
            }
            // verify required parameter 'role' is set
            if (params.role == null) {
                throw new Error('Missing required parameter role when calling salesRolesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.role),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Role
         * @param role
         */
        public salesRolesPost (params: {  role: Role; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Role> {
            const localVarPath = this.basePath + '/sales/roles';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'role' is set
            if (params.role == null) {
                throw new Error('Missing required parameter role when calling salesRolesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.role),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SLAPrioritiesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get S L A Priority Count
         * @param id
         * @param conditions
         */
        public serviceSLAsIdPrioritiesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/SLAs/{id}/priorities/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSLAsIdPrioritiesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get S L A Priority
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceSLAsIdPrioritiesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<SLAPriority>> {
            const localVarPath = this.basePath + '/service/SLAs/{id}/priorities'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSLAsIdPrioritiesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create S L A Priority
         * @param id
         * @param slaPriority
         */
        public serviceSLAsIdPrioritiesPost (params: {  id: number; slaPriority: SLAPriority; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SLAPriority> {
            const localVarPath = this.basePath + '/service/SLAs/{id}/priorities'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSLAsIdPrioritiesPost');
            }
            // verify required parameter 'slaPriority' is set
            if (params.slaPriority == null) {
                throw new Error('Missing required parameter slaPriority when calling serviceSLAsIdPrioritiesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.slaPriority),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete S L A Priority By Id
         * @param id
         * @param priorityId
         */
        public serviceSLAsIdPrioritiesPriorityIdDelete (params: {  id: number; priorityId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/SLAs/{id}/priorities/{priorityId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'priorityId' + '}', String(params.priorityId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSLAsIdPrioritiesPriorityIdDelete');
            }
            // verify required parameter 'priorityId' is set
            if (params.priorityId == null) {
                throw new Error('Missing required parameter priorityId when calling serviceSLAsIdPrioritiesPriorityIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get S L A Priority By Id
         * @param id
         * @param priorityId
         */
        public serviceSLAsIdPrioritiesPriorityIdGet (params: {  id: number; priorityId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SLAPriority> {
            const localVarPath = this.basePath + '/service/SLAs/{id}/priorities/{priorityId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'priorityId' + '}', String(params.priorityId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSLAsIdPrioritiesPriorityIdGet');
            }
            // verify required parameter 'priorityId' is set
            if (params.priorityId == null) {
                throw new Error('Missing required parameter priorityId when calling serviceSLAsIdPrioritiesPriorityIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update S L A Priority
         * @param id
         * @param priorityId
         * @param operations
         */
        public serviceSLAsIdPrioritiesPriorityIdPatch (params: {  id: number; priorityId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SLAPriority> {
            const localVarPath = this.basePath + '/service/SLAs/{id}/priorities/{priorityId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'priorityId' + '}', String(params.priorityId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSLAsIdPrioritiesPriorityIdPatch');
            }
            // verify required parameter 'priorityId' is set
            if (params.priorityId == null) {
                throw new Error('Missing required parameter priorityId when calling serviceSLAsIdPrioritiesPriorityIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceSLAsIdPrioritiesPriorityIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace S L A Priority
         * @param id
         * @param priorityId
         * @param slaPriority
         */
        public serviceSLAsIdPrioritiesPriorityIdPut (params: {  id: number; priorityId: number; slaPriority: SLAPriority; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SLAPriority> {
            const localVarPath = this.basePath + '/service/SLAs/{id}/priorities/{priorityId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'priorityId' + '}', String(params.priorityId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSLAsIdPrioritiesPriorityIdPut');
            }
            // verify required parameter 'priorityId' is set
            if (params.priorityId == null) {
                throw new Error('Missing required parameter priorityId when calling serviceSLAsIdPrioritiesPriorityIdPut');
            }
            // verify required parameter 'slaPriority' is set
            if (params.slaPriority == null) {
                throw new Error('Missing required parameter slaPriority when calling serviceSLAsIdPrioritiesPriorityIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.slaPriority),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SLAsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get S L A Count
         * @param conditions
         */
        public serviceSLAsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/SLAs/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get S L A
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceSLAsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<SLA>> {
            const localVarPath = this.basePath + '/service/SLAs';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete S L A By Id
         * @param id
         */
        public serviceSLAsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/SLAs/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSLAsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get S L A By Id
         * @param id
         */
        public serviceSLAsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SLA> {
            const localVarPath = this.basePath + '/service/SLAs/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSLAsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update S L A
         * @param id
         * @param operations
         */
        public serviceSLAsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SLA> {
            const localVarPath = this.basePath + '/service/SLAs/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSLAsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceSLAsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace S L A
         * @param id
         * @param sLA
         */
        public serviceSLAsIdPut (params: {  id: number; sLA: SLA; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SLA> {
            const localVarPath = this.basePath + '/service/SLAs/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSLAsIdPut');
            }
            // verify required parameter 'sLA' is set
            if (params.sLA == null) {
                throw new Error('Missing required parameter sLA when calling serviceSLAsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.sLA),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create S L A
         * @param sLA
         */
        public serviceSLAsPost (params: {  sLA: SLA; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SLA> {
            const localVarPath = this.basePath + '/service/SLAs';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'sLA' is set
            if (params.sLA == null) {
                throw new Error('Missing required parameter sLA when calling serviceSLAsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.sLA),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SalesProbabilitiesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Probabilities Count
         * @param conditions
         */
        public salesProbabilitiesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/sales/probabilities/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Probabilities
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public salesProbabilitiesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<SalesProbability>> {
            const localVarPath = this.basePath + '/sales/probabilities';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Probability By Id
         * @param id
         */
        public salesProbabilitiesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/sales/probabilities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesProbabilitiesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Probability By Id
         * @param id
         */
        public salesProbabilitiesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SalesProbability> {
            const localVarPath = this.basePath + '/sales/probabilities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesProbabilitiesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Probability
         * @param id
         * @param operations
         */
        public salesProbabilitiesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SalesProbability> {
            const localVarPath = this.basePath + '/sales/probabilities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesProbabilitiesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling salesProbabilitiesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Probability
         * @param id
         * @param probability
         */
        public salesProbabilitiesIdPut (params: {  id: number; probability: SalesProbability; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SalesProbability> {
            const localVarPath = this.basePath + '/sales/probabilities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesProbabilitiesIdPut');
            }
            // verify required parameter 'probability' is set
            if (params.probability == null) {
                throw new Error('Missing required parameter probability when calling salesProbabilitiesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.probability),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Probability
         * @param probability
         */
        public salesProbabilitiesPost (params: {  probability: SalesProbability; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SalesProbability> {
            const localVarPath = this.basePath + '/sales/probabilities';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'probability' is set
            if (params.probability == null) {
                throw new Error('Missing required parameter probability when calling salesProbabilitiesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.probability),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SalesQuotasApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Sales Quota Count
         * @param conditions
         */
        public salesQuotasCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/sales/quotas/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Sales Quota
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public salesQuotasGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<SalesQuota>> {
            const localVarPath = this.basePath + '/sales/quotas';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Sales Quota By Id
         * @param id
         */
        public salesQuotasIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/sales/quotas/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesQuotasIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Sales Quota By Id
         * @param id
         */
        public salesQuotasIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SalesQuota> {
            const localVarPath = this.basePath + '/sales/quotas/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesQuotasIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Sales Quota
         * @param id
         * @param operations
         */
        public salesQuotasIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SalesQuota> {
            const localVarPath = this.basePath + '/sales/quotas/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesQuotasIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling salesQuotasIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Sales Quota
         * @param id
         * @param salesQuota
         */
        public salesQuotasIdPut (params: {  id: number; salesQuota: SalesQuota; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SalesQuota> {
            const localVarPath = this.basePath + '/sales/quotas/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling salesQuotasIdPut');
            }
            // verify required parameter 'salesQuota' is set
            if (params.salesQuota == null) {
                throw new Error('Missing required parameter salesQuota when calling salesQuotasIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.salesQuota),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Sales Quota
         * @param salesQuota
         */
        public salesQuotasPost (params: {  salesQuota: SalesQuota; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SalesQuota> {
            const localVarPath = this.basePath + '/sales/quotas';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'salesQuota' is set
            if (params.salesQuota == null) {
                throw new Error('Missing required parameter salesQuota when calling salesQuotasPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.salesQuota),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SalesTeamMembersApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Sales Team Members Count
         * @param id
         * @param conditions
         */
        public systemSalesTeamsIdMembersCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/salesTeams/{id}/members/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSalesTeamsIdMembersCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Sales Team Members
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemSalesTeamsIdMembersGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<SalesTeamMember>> {
            const localVarPath = this.basePath + '/system/salesTeams/{id}/members'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSalesTeamsIdMembersGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Sales Team Member
         * @param id
         * @param salesTeamMember
         */
        public systemSalesTeamsIdMembersPost (params: {  id: number; salesTeamMember: SalesTeamMember; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SalesTeamMember> {
            const localVarPath = this.basePath + '/system/salesTeams/{id}/members'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSalesTeamsIdMembersPost');
            }
            // verify required parameter 'salesTeamMember' is set
            if (params.salesTeamMember == null) {
                throw new Error('Missing required parameter salesTeamMember when calling systemSalesTeamsIdMembersPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.salesTeamMember),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Sales Team Member By Id
         * @param id
         * @param salesTeamMemberId
         */
        public systemSalesTeamsIdMembersSalesTeamMemberIdDelete (params: {  id: number; salesTeamMemberId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/salesTeams/{id}/members/{salesTeamMemberId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'salesTeamMemberId' + '}', String(params.salesTeamMemberId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSalesTeamsIdMembersSalesTeamMemberIdDelete');
            }
            // verify required parameter 'salesTeamMemberId' is set
            if (params.salesTeamMemberId == null) {
                throw new Error('Missing required parameter salesTeamMemberId when calling systemSalesTeamsIdMembersSalesTeamMemberIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Sales Team Member By Id
         * @param id
         * @param salesTeamMemberId
         */
        public systemSalesTeamsIdMembersSalesTeamMemberIdGet (params: {  id: number; salesTeamMemberId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SalesTeamMember> {
            const localVarPath = this.basePath + '/system/salesTeams/{id}/members/{salesTeamMemberId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'salesTeamMemberId' + '}', String(params.salesTeamMemberId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSalesTeamsIdMembersSalesTeamMemberIdGet');
            }
            // verify required parameter 'salesTeamMemberId' is set
            if (params.salesTeamMemberId == null) {
                throw new Error('Missing required parameter salesTeamMemberId when calling systemSalesTeamsIdMembersSalesTeamMemberIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Sales Team Member
         * @param id
         * @param salesTeamMemberId
         * @param operations
         */
        public systemSalesTeamsIdMembersSalesTeamMemberIdPatch (params: {  id: number; salesTeamMemberId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SalesTeamMember> {
            const localVarPath = this.basePath + '/system/salesTeams/{id}/members/{salesTeamMemberId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'salesTeamMemberId' + '}', String(params.salesTeamMemberId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSalesTeamsIdMembersSalesTeamMemberIdPatch');
            }
            // verify required parameter 'salesTeamMemberId' is set
            if (params.salesTeamMemberId == null) {
                throw new Error('Missing required parameter salesTeamMemberId when calling systemSalesTeamsIdMembersSalesTeamMemberIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemSalesTeamsIdMembersSalesTeamMemberIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Sales Team Member
         * @param id
         * @param salesTeamMemberId
         * @param salesTeamMember
         */
        public systemSalesTeamsIdMembersSalesTeamMemberIdPut (params: {  id: number; salesTeamMemberId: number; salesTeamMember: SalesTeamMember; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SalesTeamMember> {
            const localVarPath = this.basePath + '/system/salesTeams/{id}/members/{salesTeamMemberId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'salesTeamMemberId' + '}', String(params.salesTeamMemberId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSalesTeamsIdMembersSalesTeamMemberIdPut');
            }
            // verify required parameter 'salesTeamMemberId' is set
            if (params.salesTeamMemberId == null) {
                throw new Error('Missing required parameter salesTeamMemberId when calling systemSalesTeamsIdMembersSalesTeamMemberIdPut');
            }
            // verify required parameter 'salesTeamMember' is set
            if (params.salesTeamMember == null) {
                throw new Error('Missing required parameter salesTeamMember when calling systemSalesTeamsIdMembersSalesTeamMemberIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.salesTeamMember),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SalesTeamsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Sales Teams Count
         * @param conditions
         */
        public systemSalesTeamsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/salesTeams/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Sales Teams
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemSalesTeamsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<SalesTeam>> {
            const localVarPath = this.basePath + '/system/salesTeams';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Sales Team By Id
         * @param id
         */
        public systemSalesTeamsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/salesTeams/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSalesTeamsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Sales Team By Id
         * @param id
         */
        public systemSalesTeamsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SalesTeam> {
            const localVarPath = this.basePath + '/system/salesTeams/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSalesTeamsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Sales Team
         * @param id
         * @param operations
         */
        public systemSalesTeamsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SalesTeam> {
            const localVarPath = this.basePath + '/system/salesTeams/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSalesTeamsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemSalesTeamsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Sales Team
         * @param id
         * @param salesTeam
         */
        public systemSalesTeamsIdPut (params: {  id: number; salesTeam: SalesTeam; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SalesTeam> {
            const localVarPath = this.basePath + '/system/salesTeams/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSalesTeamsIdPut');
            }
            // verify required parameter 'salesTeam' is set
            if (params.salesTeam == null) {
                throw new Error('Missing required parameter salesTeam when calling systemSalesTeamsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.salesTeam),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Sales Team
         * @param salesTeam
         */
        public systemSalesTeamsPost (params: {  salesTeam: SalesTeam; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SalesTeam> {
            const localVarPath = this.basePath + '/system/salesTeams';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'salesTeam' is set
            if (params.salesTeam == null) {
                throw new Error('Missing required parameter salesTeam when calling systemSalesTeamsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.salesTeam),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ScheduleColorsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Schedule Colors Count
         * @param conditions
         */
        public scheduleColorsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/schedule/colors/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Schedule Colors
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public scheduleColorsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ScheduleColor>> {
            const localVarPath = this.basePath + '/schedule/colors';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Clear Schedule Color
         * @param id
         */
        public scheduleColorsIdClearPost (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleColor> {
            const localVarPath = this.basePath + '/schedule/colors/{id}/clear'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleColorsIdClearPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Schedule Color By Id
         * @param id
         */
        public scheduleColorsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleColor> {
            const localVarPath = this.basePath + '/schedule/colors/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleColorsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Schedule Color
         * @param id
         * @param operations
         */
        public scheduleColorsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleColor> {
            const localVarPath = this.basePath + '/schedule/colors/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleColorsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling scheduleColorsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Schedule Color
         * @param id
         * @param scheduleColor
         */
        public scheduleColorsIdPut (params: {  id: number; scheduleColor: ScheduleColor; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleColor> {
            const localVarPath = this.basePath + '/schedule/colors/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleColorsIdPut');
            }
            // verify required parameter 'scheduleColor' is set
            if (params.scheduleColor == null) {
                throw new Error('Missing required parameter scheduleColor when calling scheduleColorsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.scheduleColor),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Reset Schedule Colors
         */
        public scheduleColorsResetPost (params: {  }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ScheduleColor>> {
            const localVarPath = this.basePath + '/schedule/colors/reset';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            let fetchParams = {
                method: 'POST',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ScheduleDetailsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Schedule Detail Count
         * @param id
         * @param conditions
         */
        public scheduleEntriesIdDetailsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/schedule/entries/{id}/details/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleEntriesIdDetailsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Schedule Detail By Id
         * @param id
         * @param detailId
         */
        public scheduleEntriesIdDetailsDetailIdGet (params: {  id: number; detailId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleDetail> {
            const localVarPath = this.basePath + '/schedule/entries/{id}/details/{detailId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'detailId' + '}', String(params.detailId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleEntriesIdDetailsDetailIdGet');
            }
            // verify required parameter 'detailId' is set
            if (params.detailId == null) {
                throw new Error('Missing required parameter detailId when calling scheduleEntriesIdDetailsDetailIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Schedule Detail
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public scheduleEntriesIdDetailsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ScheduleDetail>> {
            const localVarPath = this.basePath + '/schedule/entries/{id}/details'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleEntriesIdDetailsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ScheduleEntriesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Schedules Count
         * @param conditions
         */
        public scheduleEntriesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/schedule/entries/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Schedules
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public scheduleEntriesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ScheduleEntry>> {
            const localVarPath = this.basePath + '/schedule/entries';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Schedule By Id
         * @param id
         */
        public scheduleEntriesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/schedule/entries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleEntriesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Schedule By Id
         * @param id
         */
        public scheduleEntriesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleEntry> {
            const localVarPath = this.basePath + '/schedule/entries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleEntriesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Schedule
         * @param id
         * @param operations
         */
        public scheduleEntriesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleEntry> {
            const localVarPath = this.basePath + '/schedule/entries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleEntriesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling scheduleEntriesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Schedule
         * @param id
         * @param scheduleEntry
         */
        public scheduleEntriesIdPut (params: {  id: number; scheduleEntry: ScheduleEntry; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleEntry> {
            const localVarPath = this.basePath + '/schedule/entries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleEntriesIdPut');
            }
            // verify required parameter 'scheduleEntry' is set
            if (params.scheduleEntry == null) {
                throw new Error('Missing required parameter scheduleEntry when calling scheduleEntriesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.scheduleEntry),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Schedule
         * @param scheduleEntry
         */
        public scheduleEntriesPost (params: {  scheduleEntry: ScheduleEntry; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleEntry> {
            const localVarPath = this.basePath + '/schedule/entries';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'scheduleEntry' is set
            if (params.scheduleEntry == null) {
                throw new Error('Missing required parameter scheduleEntry when calling scheduleEntriesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.scheduleEntry),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ScheduleReminderTimesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Reminder Time Count
         * @param conditions
         */
        public scheduleReminderTimesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/schedule/reminderTimes/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Reminder Time
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public scheduleReminderTimesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ScheduleReminderTime>> {
            const localVarPath = this.basePath + '/schedule/reminderTimes';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Reminder Time By Id
         * @param id
         */
        public scheduleReminderTimesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleReminderTime> {
            const localVarPath = this.basePath + '/schedule/reminderTimes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleReminderTimesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Reminder Time
         * @param id
         * @param operations
         */
        public scheduleReminderTimesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleReminderTime> {
            const localVarPath = this.basePath + '/schedule/reminderTimes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleReminderTimesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling scheduleReminderTimesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Reminder Time
         * @param id
         * @param reminderTime
         */
        public scheduleReminderTimesIdPut (params: {  id: number; reminderTime: ScheduleReminderTime; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleReminderTime> {
            const localVarPath = this.basePath + '/schedule/reminderTimes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleReminderTimesIdPut');
            }
            // verify required parameter 'reminderTime' is set
            if (params.reminderTime == null) {
                throw new Error('Missing required parameter reminderTime when calling scheduleReminderTimesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.reminderTime),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ScheduleStatusesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Schedule Statuses Count
         * @param conditions
         */
        public scheduleStatusesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/schedule/statuses/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Schedule Statuses
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public scheduleStatusesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ScheduleStatus>> {
            const localVarPath = this.basePath + '/schedule/statuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Schedule Status By Id
         * @param id
         */
        public scheduleStatusesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/schedule/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleStatusesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Schedule Status By Id
         * @param id
         */
        public scheduleStatusesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleStatus> {
            const localVarPath = this.basePath + '/schedule/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleStatusesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Schedule Status
         * @param id
         * @param operations
         */
        public scheduleStatusesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleStatus> {
            const localVarPath = this.basePath + '/schedule/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleStatusesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling scheduleStatusesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Schedule Status
         * @param id
         * @param scheduleStatus
         */
        public scheduleStatusesIdPut (params: {  id: number; scheduleStatus: ScheduleStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleStatus> {
            const localVarPath = this.basePath + '/schedule/statuses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleStatusesIdPut');
            }
            // verify required parameter 'scheduleStatus' is set
            if (params.scheduleStatus == null) {
                throw new Error('Missing required parameter scheduleStatus when calling scheduleStatusesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.scheduleStatus),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Schedule Status
         * @param scheduleStatus
         */
        public scheduleStatusesPost (params: {  scheduleStatus: ScheduleStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleStatus> {
            const localVarPath = this.basePath + '/schedule/statuses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'scheduleStatus' is set
            if (params.scheduleStatus == null) {
                throw new Error('Missing required parameter scheduleStatus when calling scheduleStatusesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.scheduleStatus),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ScheduleStopwatchesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Schedule Stopwatches Count
         * @param conditions
         */
        public timeSchedulestopwatchesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/time/schedulestopwatches/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Schedule Stopwatches
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public timeSchedulestopwatchesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ScheduleStopwatch>> {
            const localVarPath = this.basePath + '/time/schedulestopwatches';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Schedule Stopwatch By Id
         * @param id
         */
        public timeSchedulestopwatchesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/time/schedulestopwatches/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeSchedulestopwatchesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Schedule Stopwatch By Id
         * @param id
         */
        public timeSchedulestopwatchesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleStopwatch> {
            const localVarPath = this.basePath + '/time/schedulestopwatches/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeSchedulestopwatchesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Schedule Stopwatch
         * @param id
         * @param operations
         */
        public timeSchedulestopwatchesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleStopwatch> {
            const localVarPath = this.basePath + '/time/schedulestopwatches/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeSchedulestopwatchesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling timeSchedulestopwatchesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Schedule Stopwatch
         * @param id
         * @param scheduleStopwatch
         */
        public timeSchedulestopwatchesIdPut (params: {  id: number; scheduleStopwatch: ScheduleStopwatch; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleStopwatch> {
            const localVarPath = this.basePath + '/time/schedulestopwatches/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeSchedulestopwatchesIdPut');
            }
            // verify required parameter 'scheduleStopwatch' is set
            if (params.scheduleStopwatch == null) {
                throw new Error('Missing required parameter scheduleStopwatch when calling timeSchedulestopwatchesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.scheduleStopwatch),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Schedule Stopwatch
         * @param scheduleStopwatch
         */
        public timeSchedulestopwatchesPost (params: {  scheduleStopwatch: ScheduleStopwatch; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleStopwatch> {
            const localVarPath = this.basePath + '/time/schedulestopwatches';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'scheduleStopwatch' is set
            if (params.scheduleStopwatch == null) {
                throw new Error('Missing required parameter scheduleStopwatch when calling timeSchedulestopwatchesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.scheduleStopwatch),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ScheduleTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Schedule Types Count
         * @param conditions
         */
        public scheduleTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/schedule/types/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Schedule Types
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public scheduleTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ScheduleType>> {
            const localVarPath = this.basePath + '/schedule/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Schedule Type By Id
         * @param id
         */
        public scheduleTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/schedule/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleTypesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Schedule Type By Id
         * @param id
         */
        public scheduleTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleType> {
            const localVarPath = this.basePath + '/schedule/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleTypesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Schedule Type
         * @param id
         * @param operations
         */
        public scheduleTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleType> {
            const localVarPath = this.basePath + '/schedule/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleTypesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling scheduleTypesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Schedule Type
         * @param id
         * @param scheduleType
         */
        public scheduleTypesIdPut (params: {  id: number; scheduleType: ScheduleType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleType> {
            const localVarPath = this.basePath + '/schedule/types/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling scheduleTypesIdPut');
            }
            // verify required parameter 'scheduleType' is set
            if (params.scheduleType == null) {
                throw new Error('Missing required parameter scheduleType when calling scheduleTypesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.scheduleType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Schedule Type
         * @param scheduleType
         */
        public scheduleTypesPost (params: {  scheduleType: ScheduleType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleType> {
            const localVarPath = this.basePath + '/schedule/types';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'scheduleType' is set
            if (params.scheduleType == null) {
                throw new Error('Missing required parameter scheduleType when calling scheduleTypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.scheduleType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SecurityRoleSettingsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Security Role Settings Count
         * @param id
         * @param conditions
         */
        public systemSecurityRolesIdSettingsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/securityRoles/{id}/settings/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSecurityRolesIdSettingsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Security Role Settings
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemSecurityRolesIdSettingsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<SecurityRoleSetting>> {
            const localVarPath = this.basePath + '/system/securityRoles/{id}/settings'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSecurityRolesIdSettingsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Security Role Setting By Id
         * @param id
         * @param settingsId
         */
        public systemSecurityRolesIdSettingsSettingsIdGet (params: {  id: number; settingsId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SecurityRoleSetting> {
            const localVarPath = this.basePath + '/system/securityRoles/{id}/settings/{settingsId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'settingsId' + '}', String(params.settingsId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSecurityRolesIdSettingsSettingsIdGet');
            }
            // verify required parameter 'settingsId' is set
            if (params.settingsId == null) {
                throw new Error('Missing required parameter settingsId when calling systemSecurityRolesIdSettingsSettingsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SecurityRolesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Security Role Count
         * @param conditions
         */
        public systemSecurityrolesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/securityroles/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Security Role
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemSecurityrolesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<SecurityRole>> {
            const localVarPath = this.basePath + '/system/securityroles';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Security Role By Id
         * @param id
         */
        public systemSecurityrolesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/securityroles/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSecurityrolesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Security Role By Id
         * @param id
         */
        public systemSecurityrolesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SecurityRole> {
            const localVarPath = this.basePath + '/system/securityroles/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSecurityrolesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Security Role
         * @param securityRole
         */
        public systemSecurityrolesPost (params: {  securityRole: SecurityRole; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SecurityRole> {
            const localVarPath = this.basePath + '/system/securityroles';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'securityRole' is set
            if (params.securityRole == null) {
                throw new Error('Missing required parameter securityRole when calling systemSecurityrolesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.securityRole),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ServiceEmailTemplatesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Email Templates Count
         * @param conditions
         */
        public serviceEmailTemplatesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/emailTemplates/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Email Templates
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceEmailTemplatesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ServiceEmailTemplate>> {
            const localVarPath = this.basePath + '/service/emailTemplates';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Email Template By Id
         * @param id
         */
        public serviceEmailTemplatesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/emailTemplates/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceEmailTemplatesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Email Template By Id
         * @param id
         */
        public serviceEmailTemplatesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ServiceEmailTemplate> {
            const localVarPath = this.basePath + '/service/emailTemplates/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceEmailTemplatesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Email Template
         * @param id
         * @param operations
         */
        public serviceEmailTemplatesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ServiceEmailTemplate> {
            const localVarPath = this.basePath + '/service/emailTemplates/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceEmailTemplatesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceEmailTemplatesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Email Template
         * @param id
         * @param serviceEmailTemplate
         */
        public serviceEmailTemplatesIdPut (params: {  id: number; serviceEmailTemplate: ServiceEmailTemplate; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ServiceEmailTemplate> {
            const localVarPath = this.basePath + '/service/emailTemplates/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceEmailTemplatesIdPut');
            }
            // verify required parameter 'serviceEmailTemplate' is set
            if (params.serviceEmailTemplate == null) {
                throw new Error('Missing required parameter serviceEmailTemplate when calling serviceEmailTemplatesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.serviceEmailTemplate),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Email Template
         * @param serviceEmailTemplate
         */
        public serviceEmailTemplatesPost (params: {  serviceEmailTemplate: ServiceEmailTemplate; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ServiceEmailTemplate> {
            const localVarPath = this.basePath + '/service/emailTemplates';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'serviceEmailTemplate' is set
            if (params.serviceEmailTemplate == null) {
                throw new Error('Missing required parameter serviceEmailTemplate when calling serviceEmailTemplatesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.serviceEmailTemplate),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ServiceLocationsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Create Locations Count
         * @param conditions
         */
        public serviceLocationsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/locations/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Locations
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceLocationsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ServiceLocation>> {
            const localVarPath = this.basePath + '/service/locations';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Location By Id
         * @param id
         */
        public serviceLocationsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/locations/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceLocationsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Location By Id
         * @param id
         */
        public serviceLocationsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ServiceLocation> {
            const localVarPath = this.basePath + '/service/locations/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceLocationsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Location
         * @param id
         * @param operations
         */
        public serviceLocationsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ServiceLocation> {
            const localVarPath = this.basePath + '/service/locations/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceLocationsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceLocationsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Location
         * @param id
         * @param location
         */
        public serviceLocationsIdPut (params: {  id: number; location: ServiceLocation; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ServiceLocation> {
            const localVarPath = this.basePath + '/service/locations/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceLocationsIdPut');
            }
            // verify required parameter 'location' is set
            if (params.location == null) {
                throw new Error('Missing required parameter location when calling serviceLocationsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.location),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Location
         * @param location
         */
        public serviceLocationsPost (params: {  location: ServiceLocation; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ServiceLocation> {
            const localVarPath = this.basePath + '/service/locations';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'location' is set
            if (params.location == null) {
                throw new Error('Missing required parameter location when calling serviceLocationsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.location),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ServiceSignoffsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Service Signoffs Count
         * @param conditions
         */
        public serviceServiceSignoffCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/serviceSignoff/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Service Signoffs
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceServiceSignoffGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ServiceSignoff>> {
            const localVarPath = this.basePath + '/service/serviceSignoff';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Service Signoff By Id
         * @param id
         */
        public serviceServiceSignoffIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/serviceSignoff/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceServiceSignoffIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Service Signoff By Id
         * @param id
         */
        public serviceServiceSignoffIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ServiceSignoff> {
            const localVarPath = this.basePath + '/service/serviceSignoff/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceServiceSignoffIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Service Signoff
         * @param id
         * @param operations
         */
        public serviceServiceSignoffIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ServiceSignoff> {
            const localVarPath = this.basePath + '/service/serviceSignoff/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceServiceSignoffIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceServiceSignoffIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Service Signoff
         * @param id
         * @param serviceSignoff
         */
        public serviceServiceSignoffIdPut (params: {  id: number; serviceSignoff: ServiceSignoff; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ServiceSignoff> {
            const localVarPath = this.basePath + '/service/serviceSignoff/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceServiceSignoffIdPut');
            }
            // verify required parameter 'serviceSignoff' is set
            if (params.serviceSignoff == null) {
                throw new Error('Missing required parameter serviceSignoff when calling serviceServiceSignoffIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.serviceSignoff),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Service Signoff
         * @param serviceSignoff
         */
        public serviceServiceSignoffPost (params: {  serviceSignoff: ServiceSignoff; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ServiceSignoff> {
            const localVarPath = this.basePath + '/service/serviceSignoff';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'serviceSignoff' is set
            if (params.serviceSignoff == null) {
                throw new Error('Missing required parameter serviceSignoff when calling serviceServiceSignoffPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.serviceSignoff),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ServiceSurveyQuestionsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Survey Questions Count
         * @param id
         * @param conditions
         */
        public serviceSurveysIdQuestionsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/surveys/{id}/questions/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdQuestionsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Survey Questions
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceSurveysIdQuestionsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ServiceSurveyQuestion>> {
            const localVarPath = this.basePath + '/service/surveys/{id}/questions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdQuestionsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Survey Question
         * @param id
         * @param serviceSurveyQuestion
         */
        public serviceSurveysIdQuestionsPost (params: {  id: number; serviceSurveyQuestion: ServiceSurveyQuestion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ServiceSurveyQuestion> {
            const localVarPath = this.basePath + '/service/surveys/{id}/questions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdQuestionsPost');
            }
            // verify required parameter 'serviceSurveyQuestion' is set
            if (params.serviceSurveyQuestion == null) {
                throw new Error('Missing required parameter serviceSurveyQuestion when calling serviceSurveysIdQuestionsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.serviceSurveyQuestion),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Survey Question By Id
         * @param id
         * @param questionId
         */
        public serviceSurveysIdQuestionsQuestionIdDelete (params: {  id: number; questionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/surveys/{id}/questions/{questionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'questionId' + '}', String(params.questionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdQuestionsQuestionIdDelete');
            }
            // verify required parameter 'questionId' is set
            if (params.questionId == null) {
                throw new Error('Missing required parameter questionId when calling serviceSurveysIdQuestionsQuestionIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Survey Question By Id
         * @param id
         * @param questionId
         */
        public serviceSurveysIdQuestionsQuestionIdGet (params: {  id: number; questionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ServiceSurveyQuestion> {
            const localVarPath = this.basePath + '/service/surveys/{id}/questions/{questionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'questionId' + '}', String(params.questionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdQuestionsQuestionIdGet');
            }
            // verify required parameter 'questionId' is set
            if (params.questionId == null) {
                throw new Error('Missing required parameter questionId when calling serviceSurveysIdQuestionsQuestionIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Survey Question
         * @param id
         * @param questionId
         * @param operations
         */
        public serviceSurveysIdQuestionsQuestionIdPatch (params: {  id: number; questionId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ServiceSurveyQuestion> {
            const localVarPath = this.basePath + '/service/surveys/{id}/questions/{questionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'questionId' + '}', String(params.questionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdQuestionsQuestionIdPatch');
            }
            // verify required parameter 'questionId' is set
            if (params.questionId == null) {
                throw new Error('Missing required parameter questionId when calling serviceSurveysIdQuestionsQuestionIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceSurveysIdQuestionsQuestionIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Survey Question
         * @param id
         * @param questionId
         * @param serviceSurveyQuestion
         */
        public serviceSurveysIdQuestionsQuestionIdPut (params: {  id: number; questionId: number; serviceSurveyQuestion: ServiceSurveyQuestion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ServiceSurveyQuestion> {
            const localVarPath = this.basePath + '/service/surveys/{id}/questions/{questionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'questionId' + '}', String(params.questionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdQuestionsQuestionIdPut');
            }
            // verify required parameter 'questionId' is set
            if (params.questionId == null) {
                throw new Error('Missing required parameter questionId when calling serviceSurveysIdQuestionsQuestionIdPut');
            }
            // verify required parameter 'serviceSurveyQuestion' is set
            if (params.serviceSurveyQuestion == null) {
                throw new Error('Missing required parameter serviceSurveyQuestion when calling serviceSurveysIdQuestionsQuestionIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.serviceSurveyQuestion),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ServiceSurveysApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Surveys Count
         * @param conditions
         */
        public serviceSurveysCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/surveys/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Surveys
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceSurveysGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ServiceSurvey>> {
            const localVarPath = this.basePath + '/service/surveys';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Survey By Id
         * @param id
         */
        public serviceSurveysIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/surveys/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Survey By Id
         * @param id
         */
        public serviceSurveysIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ServiceSurvey> {
            const localVarPath = this.basePath + '/service/surveys/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Survey
         * @param id
         * @param operations
         */
        public serviceSurveysIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ServiceSurvey> {
            const localVarPath = this.basePath + '/service/surveys/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceSurveysIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Survey
         * @param id
         * @param survey
         */
        public serviceSurveysIdPut (params: {  id: number; survey: ServiceSurvey; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ServiceSurvey> {
            const localVarPath = this.basePath + '/service/surveys/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdPut');
            }
            // verify required parameter 'survey' is set
            if (params.survey == null) {
                throw new Error('Missing required parameter survey when calling serviceSurveysIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.survey),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Survey
         * @param survey
         */
        public serviceSurveysPost (params: {  survey: ServiceSurvey; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ServiceSurvey> {
            const localVarPath = this.basePath + '/service/surveys';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'survey' is set
            if (params.survey == null) {
                throw new Error('Missing required parameter survey when calling serviceSurveysPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.survey),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ServiceTeamsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Service Teams Count
         * @param conditions
         */
        public serviceTeamsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/teams/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Service Teams
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceTeamsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ServiceTeam>> {
            const localVarPath = this.basePath + '/service/teams';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Service Team By Id
         * @param id
         */
        public serviceTeamsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ServiceTeam> {
            const localVarPath = this.basePath + '/service/teams/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTeamsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ServiceTemplatesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Templates Count
         * @param conditions
         */
        public serviceTemplatesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/templates/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Templates
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceTemplatesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ServiceTemplate>> {
            const localVarPath = this.basePath + '/service/templates';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Template By Id
         * @param id
         */
        public serviceTemplatesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ServiceTemplate> {
            const localVarPath = this.basePath + '/service/templates/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTemplatesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ServicesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Services
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemMycompanyServicesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Service>> {
            const localVarPath = this.basePath + '/system/mycompany/services';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Service By Id
         * @param id
         */
        public systemMycompanyServicesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Service> {
            const localVarPath = this.basePath + '/system/mycompany/services/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMycompanyServicesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Service
         * @param id
         * @param operations
         */
        public systemMycompanyServicesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Service> {
            const localVarPath = this.basePath + '/system/mycompany/services/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMycompanyServicesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemMycompanyServicesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Service
         * @param id
         * @param service
         */
        public systemMycompanyServicesIdPut (params: {  id: number; service: Service; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Service> {
            const localVarPath = this.basePath + '/system/mycompany/services/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMycompanyServicesIdPut');
            }
            // verify required parameter 'service' is set
            if (params.service == null) {
                throw new Error('Missing required parameter service when calling systemMycompanyServicesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.service),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SetupScreensApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Setup Screens Count
         * @param conditions
         */
        public systemSetupScreensCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/setupScreens/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Setup Screens
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemSetupScreensGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<SetupScreen>> {
            const localVarPath = this.basePath + '/system/setupScreens';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Setup Screen By Id
         * @param id
         */
        public systemSetupScreensIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SetupScreen> {
            const localVarPath = this.basePath + '/system/setupScreens/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSetupScreensIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SeveritiesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Severities Count
         * @param conditions
         */
        public serviceSeveritiesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/severities/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Severities
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceSeveritiesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Severity>> {
            const localVarPath = this.basePath + '/service/severities';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Severity By Id
         * @param id
         */
        public serviceSeveritiesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Severity> {
            const localVarPath = this.basePath + '/service/severities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSeveritiesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Severity
         * @param id
         * @param operations
         */
        public serviceSeveritiesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Severity> {
            const localVarPath = this.basePath + '/service/severities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSeveritiesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceSeveritiesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Severity
         * @param id
         * @param severity
         */
        public serviceSeveritiesIdPut (params: {  id: number; severity: Severity; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Severity> {
            const localVarPath = this.basePath + '/service/severities/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSeveritiesIdPut');
            }
            // verify required parameter 'severity' is set
            if (params.severity == null) {
                throw new Error('Missing required parameter severity when calling serviceSeveritiesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.severity),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ShipmentMethodsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Shipment Methods Count
         * @param conditions
         */
        public procurementShipmentmethodsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/shipmentmethods/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Shipment Methods
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementShipmentmethodsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ShipmentMethod>> {
            const localVarPath = this.basePath + '/procurement/shipmentmethods';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Shipment Method By Id
         * @param id
         */
        public procurementShipmentmethodsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/shipmentmethods/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementShipmentmethodsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Shipment Method By Id
         * @param id
         */
        public procurementShipmentmethodsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ShipmentMethod> {
            const localVarPath = this.basePath + '/procurement/shipmentmethods/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementShipmentmethodsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Shipment Method
         * @param id
         * @param operations
         */
        public procurementShipmentmethodsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ShipmentMethod> {
            const localVarPath = this.basePath + '/procurement/shipmentmethods/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementShipmentmethodsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementShipmentmethodsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Shipment Method
         * @param id
         * @param shipmentMethod
         */
        public procurementShipmentmethodsIdPut (params: {  id: number; shipmentMethod: ShipmentMethod; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ShipmentMethod> {
            const localVarPath = this.basePath + '/procurement/shipmentmethods/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementShipmentmethodsIdPut');
            }
            // verify required parameter 'shipmentMethod' is set
            if (params.shipmentMethod == null) {
                throw new Error('Missing required parameter shipmentMethod when calling procurementShipmentmethodsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.shipmentMethod),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Shipment Method
         * @param shipmentMethod
         */
        public procurementShipmentmethodsPost (params: {  shipmentMethod: ShipmentMethod; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ShipmentMethod> {
            const localVarPath = this.basePath + '/procurement/shipmentmethods';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'shipmentMethod' is set
            if (params.shipmentMethod == null) {
                throw new Error('Missing required parameter shipmentMethod when calling procurementShipmentmethodsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.shipmentMethod),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SkillCategoriesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Skill Categories Count
         * @param conditions
         */
        public systemSkillCategoriesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/skillCategories/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Skill Categories
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemSkillCategoriesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<SkillCategory>> {
            const localVarPath = this.basePath + '/system/skillCategories';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Skill Category By Id
         * @param id
         */
        public systemSkillCategoriesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/skillCategories/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSkillCategoriesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Skill Category By Id
         * @param id
         */
        public systemSkillCategoriesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SkillCategory> {
            const localVarPath = this.basePath + '/system/skillCategories/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSkillCategoriesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Skill Category
         * @param id
         * @param operations
         */
        public systemSkillCategoriesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SkillCategory> {
            const localVarPath = this.basePath + '/system/skillCategories/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSkillCategoriesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemSkillCategoriesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Skill Category
         * @param id
         * @param skillCategory
         */
        public systemSkillCategoriesIdPut (params: {  id: number; skillCategory: SkillCategory; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SkillCategory> {
            const localVarPath = this.basePath + '/system/skillCategories/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSkillCategoriesIdPut');
            }
            // verify required parameter 'skillCategory' is set
            if (params.skillCategory == null) {
                throw new Error('Missing required parameter skillCategory when calling systemSkillCategoriesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.skillCategory),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Skill Category
         * @param skillCategory
         */
        public systemSkillCategoriesPost (params: {  skillCategory: SkillCategory; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SkillCategory> {
            const localVarPath = this.basePath + '/system/skillCategories';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'skillCategory' is set
            if (params.skillCategory == null) {
                throw new Error('Missing required parameter skillCategory when calling systemSkillCategoriesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.skillCategory),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SkillsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Skill Count
         * @param conditions
         */
        public systemSkillsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/skills/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Skill
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemSkillsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Skill>> {
            const localVarPath = this.basePath + '/system/skills';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Skill By Id
         * @param id
         */
        public systemSkillsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/skills/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSkillsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Skill By Id
         * @param id
         */
        public systemSkillsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Skill> {
            const localVarPath = this.basePath + '/system/skills/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSkillsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Skill
         * @param id
         * @param operations
         */
        public systemSkillsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Skill> {
            const localVarPath = this.basePath + '/system/skills/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSkillsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemSkillsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Skill
         * @param id
         * @param skill
         */
        public systemSkillsIdPut (params: {  id: number; skill: Skill; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Skill> {
            const localVarPath = this.basePath + '/system/skills/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSkillsIdPut');
            }
            // verify required parameter 'skill' is set
            if (params.skill == null) {
                throw new Error('Missing required parameter skill when calling systemSkillsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.skill),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Skill
         * @param skill
         */
        public systemSkillsPost (params: {  skill: Skill; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Skill> {
            const localVarPath = this.basePath + '/system/skills';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'skill' is set
            if (params.skill == null) {
                throw new Error('Missing required parameter skill when calling systemSkillsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.skill),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SourcesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Create Sources Count
         * @param conditions
         */
        public serviceSourcesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/sources/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Sources
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceSourcesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Source>> {
            const localVarPath = this.basePath + '/service/sources';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Source By Id
         * @param id
         */
        public serviceSourcesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/sources/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSourcesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Source By Id
         * @param id
         */
        public serviceSourcesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Source> {
            const localVarPath = this.basePath + '/service/sources/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSourcesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Source
         * @param id
         * @param operations
         */
        public serviceSourcesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Source> {
            const localVarPath = this.basePath + '/service/sources/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSourcesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceSourcesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Source
         * @param id
         * @param source
         */
        public serviceSourcesIdPut (params: {  id: number; source: Source; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Source> {
            const localVarPath = this.basePath + '/service/sources/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSourcesIdPut');
            }
            // verify required parameter 'source' is set
            if (params.source == null) {
                throw new Error('Missing required parameter source when calling serviceSourcesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.source),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Source
         * @param source
         */
        public serviceSourcesPost (params: {  source: Source; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Source> {
            const localVarPath = this.basePath + '/service/sources';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'source' is set
            if (params.source == null) {
                throw new Error('Missing required parameter source when calling serviceSourcesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.source),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class StatesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get States Count
         * @param conditions
         */
        public systemStatesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/states/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get States
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemStatesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<State>> {
            const localVarPath = this.basePath + '/system/states';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get State By Id
         * @param id
         */
        public systemStatesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<State> {
            const localVarPath = this.basePath + '/system/states/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemStatesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create State
         * @param billingSetup
         */
        public systemStatesPost (params: {  billingSetup: State; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<State> {
            const localVarPath = this.basePath + '/system/states';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'billingSetup' is set
            if (params.billingSetup == null) {
                throw new Error('Missing required parameter billingSetup when calling systemStatesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.billingSetup),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class StatusExternalIntegrationReferencesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Status External Integration References Count
         * @param conditions
         */
        public serviceStatusExternalIntegrationReferencesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/statusExternalIntegrationReferences/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Status External Integration References
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceStatusExternalIntegrationReferencesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<StatusExternalIntegrationReference>> {
            const localVarPath = this.basePath + '/service/statusExternalIntegrationReferences';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get External Integration Status By Id
         * @param id
         */
        public serviceStatusExternalIntegrationReferencesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<StatusExternalIntegrationReference> {
            const localVarPath = this.basePath + '/service/statusExternalIntegrationReferences/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceStatusExternalIntegrationReferencesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SubCategoriesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Sub Categories Count
         * @param conditions
         */
        public procurementSubcategoriesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/subcategories/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Sub Categories
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementSubcategoriesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<SubCategory>> {
            const localVarPath = this.basePath + '/procurement/subcategories';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Sub Category By Id
         * @param id
         */
        public procurementSubcategoriesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/subcategories/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementSubcategoriesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Sub Category By Id
         * @param id
         */
        public procurementSubcategoriesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SubCategory> {
            const localVarPath = this.basePath + '/procurement/subcategories/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementSubcategoriesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Sub Category
         * @param id
         * @param operations
         */
        public procurementSubcategoriesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SubCategory> {
            const localVarPath = this.basePath + '/procurement/subcategories/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementSubcategoriesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementSubcategoriesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Sub Category
         * @param id
         * @param subCategory
         */
        public procurementSubcategoriesIdPut (params: {  id: number; subCategory: SubCategory; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SubCategory> {
            const localVarPath = this.basePath + '/procurement/subcategories/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementSubcategoriesIdPut');
            }
            // verify required parameter 'subCategory' is set
            if (params.subCategory == null) {
                throw new Error('Missing required parameter subCategory when calling procurementSubcategoriesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.subCategory),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Sub Category
         * @param subCategory
         */
        public procurementSubcategoriesPost (params: {  subCategory: SubCategory; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SubCategory> {
            const localVarPath = this.basePath + '/procurement/subcategories';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'subCategory' is set
            if (params.subCategory == null) {
                throw new Error('Missing required parameter subCategory when calling procurementSubcategoriesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.subCategory),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SurveyOptionsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Survey Options Count
         * @param surveyID
         * @param questionID
         * @param conditions
         */
        public serviceSurveysSurveyIDQuestionsQuestionIDOptionsCountGet (params: {  surveyID: number; questionID: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/surveys/{surveyID}/questions/{questionID}/options/count'
                .replace('{' + 'surveyID' + '}', String(params.surveyID))
                .replace('{' + 'questionID' + '}', String(params.questionID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'surveyID' is set
            if (params.surveyID == null) {
                throw new Error('Missing required parameter surveyID when calling serviceSurveysSurveyIDQuestionsQuestionIDOptionsCountGet');
            }
            // verify required parameter 'questionID' is set
            if (params.questionID == null) {
                throw new Error('Missing required parameter questionID when calling serviceSurveysSurveyIDQuestionsQuestionIDOptionsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Survey Options
         * @param surveyID
         * @param questionID
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceSurveysSurveyIDQuestionsQuestionIDOptionsGet (params: {  surveyID: number; questionID: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<SurveyOption>> {
            const localVarPath = this.basePath + '/service/surveys/{surveyID}/questions/{questionID}/options'
                .replace('{' + 'surveyID' + '}', String(params.surveyID))
                .replace('{' + 'questionID' + '}', String(params.questionID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'surveyID' is set
            if (params.surveyID == null) {
                throw new Error('Missing required parameter surveyID when calling serviceSurveysSurveyIDQuestionsQuestionIDOptionsGet');
            }
            // verify required parameter 'questionID' is set
            if (params.questionID == null) {
                throw new Error('Missing required parameter questionID when calling serviceSurveysSurveyIDQuestionsQuestionIDOptionsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Survey Option By Id
         * @param surveyID
         * @param questionID
         * @param oid
         */
        public serviceSurveysSurveyIDQuestionsQuestionIDOptionsOidDelete (params: {  surveyID: number; questionID: number; oid: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/surveys/{surveyID}/questions/{questionID}/options/{oid}'
                .replace('{' + 'surveyID' + '}', String(params.surveyID))
                .replace('{' + 'questionID' + '}', String(params.questionID))
                .replace('{' + 'oid' + '}', String(params.oid));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'surveyID' is set
            if (params.surveyID == null) {
                throw new Error('Missing required parameter surveyID when calling serviceSurveysSurveyIDQuestionsQuestionIDOptionsOidDelete');
            }
            // verify required parameter 'questionID' is set
            if (params.questionID == null) {
                throw new Error('Missing required parameter questionID when calling serviceSurveysSurveyIDQuestionsQuestionIDOptionsOidDelete');
            }
            // verify required parameter 'oid' is set
            if (params.oid == null) {
                throw new Error('Missing required parameter oid when calling serviceSurveysSurveyIDQuestionsQuestionIDOptionsOidDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Survey Option By Id
         * @param surveyID
         * @param questionID
         * @param oid
         */
        public serviceSurveysSurveyIDQuestionsQuestionIDOptionsOidGet (params: {  surveyID: number; questionID: number; oid: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SurveyOption> {
            const localVarPath = this.basePath + '/service/surveys/{surveyID}/questions/{questionID}/options/{oid}'
                .replace('{' + 'surveyID' + '}', String(params.surveyID))
                .replace('{' + 'questionID' + '}', String(params.questionID))
                .replace('{' + 'oid' + '}', String(params.oid));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'surveyID' is set
            if (params.surveyID == null) {
                throw new Error('Missing required parameter surveyID when calling serviceSurveysSurveyIDQuestionsQuestionIDOptionsOidGet');
            }
            // verify required parameter 'questionID' is set
            if (params.questionID == null) {
                throw new Error('Missing required parameter questionID when calling serviceSurveysSurveyIDQuestionsQuestionIDOptionsOidGet');
            }
            // verify required parameter 'oid' is set
            if (params.oid == null) {
                throw new Error('Missing required parameter oid when calling serviceSurveysSurveyIDQuestionsQuestionIDOptionsOidGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Survey Option
         * @param surveyID
         * @param questionID
         * @param oid
         * @param operations
         */
        public serviceSurveysSurveyIDQuestionsQuestionIDOptionsOidPatch (params: {  surveyID: number; questionID: number; oid: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SurveyOption> {
            const localVarPath = this.basePath + '/service/surveys/{surveyID}/questions/{questionID}/options/{oid}'
                .replace('{' + 'surveyID' + '}', String(params.surveyID))
                .replace('{' + 'questionID' + '}', String(params.questionID))
                .replace('{' + 'oid' + '}', String(params.oid));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'surveyID' is set
            if (params.surveyID == null) {
                throw new Error('Missing required parameter surveyID when calling serviceSurveysSurveyIDQuestionsQuestionIDOptionsOidPatch');
            }
            // verify required parameter 'questionID' is set
            if (params.questionID == null) {
                throw new Error('Missing required parameter questionID when calling serviceSurveysSurveyIDQuestionsQuestionIDOptionsOidPatch');
            }
            // verify required parameter 'oid' is set
            if (params.oid == null) {
                throw new Error('Missing required parameter oid when calling serviceSurveysSurveyIDQuestionsQuestionIDOptionsOidPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceSurveysSurveyIDQuestionsQuestionIDOptionsOidPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Survey Option
         * @param surveyID
         * @param questionID
         * @param oid
         * @param surveyOption
         */
        public serviceSurveysSurveyIDQuestionsQuestionIDOptionsOidPut (params: {  surveyID: number; questionID: number; oid: number; surveyOption: SurveyOption; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SurveyOption> {
            const localVarPath = this.basePath + '/service/surveys/{surveyID}/questions/{questionID}/options/{oid}'
                .replace('{' + 'surveyID' + '}', String(params.surveyID))
                .replace('{' + 'questionID' + '}', String(params.questionID))
                .replace('{' + 'oid' + '}', String(params.oid));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'surveyID' is set
            if (params.surveyID == null) {
                throw new Error('Missing required parameter surveyID when calling serviceSurveysSurveyIDQuestionsQuestionIDOptionsOidPut');
            }
            // verify required parameter 'questionID' is set
            if (params.questionID == null) {
                throw new Error('Missing required parameter questionID when calling serviceSurveysSurveyIDQuestionsQuestionIDOptionsOidPut');
            }
            // verify required parameter 'oid' is set
            if (params.oid == null) {
                throw new Error('Missing required parameter oid when calling serviceSurveysSurveyIDQuestionsQuestionIDOptionsOidPut');
            }
            // verify required parameter 'surveyOption' is set
            if (params.surveyOption == null) {
                throw new Error('Missing required parameter surveyOption when calling serviceSurveysSurveyIDQuestionsQuestionIDOptionsOidPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.surveyOption),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Survey Option
         * @param surveyID
         * @param questionID
         * @param surveyOption
         */
        public serviceSurveysSurveyIDQuestionsQuestionIDOptionsPost (params: {  surveyID: number; questionID: number; surveyOption: SurveyOption; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SurveyOption> {
            const localVarPath = this.basePath + '/service/surveys/{surveyID}/questions/{questionID}/options'
                .replace('{' + 'surveyID' + '}', String(params.surveyID))
                .replace('{' + 'questionID' + '}', String(params.questionID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'surveyID' is set
            if (params.surveyID == null) {
                throw new Error('Missing required parameter surveyID when calling serviceSurveysSurveyIDQuestionsQuestionIDOptionsPost');
            }
            // verify required parameter 'questionID' is set
            if (params.questionID == null) {
                throw new Error('Missing required parameter questionID when calling serviceSurveysSurveyIDQuestionsQuestionIDOptionsPost');
            }
            // verify required parameter 'surveyOption' is set
            if (params.surveyOption == null) {
                throw new Error('Missing required parameter surveyOption when calling serviceSurveysSurveyIDQuestionsQuestionIDOptionsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.surveyOption),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SurveyQuestionValuesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Survey Question Values Count
         * @param surveyQuestionId
         * @param conditions
         */
        public systemSurveysIdQuestionsSurveyQuestionIdValuesCountGet (params: {  surveyQuestionId: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/surveys/{id}/questions/{surveyQuestionId}/values/count'
                .replace('{' + 'surveyQuestionId' + '}', String(params.surveyQuestionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'surveyQuestionId' is set
            if (params.surveyQuestionId == null) {
                throw new Error('Missing required parameter surveyQuestionId when calling systemSurveysIdQuestionsSurveyQuestionIdValuesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Survey Question Values
         * @param surveyQuestionId
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemSurveysIdQuestionsSurveyQuestionIdValuesGet (params: {  surveyQuestionId: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<SurveyQuestionValue>> {
            const localVarPath = this.basePath + '/system/surveys/{id}/questions/{surveyQuestionId}/values'
                .replace('{' + 'surveyQuestionId' + '}', String(params.surveyQuestionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'surveyQuestionId' is set
            if (params.surveyQuestionId == null) {
                throw new Error('Missing required parameter surveyQuestionId when calling systemSurveysIdQuestionsSurveyQuestionIdValuesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Survey Question Value
         * @param id
         * @param surveyQuestionId
         * @param surveyQuestionValue
         */
        public systemSurveysIdQuestionsSurveyQuestionIdValuesPost (params: {  id: number; surveyQuestionId: number; surveyQuestionValue: SurveyQuestionValue; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SurveyQuestionValue> {
            const localVarPath = this.basePath + '/system/surveys/{id}/questions/{surveyQuestionId}/values'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'surveyQuestionId' + '}', String(params.surveyQuestionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSurveysIdQuestionsSurveyQuestionIdValuesPost');
            }
            // verify required parameter 'surveyQuestionId' is set
            if (params.surveyQuestionId == null) {
                throw new Error('Missing required parameter surveyQuestionId when calling systemSurveysIdQuestionsSurveyQuestionIdValuesPost');
            }
            // verify required parameter 'surveyQuestionValue' is set
            if (params.surveyQuestionValue == null) {
                throw new Error('Missing required parameter surveyQuestionValue when calling systemSurveysIdQuestionsSurveyQuestionIdValuesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.surveyQuestionValue),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Survey Question Value By Id
         * @param surveyQuestionId
         * @param surveyQuestionValueId
         */
        public systemSurveysIdQuestionsSurveyQuestionIdValuesSurveyQuestionValueIdDelete (params: {  surveyQuestionId: number; surveyQuestionValueId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/surveys/{id}/questions/{surveyQuestionId}/values/{surveyQuestionValueId}'
                .replace('{' + 'surveyQuestionId' + '}', String(params.surveyQuestionId))
                .replace('{' + 'surveyQuestionValueId' + '}', String(params.surveyQuestionValueId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'surveyQuestionId' is set
            if (params.surveyQuestionId == null) {
                throw new Error('Missing required parameter surveyQuestionId when calling systemSurveysIdQuestionsSurveyQuestionIdValuesSurveyQuestionValueIdDelete');
            }
            // verify required parameter 'surveyQuestionValueId' is set
            if (params.surveyQuestionValueId == null) {
                throw new Error('Missing required parameter surveyQuestionValueId when calling systemSurveysIdQuestionsSurveyQuestionIdValuesSurveyQuestionValueIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Survey Question Value By Id
         * @param surveyQuestionId
         * @param surveyQuestionValueId
         */
        public systemSurveysIdQuestionsSurveyQuestionIdValuesSurveyQuestionValueIdGet (params: {  surveyQuestionId: number; surveyQuestionValueId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SurveyQuestionValue> {
            const localVarPath = this.basePath + '/system/surveys/{id}/questions/{surveyQuestionId}/values/{surveyQuestionValueId}'
                .replace('{' + 'surveyQuestionId' + '}', String(params.surveyQuestionId))
                .replace('{' + 'surveyQuestionValueId' + '}', String(params.surveyQuestionValueId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'surveyQuestionId' is set
            if (params.surveyQuestionId == null) {
                throw new Error('Missing required parameter surveyQuestionId when calling systemSurveysIdQuestionsSurveyQuestionIdValuesSurveyQuestionValueIdGet');
            }
            // verify required parameter 'surveyQuestionValueId' is set
            if (params.surveyQuestionValueId == null) {
                throw new Error('Missing required parameter surveyQuestionValueId when calling systemSurveysIdQuestionsSurveyQuestionIdValuesSurveyQuestionValueIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Survey Question Value
         * @param id
         * @param surveyQuestionId
         * @param surveyQuestionValueId
         * @param operations
         */
        public systemSurveysIdQuestionsSurveyQuestionIdValuesSurveyQuestionValueIdPatch (params: {  id: number; surveyQuestionId: number; surveyQuestionValueId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SurveyQuestionValue> {
            const localVarPath = this.basePath + '/system/surveys/{id}/questions/{surveyQuestionId}/values/{surveyQuestionValueId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'surveyQuestionId' + '}', String(params.surveyQuestionId))
                .replace('{' + 'surveyQuestionValueId' + '}', String(params.surveyQuestionValueId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSurveysIdQuestionsSurveyQuestionIdValuesSurveyQuestionValueIdPatch');
            }
            // verify required parameter 'surveyQuestionId' is set
            if (params.surveyQuestionId == null) {
                throw new Error('Missing required parameter surveyQuestionId when calling systemSurveysIdQuestionsSurveyQuestionIdValuesSurveyQuestionValueIdPatch');
            }
            // verify required parameter 'surveyQuestionValueId' is set
            if (params.surveyQuestionValueId == null) {
                throw new Error('Missing required parameter surveyQuestionValueId when calling systemSurveysIdQuestionsSurveyQuestionIdValuesSurveyQuestionValueIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemSurveysIdQuestionsSurveyQuestionIdValuesSurveyQuestionValueIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Survey Question Value
         * @param id
         * @param surveyQuestionId
         * @param surveyQuestionValueId
         * @param surveyQuestionValue
         */
        public systemSurveysIdQuestionsSurveyQuestionIdValuesSurveyQuestionValueIdPut (params: {  id: number; surveyQuestionId: number; surveyQuestionValueId: number; surveyQuestionValue: SurveyQuestionValue; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SurveyQuestionValue> {
            const localVarPath = this.basePath + '/system/surveys/{id}/questions/{surveyQuestionId}/values/{surveyQuestionValueId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'surveyQuestionId' + '}', String(params.surveyQuestionId))
                .replace('{' + 'surveyQuestionValueId' + '}', String(params.surveyQuestionValueId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSurveysIdQuestionsSurveyQuestionIdValuesSurveyQuestionValueIdPut');
            }
            // verify required parameter 'surveyQuestionId' is set
            if (params.surveyQuestionId == null) {
                throw new Error('Missing required parameter surveyQuestionId when calling systemSurveysIdQuestionsSurveyQuestionIdValuesSurveyQuestionValueIdPut');
            }
            // verify required parameter 'surveyQuestionValueId' is set
            if (params.surveyQuestionValueId == null) {
                throw new Error('Missing required parameter surveyQuestionValueId when calling systemSurveysIdQuestionsSurveyQuestionIdValuesSurveyQuestionValueIdPut');
            }
            // verify required parameter 'surveyQuestionValue' is set
            if (params.surveyQuestionValue == null) {
                throw new Error('Missing required parameter surveyQuestionValue when calling systemSurveysIdQuestionsSurveyQuestionIdValuesSurveyQuestionValueIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.surveyQuestionValue),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SurveyQuestionsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Survey Questions Count
         * @param id
         * @param conditions
         */
        public systemSurveysIdQuestionsGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/surveys/{id}/questions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSurveysIdQuestionsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Survey Question
         * @param id
         * @param surveyQuestion
         */
        public systemSurveysIdQuestionsPost (params: {  id: number; surveyQuestion: SurveyQuestion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SurveyQuestion> {
            const localVarPath = this.basePath + '/system/surveys/{id}/questions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSurveysIdQuestionsPost');
            }
            // verify required parameter 'surveyQuestion' is set
            if (params.surveyQuestion == null) {
                throw new Error('Missing required parameter surveyQuestion when calling systemSurveysIdQuestionsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.surveyQuestion),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Survey Question By Id
         * @param id
         * @param surveyQuestionId
         */
        public systemSurveysIdQuestionsSurveyQuestionIdDelete (params: {  id: number; surveyQuestionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/surveys/{id}/questions/{surveyQuestionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'surveyQuestionId' + '}', String(params.surveyQuestionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSurveysIdQuestionsSurveyQuestionIdDelete');
            }
            // verify required parameter 'surveyQuestionId' is set
            if (params.surveyQuestionId == null) {
                throw new Error('Missing required parameter surveyQuestionId when calling systemSurveysIdQuestionsSurveyQuestionIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Survey Question By Id
         * @param id
         * @param surveyQuestionId
         */
        public systemSurveysIdQuestionsSurveyQuestionIdGet (params: {  id: number; surveyQuestionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SurveyQuestion> {
            const localVarPath = this.basePath + '/system/surveys/{id}/questions/{surveyQuestionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'surveyQuestionId' + '}', String(params.surveyQuestionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSurveysIdQuestionsSurveyQuestionIdGet');
            }
            // verify required parameter 'surveyQuestionId' is set
            if (params.surveyQuestionId == null) {
                throw new Error('Missing required parameter surveyQuestionId when calling systemSurveysIdQuestionsSurveyQuestionIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Survey Question
         * @param id
         * @param surveyQuestionId
         * @param operations
         */
        public systemSurveysIdQuestionsSurveyQuestionIdPatch (params: {  id: number; surveyQuestionId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SurveyQuestion> {
            const localVarPath = this.basePath + '/system/surveys/{id}/questions/{surveyQuestionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'surveyQuestionId' + '}', String(params.surveyQuestionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSurveysIdQuestionsSurveyQuestionIdPatch');
            }
            // verify required parameter 'surveyQuestionId' is set
            if (params.surveyQuestionId == null) {
                throw new Error('Missing required parameter surveyQuestionId when calling systemSurveysIdQuestionsSurveyQuestionIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemSurveysIdQuestionsSurveyQuestionIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Survey Question
         * @param id
         * @param surveyQuestionId
         * @param surveyQuestion
         */
        public systemSurveysIdQuestionsSurveyQuestionIdPut (params: {  id: number; surveyQuestionId: number; surveyQuestion: SurveyQuestion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SurveyQuestion> {
            const localVarPath = this.basePath + '/system/surveys/{id}/questions/{surveyQuestionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'surveyQuestionId' + '}', String(params.surveyQuestionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSurveysIdQuestionsSurveyQuestionIdPut');
            }
            // verify required parameter 'surveyQuestionId' is set
            if (params.surveyQuestionId == null) {
                throw new Error('Missing required parameter surveyQuestionId when calling systemSurveysIdQuestionsSurveyQuestionIdPut');
            }
            // verify required parameter 'surveyQuestion' is set
            if (params.surveyQuestion == null) {
                throw new Error('Missing required parameter surveyQuestion when calling systemSurveysIdQuestionsSurveyQuestionIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.surveyQuestion),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SurveyResultsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Survey Results Count
         * @param id
         * @param conditions
         */
        public serviceSurveysIdResultsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/surveys/{id}/results/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdResultsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Survey Results
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceSurveysIdResultsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<SurveyResult>> {
            const localVarPath = this.basePath + '/service/surveys/{id}/results'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdResultsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Survey Result
         * @param id
         * @param surveyResult
         */
        public serviceSurveysIdResultsPost (params: {  id: number; surveyResult: SurveyResult; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SurveyResult> {
            const localVarPath = this.basePath + '/service/surveys/{id}/results'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdResultsPost');
            }
            // verify required parameter 'surveyResult' is set
            if (params.surveyResult == null) {
                throw new Error('Missing required parameter surveyResult when calling serviceSurveysIdResultsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.surveyResult),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Survey Result By Id
         * @param id
         * @param resultId
         */
        public serviceSurveysIdResultsResultIdDelete (params: {  id: number; resultId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/surveys/{id}/results/{resultId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'resultId' + '}', String(params.resultId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdResultsResultIdDelete');
            }
            // verify required parameter 'resultId' is set
            if (params.resultId == null) {
                throw new Error('Missing required parameter resultId when calling serviceSurveysIdResultsResultIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Survey Result By Id
         * @param id
         * @param resultId
         */
        public serviceSurveysIdResultsResultIdGet (params: {  id: number; resultId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SurveyResult> {
            const localVarPath = this.basePath + '/service/surveys/{id}/results/{resultId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'resultId' + '}', String(params.resultId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdResultsResultIdGet');
            }
            // verify required parameter 'resultId' is set
            if (params.resultId == null) {
                throw new Error('Missing required parameter resultId when calling serviceSurveysIdResultsResultIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Survey Result
         * @param id
         * @param resultId
         * @param operations
         */
        public serviceSurveysIdResultsResultIdPatch (params: {  id: number; resultId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SurveyResult> {
            const localVarPath = this.basePath + '/service/surveys/{id}/results/{resultId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'resultId' + '}', String(params.resultId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdResultsResultIdPatch');
            }
            // verify required parameter 'resultId' is set
            if (params.resultId == null) {
                throw new Error('Missing required parameter resultId when calling serviceSurveysIdResultsResultIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceSurveysIdResultsResultIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Survey Result
         * @param id
         * @param resultId
         * @param surveyResult
         */
        public serviceSurveysIdResultsResultIdPut (params: {  id: number; resultId: number; surveyResult: SurveyResult; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SurveyResult> {
            const localVarPath = this.basePath + '/service/surveys/{id}/results/{resultId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'resultId' + '}', String(params.resultId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceSurveysIdResultsResultIdPut');
            }
            // verify required parameter 'resultId' is set
            if (params.resultId == null) {
                throw new Error('Missing required parameter resultId when calling serviceSurveysIdResultsResultIdPut');
            }
            // verify required parameter 'surveyResult' is set
            if (params.surveyResult == null) {
                throw new Error('Missing required parameter surveyResult when calling serviceSurveysIdResultsResultIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.surveyResult),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SurveysApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Surveys Count
         * @param conditions
         */
        public systemSurveysCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/surveys/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Surveys
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemSurveysGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Survey>> {
            const localVarPath = this.basePath + '/system/surveys';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Survey By Id
         * @param id
         */
        public systemSurveysIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/surveys/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSurveysIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Survey By Id
         * @param id
         */
        public systemSurveysIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Survey> {
            const localVarPath = this.basePath + '/system/surveys/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSurveysIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Survey
         * @param id
         * @param operations
         */
        public systemSurveysIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Survey> {
            const localVarPath = this.basePath + '/system/surveys/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSurveysIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemSurveysIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Survey
         * @param id
         * @param survey
         */
        public systemSurveysIdPut (params: {  id: number; survey: Survey; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Survey> {
            const localVarPath = this.basePath + '/system/surveys/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemSurveysIdPut');
            }
            // verify required parameter 'survey' is set
            if (params.survey == null) {
                throw new Error('Missing required parameter survey when calling systemSurveysIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.survey),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Survey
         * @param survey
         */
        public systemSurveysPost (params: {  survey: Survey; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Survey> {
            const localVarPath = this.basePath + '/system/surveys';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'survey' is set
            if (params.survey == null) {
                throw new Error('Missing required parameter survey when calling systemSurveysPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.survey),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SystemTracksApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Trackses Count
         * @param conditions
         */
        public systemTracksCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/tracks/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Trackses
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemTracksGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Track>> {
            const localVarPath = this.basePath + '/system/tracks';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Tracks By Id
         * @param id
         */
        public systemTracksIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/tracks/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemTracksIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Tracks By Id
         * @param id
         */
        public systemTracksIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Track> {
            const localVarPath = this.basePath + '/system/tracks/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemTracksIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Tracks
         * @param id
         * @param operations
         */
        public systemTracksIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Track> {
            const localVarPath = this.basePath + '/system/tracks/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemTracksIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemTracksIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Tracks
         * @param id
         * @param track
         */
        public systemTracksIdPut (params: {  id: number; track: Track; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Track> {
            const localVarPath = this.basePath + '/system/tracks/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemTracksIdPut');
            }
            // verify required parameter 'track' is set
            if (params.track == null) {
                throw new Error('Missing required parameter track when calling systemTracksIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.track),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Tracks
         * @param track
         */
        public systemTracksPost (params: {  track: Track; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Track> {
            const localVarPath = this.basePath + '/system/tracks';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'track' is set
            if (params.track == null) {
                throw new Error('Missing required parameter track when calling systemTracksPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.track),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TaxCodeExpenseTypeExemptionsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Expense Type Exemption Count
         * @param id
         * @param conditions
         */
        public financeTaxCodesIdExpenseTypeExemptionsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/expenseTypeExemptions/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdExpenseTypeExemptionsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Expense Type Exemption By Id
         * @param id
         * @param expenseTypeExemptionId
         */
        public financeTaxCodesIdExpenseTypeExemptionsExpenseTypeExemptionIdDelete (params: {  id: number; expenseTypeExemptionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/expenseTypeExemptions/{expenseTypeExemptionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'expenseTypeExemptionId' + '}', String(params.expenseTypeExemptionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdExpenseTypeExemptionsExpenseTypeExemptionIdDelete');
            }
            // verify required parameter 'expenseTypeExemptionId' is set
            if (params.expenseTypeExemptionId == null) {
                throw new Error('Missing required parameter expenseTypeExemptionId when calling financeTaxCodesIdExpenseTypeExemptionsExpenseTypeExemptionIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Expense Type Exemption By Id
         * @param id
         * @param expenseTypeExemptionId
         */
        public financeTaxCodesIdExpenseTypeExemptionsExpenseTypeExemptionIdGet (params: {  id: number; expenseTypeExemptionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ExpenseTypeExemption> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/expenseTypeExemptions/{expenseTypeExemptionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'expenseTypeExemptionId' + '}', String(params.expenseTypeExemptionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdExpenseTypeExemptionsExpenseTypeExemptionIdGet');
            }
            // verify required parameter 'expenseTypeExemptionId' is set
            if (params.expenseTypeExemptionId == null) {
                throw new Error('Missing required parameter expenseTypeExemptionId when calling financeTaxCodesIdExpenseTypeExemptionsExpenseTypeExemptionIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Expense Type Exemption
         * @param id
         * @param expenseTypeExemptionId
         * @param operations
         */
        public financeTaxCodesIdExpenseTypeExemptionsExpenseTypeExemptionIdPatch (params: {  id: number; expenseTypeExemptionId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ExpenseTypeExemption> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/expenseTypeExemptions/{expenseTypeExemptionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'expenseTypeExemptionId' + '}', String(params.expenseTypeExemptionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdExpenseTypeExemptionsExpenseTypeExemptionIdPatch');
            }
            // verify required parameter 'expenseTypeExemptionId' is set
            if (params.expenseTypeExemptionId == null) {
                throw new Error('Missing required parameter expenseTypeExemptionId when calling financeTaxCodesIdExpenseTypeExemptionsExpenseTypeExemptionIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeTaxCodesIdExpenseTypeExemptionsExpenseTypeExemptionIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Expense Type Exemption
         * @param id
         * @param expenseTypeExemptionId
         * @param expenseTypeExemption
         */
        public financeTaxCodesIdExpenseTypeExemptionsExpenseTypeExemptionIdPut (params: {  id: number; expenseTypeExemptionId: number; expenseTypeExemption: ExpenseTypeExemption; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ExpenseTypeExemption> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/expenseTypeExemptions/{expenseTypeExemptionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'expenseTypeExemptionId' + '}', String(params.expenseTypeExemptionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdExpenseTypeExemptionsExpenseTypeExemptionIdPut');
            }
            // verify required parameter 'expenseTypeExemptionId' is set
            if (params.expenseTypeExemptionId == null) {
                throw new Error('Missing required parameter expenseTypeExemptionId when calling financeTaxCodesIdExpenseTypeExemptionsExpenseTypeExemptionIdPut');
            }
            // verify required parameter 'expenseTypeExemption' is set
            if (params.expenseTypeExemption == null) {
                throw new Error('Missing required parameter expenseTypeExemption when calling financeTaxCodesIdExpenseTypeExemptionsExpenseTypeExemptionIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.expenseTypeExemption),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Expense Type Exemption
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeTaxCodesIdExpenseTypeExemptionsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ExpenseTypeExemption>> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/expenseTypeExemptions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdExpenseTypeExemptionsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Expense Type Exemption
         * @param id
         * @param expenseTypeExemption
         */
        public financeTaxCodesIdExpenseTypeExemptionsPost (params: {  id: number; expenseTypeExemption: ExpenseTypeExemption; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ExpenseTypeExemption> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/expenseTypeExemptions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdExpenseTypeExemptionsPost');
            }
            // verify required parameter 'expenseTypeExemption' is set
            if (params.expenseTypeExemption == null) {
                throw new Error('Missing required parameter expenseTypeExemption when calling financeTaxCodesIdExpenseTypeExemptionsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.expenseTypeExemption),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TaxCodeProductTypeExemptionsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Tax Code Product Type Exemption Count
         * @param id
         * @param conditions
         */
        public financeTaxCodesIdProductTypeExemptionsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/productTypeExemptions/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdProductTypeExemptionsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Tax Code Product Type Exemption
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeTaxCodesIdProductTypeExemptionsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductTypeExemption>> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/productTypeExemptions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdProductTypeExemptionsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Tax Code Product Type Exemption
         * @param id
         * @param productTypeExemption
         */
        public financeTaxCodesIdProductTypeExemptionsPost (params: {  id: number; productTypeExemption: ProductTypeExemption; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProductTypeExemption> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/productTypeExemptions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdProductTypeExemptionsPost');
            }
            // verify required parameter 'productTypeExemption' is set
            if (params.productTypeExemption == null) {
                throw new Error('Missing required parameter productTypeExemption when calling financeTaxCodesIdProductTypeExemptionsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.productTypeExemption),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Tax Code Product Type Exemption By Id
         * @param id
         * @param productTypeExemptionId
         */
        public financeTaxCodesIdProductTypeExemptionsProductTypeExemptionIdDelete (params: {  id: number; productTypeExemptionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/productTypeExemptions/{productTypeExemptionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'productTypeExemptionId' + '}', String(params.productTypeExemptionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdProductTypeExemptionsProductTypeExemptionIdDelete');
            }
            // verify required parameter 'productTypeExemptionId' is set
            if (params.productTypeExemptionId == null) {
                throw new Error('Missing required parameter productTypeExemptionId when calling financeTaxCodesIdProductTypeExemptionsProductTypeExemptionIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Tax Code Product Type Exemption By Id
         * @param id
         * @param productTypeExemptionId
         */
        public financeTaxCodesIdProductTypeExemptionsProductTypeExemptionIdGet (params: {  id: number; productTypeExemptionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProductTypeExemption> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/productTypeExemptions/{productTypeExemptionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'productTypeExemptionId' + '}', String(params.productTypeExemptionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdProductTypeExemptionsProductTypeExemptionIdGet');
            }
            // verify required parameter 'productTypeExemptionId' is set
            if (params.productTypeExemptionId == null) {
                throw new Error('Missing required parameter productTypeExemptionId when calling financeTaxCodesIdProductTypeExemptionsProductTypeExemptionIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Tax Code Product Type Exemption
         * @param id
         * @param productTypeExemptionId
         * @param operations
         */
        public financeTaxCodesIdProductTypeExemptionsProductTypeExemptionIdPatch (params: {  id: number; productTypeExemptionId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProductTypeExemption> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/productTypeExemptions/{productTypeExemptionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'productTypeExemptionId' + '}', String(params.productTypeExemptionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdProductTypeExemptionsProductTypeExemptionIdPatch');
            }
            // verify required parameter 'productTypeExemptionId' is set
            if (params.productTypeExemptionId == null) {
                throw new Error('Missing required parameter productTypeExemptionId when calling financeTaxCodesIdProductTypeExemptionsProductTypeExemptionIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeTaxCodesIdProductTypeExemptionsProductTypeExemptionIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Tax Code Product Type Exemption
         * @param id
         * @param productTypeExemptionId
         * @param productTypeExemption
         */
        public financeTaxCodesIdProductTypeExemptionsProductTypeExemptionIdPut (params: {  id: number; productTypeExemptionId: number; productTypeExemption: ProductTypeExemption; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProductTypeExemption> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/productTypeExemptions/{productTypeExemptionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'productTypeExemptionId' + '}', String(params.productTypeExemptionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdProductTypeExemptionsProductTypeExemptionIdPut');
            }
            // verify required parameter 'productTypeExemptionId' is set
            if (params.productTypeExemptionId == null) {
                throw new Error('Missing required parameter productTypeExemptionId when calling financeTaxCodesIdProductTypeExemptionsProductTypeExemptionIdPut');
            }
            // verify required parameter 'productTypeExemption' is set
            if (params.productTypeExemption == null) {
                throw new Error('Missing required parameter productTypeExemption when calling financeTaxCodesIdProductTypeExemptionsProductTypeExemptionIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.productTypeExemption),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TaxCodeWorkRoleExemptionsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Tax Code Work Role Exemption Count
         * @param id
         * @param conditions
         */
        public financeTaxCodesIdWorkRoleExemptionsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/workRoleExemptions/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdWorkRoleExemptionsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Tax Code Work Role Exemption
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeTaxCodesIdWorkRoleExemptionsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<WorkRoleExemption>> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/workRoleExemptions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdWorkRoleExemptionsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Tax Code Work Role Exemption
         * @param id
         * @param workRoleExemption
         */
        public financeTaxCodesIdWorkRoleExemptionsPost (params: {  id: number; workRoleExemption: WorkRoleExemption; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WorkRoleExemption> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/workRoleExemptions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdWorkRoleExemptionsPost');
            }
            // verify required parameter 'workRoleExemption' is set
            if (params.workRoleExemption == null) {
                throw new Error('Missing required parameter workRoleExemption when calling financeTaxCodesIdWorkRoleExemptionsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.workRoleExemption),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Tax Code Work Role Exemption By Id
         * @param id
         * @param workRoleExemptionId
         */
        public financeTaxCodesIdWorkRoleExemptionsWorkRoleExemptionIdDelete (params: {  id: number; workRoleExemptionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/workRoleExemptions/{workRoleExemptionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'workRoleExemptionId' + '}', String(params.workRoleExemptionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdWorkRoleExemptionsWorkRoleExemptionIdDelete');
            }
            // verify required parameter 'workRoleExemptionId' is set
            if (params.workRoleExemptionId == null) {
                throw new Error('Missing required parameter workRoleExemptionId when calling financeTaxCodesIdWorkRoleExemptionsWorkRoleExemptionIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Tax Code Work Role Exemption By Id
         * @param id
         * @param workRoleExemptionId
         */
        public financeTaxCodesIdWorkRoleExemptionsWorkRoleExemptionIdGet (params: {  id: number; workRoleExemptionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WorkRoleExemption> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/workRoleExemptions/{workRoleExemptionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'workRoleExemptionId' + '}', String(params.workRoleExemptionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdWorkRoleExemptionsWorkRoleExemptionIdGet');
            }
            // verify required parameter 'workRoleExemptionId' is set
            if (params.workRoleExemptionId == null) {
                throw new Error('Missing required parameter workRoleExemptionId when calling financeTaxCodesIdWorkRoleExemptionsWorkRoleExemptionIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Tax Code Work Role Exemption
         * @param id
         * @param workRoleExemptionId
         * @param operations
         */
        public financeTaxCodesIdWorkRoleExemptionsWorkRoleExemptionIdPatch (params: {  id: number; workRoleExemptionId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WorkRoleExemption> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/workRoleExemptions/{workRoleExemptionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'workRoleExemptionId' + '}', String(params.workRoleExemptionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdWorkRoleExemptionsWorkRoleExemptionIdPatch');
            }
            // verify required parameter 'workRoleExemptionId' is set
            if (params.workRoleExemptionId == null) {
                throw new Error('Missing required parameter workRoleExemptionId when calling financeTaxCodesIdWorkRoleExemptionsWorkRoleExemptionIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeTaxCodesIdWorkRoleExemptionsWorkRoleExemptionIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Tax Code Work Role Exemption
         * @param id
         * @param workRoleExemptionId
         * @param workRoleExemption
         */
        public financeTaxCodesIdWorkRoleExemptionsWorkRoleExemptionIdPut (params: {  id: number; workRoleExemptionId: number; workRoleExemption: WorkRoleExemption; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WorkRoleExemption> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/workRoleExemptions/{workRoleExemptionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'workRoleExemptionId' + '}', String(params.workRoleExemptionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdWorkRoleExemptionsWorkRoleExemptionIdPut');
            }
            // verify required parameter 'workRoleExemptionId' is set
            if (params.workRoleExemptionId == null) {
                throw new Error('Missing required parameter workRoleExemptionId when calling financeTaxCodesIdWorkRoleExemptionsWorkRoleExemptionIdPut');
            }
            // verify required parameter 'workRoleExemption' is set
            if (params.workRoleExemption == null) {
                throw new Error('Missing required parameter workRoleExemption when calling financeTaxCodesIdWorkRoleExemptionsWorkRoleExemptionIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.workRoleExemption),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TaxCodeXRefsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Tax Code X Ref Count
         * @param id
         * @param conditions
         */
        public financeTaxCodesIdTaxCodeXRefsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/taxCodeXRefs/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdTaxCodeXRefsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Tax Code X Ref
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeTaxCodesIdTaxCodeXRefsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<TaxCodeXRef>> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/taxCodeXRefs'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdTaxCodeXRefsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Tax Code X Ref
         * @param id
         * @param taxCodeXRef
         */
        public financeTaxCodesIdTaxCodeXRefsPost (params: {  id: number; taxCodeXRef: TaxCodeXRef; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TaxCodeXRef> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/taxCodeXRefs'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdTaxCodeXRefsPost');
            }
            // verify required parameter 'taxCodeXRef' is set
            if (params.taxCodeXRef == null) {
                throw new Error('Missing required parameter taxCodeXRef when calling financeTaxCodesIdTaxCodeXRefsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.taxCodeXRef),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Tax Code X Ref By Id
         * @param id
         * @param taxCodeXRefId
         */
        public financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdDelete (params: {  id: number; taxCodeXRefId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/taxCodeXRefs/{taxCodeXRefId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'taxCodeXRefId' + '}', String(params.taxCodeXRefId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdDelete');
            }
            // verify required parameter 'taxCodeXRefId' is set
            if (params.taxCodeXRefId == null) {
                throw new Error('Missing required parameter taxCodeXRefId when calling financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Tax Code X Ref By Id
         * @param id
         * @param taxCodeXRefId
         */
        public financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdGet (params: {  id: number; taxCodeXRefId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TaxCodeXRef> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/taxCodeXRefs/{taxCodeXRefId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'taxCodeXRefId' + '}', String(params.taxCodeXRefId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdGet');
            }
            // verify required parameter 'taxCodeXRefId' is set
            if (params.taxCodeXRefId == null) {
                throw new Error('Missing required parameter taxCodeXRefId when calling financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Tax Code X Ref
         * @param id
         * @param taxCodeXRefId
         * @param operations
         */
        public financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdPatch (params: {  id: number; taxCodeXRefId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TaxCodeXRef> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/taxCodeXRefs/{taxCodeXRefId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'taxCodeXRefId' + '}', String(params.taxCodeXRefId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdPatch');
            }
            // verify required parameter 'taxCodeXRefId' is set
            if (params.taxCodeXRefId == null) {
                throw new Error('Missing required parameter taxCodeXRefId when calling financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Tax Code X Ref
         * @param id
         * @param taxCodeXRefId
         * @param taxCodeXRef
         */
        public financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdPut (params: {  id: number; taxCodeXRefId: number; taxCodeXRef: TaxCodeXRef; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TaxCodeXRef> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}/taxCodeXRefs/{taxCodeXRefId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'taxCodeXRefId' + '}', String(params.taxCodeXRefId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdPut');
            }
            // verify required parameter 'taxCodeXRefId' is set
            if (params.taxCodeXRefId == null) {
                throw new Error('Missing required parameter taxCodeXRefId when calling financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdPut');
            }
            // verify required parameter 'taxCodeXRef' is set
            if (params.taxCodeXRef == null) {
                throw new Error('Missing required parameter taxCodeXRef when calling financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.taxCodeXRef),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TaxCodesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Tax Code Count
         * @param conditions
         */
        public financeTaxCodesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/finance/taxCodes/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Tax Code
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public financeTaxCodesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<TaxCode>> {
            const localVarPath = this.basePath + '/finance/taxCodes';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Tax Code By Id
         * @param id
         */
        public financeTaxCodesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Tax Code By Id
         * @param id
         */
        public financeTaxCodesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TaxCode> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Tax Code
         * @param id
         * @param operations
         */
        public financeTaxCodesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TaxCode> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling financeTaxCodesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Tax Code
         * @param id
         * @param taxCode
         */
        public financeTaxCodesIdPut (params: {  id: number; taxCode: TaxCode; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TaxCode> {
            const localVarPath = this.basePath + '/finance/taxCodes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling financeTaxCodesIdPut');
            }
            // verify required parameter 'taxCode' is set
            if (params.taxCode == null) {
                throw new Error('Missing required parameter taxCode when calling financeTaxCodesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.taxCode),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Tax Code
         * @param taxCode
         */
        public financeTaxCodesPost (params: {  taxCode: TaxCode; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TaxCode> {
            const localVarPath = this.basePath + '/finance/taxCodes';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'taxCode' is set
            if (params.taxCode == null) {
                throw new Error('Missing required parameter taxCode when calling financeTaxCodesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.taxCode),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TaxIntegrationsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Tax Integrations Count
         * @param conditions
         */
        public systemTaxIntegrationsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/taxIntegrations/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Tax Integrations
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemTaxIntegrationsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<TaxIntegration>> {
            const localVarPath = this.basePath + '/system/taxIntegrations';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Tax Integration By Id
         * @param id
         */
        public systemTaxIntegrationsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TaxIntegration> {
            const localVarPath = this.basePath + '/system/taxIntegrations/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemTaxIntegrationsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TeamMembersApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Team Members Count
         * @param conditions
         */
        public serviceTeamMembersCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/teamMembers/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Team Members
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceTeamMembersGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<TeamMember>> {
            const localVarPath = this.basePath + '/service/teamMembers';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Team By Id
         * @param id
         */
        public serviceTeamMembersIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/teamMembers/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTeamMembersIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Team Member By Id
         * @param id
         */
        public serviceTeamMembersIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TeamMember> {
            const localVarPath = this.basePath + '/service/teamMembers/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTeamMembersIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Team Member
         * @param teamMember
         */
        public serviceTeamMembersPost (params: {  teamMember: TeamMember; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TeamMember> {
            const localVarPath = this.basePath + '/service/teamMembers';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'teamMember' is set
            if (params.teamMember == null) {
                throw new Error('Missing required parameter teamMember when calling serviceTeamMembersPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.teamMember),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TeamRolesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Team Role Count
         * @param conditions
         */
        public companyTeamRolesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/company/teamRoles/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Team Role
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public companyTeamRolesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<TeamRole>> {
            const localVarPath = this.basePath + '/company/teamRoles';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Team Role By Id
         * @param id
         */
        public companyTeamRolesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/company/teamRoles/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyTeamRolesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Team Role By Id
         * @param id
         */
        public companyTeamRolesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TeamRole> {
            const localVarPath = this.basePath + '/company/teamRoles/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyTeamRolesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Team Role
         * @param id
         * @param operations
         */
        public companyTeamRolesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TeamRole> {
            const localVarPath = this.basePath + '/company/teamRoles/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyTeamRolesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling companyTeamRolesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Team Role
         * @param id
         * @param teamRole
         */
        public companyTeamRolesIdPut (params: {  id: number; teamRole: TeamRole; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TeamRole> {
            const localVarPath = this.basePath + '/company/teamRoles/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling companyTeamRolesIdPut');
            }
            // verify required parameter 'teamRole' is set
            if (params.teamRole == null) {
                throw new Error('Missing required parameter teamRole when calling companyTeamRolesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.teamRole),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Team Role
         * @param teamRole
         */
        public companyTeamRolesPost (params: {  teamRole: TeamRole; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TeamRole> {
            const localVarPath = this.basePath + '/company/teamRoles';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'teamRole' is set
            if (params.teamRole == null) {
                throw new Error('Missing required parameter teamRole when calling companyTeamRolesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.teamRole),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TicketNotesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Service Notes Count
         * @param id
         * @param conditions
         */
        public serviceTicketsIdNotesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/tickets/{id}/notes/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdNotesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Service Notes
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceTicketsIdNotesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ServiceNote>> {
            const localVarPath = this.basePath + '/service/tickets/{id}/notes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdNotesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Service Note By Id
         * @param id
         * @param noteId
         */
        public serviceTicketsIdNotesNoteIdDelete (params: {  id: number; noteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/tickets/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdNotesNoteIdDelete');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling serviceTicketsIdNotesNoteIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Service Note By Id
         * @param id
         * @param noteId
         */
        public serviceTicketsIdNotesNoteIdGet (params: {  id: number; noteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ServiceNote> {
            const localVarPath = this.basePath + '/service/tickets/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdNotesNoteIdGet');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling serviceTicketsIdNotesNoteIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Service Note
         * @param id
         * @param noteId
         * @param operations
         */
        public serviceTicketsIdNotesNoteIdPatch (params: {  id: number; noteId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ServiceNote> {
            const localVarPath = this.basePath + '/service/tickets/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdNotesNoteIdPatch');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling serviceTicketsIdNotesNoteIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceTicketsIdNotesNoteIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Service Note
         * @param id
         * @param noteId
         * @param serviceNote
         */
        public serviceTicketsIdNotesNoteIdPut (params: {  id: number; noteId: number; serviceNote: ServiceNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ServiceNote> {
            const localVarPath = this.basePath + '/service/tickets/{id}/notes/{noteId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'noteId' + '}', String(params.noteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdNotesNoteIdPut');
            }
            // verify required parameter 'noteId' is set
            if (params.noteId == null) {
                throw new Error('Missing required parameter noteId when calling serviceTicketsIdNotesNoteIdPut');
            }
            // verify required parameter 'serviceNote' is set
            if (params.serviceNote == null) {
                throw new Error('Missing required parameter serviceNote when calling serviceTicketsIdNotesNoteIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.serviceNote),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Service Note
         * @param id
         * @param serviceNote
         */
        public serviceTicketsIdNotesPost (params: {  id: number; serviceNote: ServiceNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ServiceNote> {
            const localVarPath = this.basePath + '/service/tickets/{id}/notes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdNotesPost');
            }
            // verify required parameter 'serviceNote' is set
            if (params.serviceNote == null) {
                throw new Error('Missing required parameter serviceNote when calling serviceTicketsIdNotesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.serviceNote),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TicketStopwatchesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Ticket Stopwatches Count
         * @param conditions
         */
        public timeTicketstopwatchesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/time/ticketstopwatches/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Ticket Stopwatches
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public timeTicketstopwatchesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<TicketStopwatch>> {
            const localVarPath = this.basePath + '/time/ticketstopwatches';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Ticket Stopwatch By Id
         * @param id
         */
        public timeTicketstopwatchesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/time/ticketstopwatches/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeTicketstopwatchesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Ticket Stopwatch By Id
         * @param id
         */
        public timeTicketstopwatchesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TicketStopwatch> {
            const localVarPath = this.basePath + '/time/ticketstopwatches/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeTicketstopwatchesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Ticket Stopwatch
         * @param id
         * @param operations
         */
        public timeTicketstopwatchesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TicketStopwatch> {
            const localVarPath = this.basePath + '/time/ticketstopwatches/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeTicketstopwatchesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling timeTicketstopwatchesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Ticket Stopwatch
         * @param id
         * @param ticketStopwatch
         */
        public timeTicketstopwatchesIdPut (params: {  id: number; ticketStopwatch: TicketStopwatch; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TicketStopwatch> {
            const localVarPath = this.basePath + '/time/ticketstopwatches/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeTicketstopwatchesIdPut');
            }
            // verify required parameter 'ticketStopwatch' is set
            if (params.ticketStopwatch == null) {
                throw new Error('Missing required parameter ticketStopwatch when calling timeTicketstopwatchesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.ticketStopwatch),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Ticket Stopwatch
         * @param ticketStopwatch
         */
        public timeTicketstopwatchesPost (params: {  ticketStopwatch: TicketStopwatch; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TicketStopwatch> {
            const localVarPath = this.basePath + '/time/ticketstopwatches';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'ticketStopwatch' is set
            if (params.ticketStopwatch == null) {
                throw new Error('Missing required parameter ticketStopwatch when calling timeTicketstopwatchesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.ticketStopwatch),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TicketSyncsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Ticket Syncs Count
         * @param conditions
         */
        public systemTicketSyncsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/ticketSyncs/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Ticket Syncs
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemTicketSyncsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<TicketSync>> {
            const localVarPath = this.basePath + '/system/ticketSyncs';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Ticket Sync By Id
         * @param id
         */
        public systemTicketSyncsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/ticketSyncs/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemTicketSyncsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Ticket Sync By Id
         * @param id
         */
        public systemTicketSyncsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TicketSync> {
            const localVarPath = this.basePath + '/system/ticketSyncs/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemTicketSyncsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Ticket Sync
         * @param id
         * @param operations
         */
        public systemTicketSyncsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TicketSync> {
            const localVarPath = this.basePath + '/system/ticketSyncs/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemTicketSyncsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemTicketSyncsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Ticket Sync
         * @param id
         * @param ticketSync
         */
        public systemTicketSyncsIdPut (params: {  id: number; ticketSync: TicketSync; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TicketSync> {
            const localVarPath = this.basePath + '/system/ticketSyncs/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemTicketSyncsIdPut');
            }
            // verify required parameter 'ticketSync' is set
            if (params.ticketSync == null) {
                throw new Error('Missing required parameter ticketSync when calling systemTicketSyncsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.ticketSync),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Ticket Sync
         * @param ticketSync
         */
        public systemTicketSyncsPost (params: {  ticketSync: TicketSync; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TicketSync> {
            const localVarPath = this.basePath + '/system/ticketSyncs';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'ticketSync' is set
            if (params.ticketSync == null) {
                throw new Error('Missing required parameter ticketSync when calling systemTicketSyncsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.ticketSync),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TicketTasksApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Tasks Count
         * @param id
         * @param conditions
         */
        public serviceTicketsIdTasksCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/tickets/{id}/tasks/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdTasksCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Tasks
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceTicketsIdTasksGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Task>> {
            const localVarPath = this.basePath + '/service/tickets/{id}/tasks'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdTasksGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Task
         * @param id
         * @param task
         */
        public serviceTicketsIdTasksPost (params: {  id: number; task: Task; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Task> {
            const localVarPath = this.basePath + '/service/tickets/{id}/tasks'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdTasksPost');
            }
            // verify required parameter 'task' is set
            if (params.task == null) {
                throw new Error('Missing required parameter task when calling serviceTicketsIdTasksPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.task),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Task By Id
         * @param id
         * @param taskId
         */
        public serviceTicketsIdTasksTaskIdDelete (params: {  id: number; taskId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/tickets/{id}/tasks/{taskId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'taskId' + '}', String(params.taskId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdTasksTaskIdDelete');
            }
            // verify required parameter 'taskId' is set
            if (params.taskId == null) {
                throw new Error('Missing required parameter taskId when calling serviceTicketsIdTasksTaskIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Task By Id
         * @param id
         * @param taskId
         */
        public serviceTicketsIdTasksTaskIdGet (params: {  id: number; taskId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Task> {
            const localVarPath = this.basePath + '/service/tickets/{id}/tasks/{taskId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'taskId' + '}', String(params.taskId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdTasksTaskIdGet');
            }
            // verify required parameter 'taskId' is set
            if (params.taskId == null) {
                throw new Error('Missing required parameter taskId when calling serviceTicketsIdTasksTaskIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Task
         * @param id
         * @param taskId
         * @param operations
         */
        public serviceTicketsIdTasksTaskIdPatch (params: {  id: number; taskId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Task> {
            const localVarPath = this.basePath + '/service/tickets/{id}/tasks/{taskId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'taskId' + '}', String(params.taskId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdTasksTaskIdPatch');
            }
            // verify required parameter 'taskId' is set
            if (params.taskId == null) {
                throw new Error('Missing required parameter taskId when calling serviceTicketsIdTasksTaskIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceTicketsIdTasksTaskIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Task
         * @param id
         * @param taskId
         * @param task
         */
        public serviceTicketsIdTasksTaskIdPut (params: {  id: number; taskId: number; task: Task; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Task> {
            const localVarPath = this.basePath + '/service/tickets/{id}/tasks/{taskId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'taskId' + '}', String(params.taskId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdTasksTaskIdPut');
            }
            // verify required parameter 'taskId' is set
            if (params.taskId == null) {
                throw new Error('Missing required parameter taskId when calling serviceTicketsIdTasksTaskIdPut');
            }
            // verify required parameter 'task' is set
            if (params.task == null) {
                throw new Error('Missing required parameter task when calling serviceTicketsIdTasksTaskIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.task),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TicketsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Tickets Count
         * @param conditions
         * @param customFieldConditions
         */
        public serviceTicketsCountGet (params: {  conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/tickets/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.customFieldConditions !== undefined) {
                queryParameters['customFieldConditions'] = params.customFieldConditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Tickets
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public serviceTicketsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Ticket>> {
            const localVarPath = this.basePath + '/service/tickets';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Gets count of activities associated to the ticket          /// Please use the /sales/activities/count?conditions&#x3D;ticket/id&#x3D;{id} endpoint
         * @param id
         */
        public serviceTicketsIdActivitiesCountGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/tickets/{id}/activities/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdActivitiesCountGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Gets activities associated to the ticket          /// Please use the /sales/activities?conditions&#x3D;ticket/id&#x3D;{id} endpoint
         * @param id
         * @param page
         * @param pageSize
         */
        public serviceTicketsIdActivitiesGet (params: {  id: number; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ActivityReference>> {
            const localVarPath = this.basePath + '/service/tickets/{id}/activities'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdActivitiesGet');
            }
            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Configuration Association
         * @param id
         * @param configId
         */
        public serviceTicketsIdConfigurationsConfigIdDelete (params: {  id: number; configId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/tickets/{id}/configurations/{configId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'configId' + '}', String(params.configId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdConfigurationsConfigIdDelete');
            }
            // verify required parameter 'configId' is set
            if (params.configId == null) {
                throw new Error('Missing required parameter configId when calling serviceTicketsIdConfigurationsConfigIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Configuration Association
         * @param id
         * @param configId
         */
        public serviceTicketsIdConfigurationsConfigIdGet (params: {  id: number; configId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationReference> {
            const localVarPath = this.basePath + '/service/tickets/{id}/configurations/{configId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'configId' + '}', String(params.configId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdConfigurationsConfigIdGet');
            }
            // verify required parameter 'configId' is set
            if (params.configId == null) {
                throw new Error('Missing required parameter configId when calling serviceTicketsIdConfigurationsConfigIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Ticket Configurations Count
         * @param id
         */
        public serviceTicketsIdConfigurationsCountGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/tickets/{id}/configurations/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdConfigurationsCountGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Ticket Configurations
         * @param id
         * @param page
         * @param pageSize
         */
        public serviceTicketsIdConfigurationsGet (params: {  id: number; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ConfigurationReference>> {
            const localVarPath = this.basePath + '/service/tickets/{id}/configurations'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdConfigurationsGet');
            }
            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Configuration Association
         * @param id
         * @param configuration
         */
        public serviceTicketsIdConfigurationsPost (params: {  id: number; configuration: ConfigurationReference; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationReference> {
            const localVarPath = this.basePath + '/service/tickets/{id}/configurations'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdConfigurationsPost');
            }
            // verify required parameter 'configuration' is set
            if (params.configuration == null) {
                throw new Error('Missing required parameter configuration when calling serviceTicketsIdConfigurationsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.configuration),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Ticket By Id
         * @param id
         */
        public serviceTicketsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/service/tickets/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Ticket Documents Count
         * @param id
         */
        public serviceTicketsIdDocumentsCountGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/tickets/{id}/documents/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdDocumentsCountGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Gets the documents associated to the ticket          /// Please use the /system/documents?recordType&#x3D;Ticket&amp;amp;recordId&#x3D;{id} endpoint
         * @param id
         * @param page
         * @param pageSize
         */
        public serviceTicketsIdDocumentsGet (params: {  id: number; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<DocumentReference>> {
            const localVarPath = this.basePath + '/service/tickets/{id}/documents'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdDocumentsGet');
            }
            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Ticket By Id
         * @param id
         */
        public serviceTicketsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Ticket> {
            const localVarPath = this.basePath + '/service/tickets/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Merge Company
         * @param id
         * @param merge
         */
        public serviceTicketsIdMergePost (params: {  id: number; merge: TicketMerge; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SuccessResponse> {
            const localVarPath = this.basePath + '/service/tickets/{id}/merge'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdMergePost');
            }
            // verify required parameter 'merge' is set
            if (params.merge == null) {
                throw new Error('Missing required parameter merge when calling serviceTicketsIdMergePost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.merge),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Ticket
         * @param id
         * @param operations
         */
        public serviceTicketsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Ticket> {
            const localVarPath = this.basePath + '/service/tickets/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling serviceTicketsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Gets the products associated to the ticket          /// Please use the /procurement/products/count?conditions&#x3D;chargeToType&#x3D;&#39;Ticket&#39; AND chargeToId&#x3D;{id} endpoint
         * @param id
         */
        public serviceTicketsIdProductsCountGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/tickets/{id}/products/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdProductsCountGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Gets the products associated to the ticket          /// Please use the /procurement/products?conditions&#x3D;chargeToType&#x3D;&#39;Ticket&#39; AND chargeToId&#x3D;{id} endpoint
         * @param id
         * @param page
         * @param pageSize
         */
        public serviceTicketsIdProductsGet (params: {  id: number; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductReference>> {
            const localVarPath = this.basePath + '/service/tickets/{id}/products'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdProductsGet');
            }
            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Ticket
         * @param id
         * @param ticket
         */
        public serviceTicketsIdPut (params: {  id: number; ticket: Ticket; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Ticket> {
            const localVarPath = this.basePath + '/service/tickets/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdPut');
            }
            // verify required parameter 'ticket' is set
            if (params.ticket == null) {
                throw new Error('Missing required parameter ticket when calling serviceTicketsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.ticket),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Gets the schedule entries count associated to the ticket          /// Please use the /schedule/entries/count?conditions&#x3D;type/id&#x3D;4 AND objectId&#x3D;{id} endpoint
         * @param id
         */
        public serviceTicketsIdScheduleentriesCountGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/tickets/{id}/scheduleentries/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdScheduleentriesCountGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Gets the schedule entries associated to the ticket          /// Please use the /schedule/entries?conditions&#x3D;type/id&#x3D;4 AND objectId&#x3D;{id} endpoint
         * @param id
         * @param page
         * @param pageSize
         */
        public serviceTicketsIdScheduleentriesGet (params: {  id: number; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ScheduleEntryReference>> {
            const localVarPath = this.basePath + '/service/tickets/{id}/scheduleentries'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdScheduleentriesGet');
            }
            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Gets time entries count associated to the ticket          /// Please use the /time/entries/count?conditions&#x3D;(chargeToType&#x3D;&quot;ServiceTicket&quot; OR chargeToType&#x3D;&quot;ProjectTicket&quot;) AND chargeToId&#x3D;{id} endpoint
         * @param id
         */
        public serviceTicketsIdTimeentriesCountGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/service/tickets/{id}/timeentries/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdTimeentriesCountGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Gets time entries associated to the ticket          /// Please use the /time/entries?conditions&#x3D;(chargeToType&#x3D;&quot;ServiceTicket&quot; OR chargeToType&#x3D;&quot;ProjectTicket&quot;) AND chargeToId&#x3D;{id} endpoint
         * @param id
         * @param page
         * @param pageSize
         */
        public serviceTicketsIdTimeentriesGet (params: {  id: number; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<TimeEntryReference>> {
            const localVarPath = this.basePath + '/service/tickets/{id}/timeentries'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling serviceTicketsIdTimeentriesGet');
            }
            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Ticket
         * @param ticket
         */
        public serviceTicketsPost (params: {  ticket: Ticket; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Ticket> {
            const localVarPath = this.basePath + '/service/tickets';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'ticket' is set
            if (params.ticket == null) {
                throw new Error('Missing required parameter ticket when calling serviceTicketsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.ticket),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Ticket Search
         * @param filterValues
         * @param page
         * @param pageSize
         */
        public serviceTicketsSearchPost (params: {  filterValues: FilterValues; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Ticket>> {
            const localVarPath = this.basePath + '/service/tickets/search';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'filterValues' is set
            if (params.filterValues == null) {
                throw new Error('Missing required parameter filterValues when calling serviceTicketsSearchPost');
            }
            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.filterValues),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TimeAccrualDetailsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Time Accrual Detail Count
         * @param id
         * @param conditions
         */
        public timeAccrualsIdDetailsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/time/accruals/{id}/details/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeAccrualsIdDetailsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Time Accrual Detail By Id
         * @param id
         * @param detailId
         */
        public timeAccrualsIdDetailsDetailIdDelete (params: {  id: number; detailId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/time/accruals/{id}/details/{detailId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'detailId' + '}', String(params.detailId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeAccrualsIdDetailsDetailIdDelete');
            }
            // verify required parameter 'detailId' is set
            if (params.detailId == null) {
                throw new Error('Missing required parameter detailId when calling timeAccrualsIdDetailsDetailIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Time Accrual Detail By Id
         * @param id
         * @param detailId
         */
        public timeAccrualsIdDetailsDetailIdGet (params: {  id: number; detailId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TimeAccrualDetail> {
            const localVarPath = this.basePath + '/time/accruals/{id}/details/{detailId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'detailId' + '}', String(params.detailId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeAccrualsIdDetailsDetailIdGet');
            }
            // verify required parameter 'detailId' is set
            if (params.detailId == null) {
                throw new Error('Missing required parameter detailId when calling timeAccrualsIdDetailsDetailIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Time Accrual Detail
         * @param id
         * @param detailId
         * @param operations
         */
        public timeAccrualsIdDetailsDetailIdPatch (params: {  id: number; detailId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TimeAccrualDetail> {
            const localVarPath = this.basePath + '/time/accruals/{id}/details/{detailId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'detailId' + '}', String(params.detailId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeAccrualsIdDetailsDetailIdPatch');
            }
            // verify required parameter 'detailId' is set
            if (params.detailId == null) {
                throw new Error('Missing required parameter detailId when calling timeAccrualsIdDetailsDetailIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling timeAccrualsIdDetailsDetailIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Time Accrual Detail
         * @param id
         * @param detailId
         * @param timeAccrualDetail
         */
        public timeAccrualsIdDetailsDetailIdPut (params: {  id: number; detailId: number; timeAccrualDetail: TimeAccrualDetail; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TimeAccrualDetail> {
            const localVarPath = this.basePath + '/time/accruals/{id}/details/{detailId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'detailId' + '}', String(params.detailId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeAccrualsIdDetailsDetailIdPut');
            }
            // verify required parameter 'detailId' is set
            if (params.detailId == null) {
                throw new Error('Missing required parameter detailId when calling timeAccrualsIdDetailsDetailIdPut');
            }
            // verify required parameter 'timeAccrualDetail' is set
            if (params.timeAccrualDetail == null) {
                throw new Error('Missing required parameter timeAccrualDetail when calling timeAccrualsIdDetailsDetailIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.timeAccrualDetail),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Time Accrual Detail
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public timeAccrualsIdDetailsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<TimeAccrualDetail>> {
            const localVarPath = this.basePath + '/time/accruals/{id}/details'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeAccrualsIdDetailsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Time Accrual Detail
         * @param id
         * @param timeAccrualDetail
         */
        public timeAccrualsIdDetailsPost (params: {  id: number; timeAccrualDetail: TimeAccrualDetail; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TimeAccrualDetail> {
            const localVarPath = this.basePath + '/time/accruals/{id}/details'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeAccrualsIdDetailsPost');
            }
            // verify required parameter 'timeAccrualDetail' is set
            if (params.timeAccrualDetail == null) {
                throw new Error('Missing required parameter timeAccrualDetail when calling timeAccrualsIdDetailsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.timeAccrualDetail),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TimeAccrualsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Time Accruals Count
         * @param conditions
         */
        public timeAccrualsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/time/accruals/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Time Accruals
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public timeAccrualsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<TimeAccrual>> {
            const localVarPath = this.basePath + '/time/accruals';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Time Accrual By Id
         * @param id
         */
        public timeAccrualsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/time/accruals/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeAccrualsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Time Accrual By Id
         * @param id
         */
        public timeAccrualsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TimeAccrual> {
            const localVarPath = this.basePath + '/time/accruals/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeAccrualsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Time Accrual
         * @param id
         * @param operations
         */
        public timeAccrualsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TimeAccrual> {
            const localVarPath = this.basePath + '/time/accruals/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeAccrualsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling timeAccrualsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Time Accrual
         * @param id
         * @param timeAccrual
         */
        public timeAccrualsIdPut (params: {  id: number; timeAccrual: TimeAccrual; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TimeAccrual> {
            const localVarPath = this.basePath + '/time/accruals/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeAccrualsIdPut');
            }
            // verify required parameter 'timeAccrual' is set
            if (params.timeAccrual == null) {
                throw new Error('Missing required parameter timeAccrual when calling timeAccrualsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.timeAccrual),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Time Accrual
         * @param timeAccrual
         */
        public timeAccrualsPost (params: {  timeAccrual: TimeAccrual; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TimeAccrual> {
            const localVarPath = this.basePath + '/time/accruals';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'timeAccrual' is set
            if (params.timeAccrual == null) {
                throw new Error('Missing required parameter timeAccrual when calling timeAccrualsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.timeAccrual),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TimeEntriesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Time Entries Count
         * @param conditions
         * @param customFieldConditions
         */
        public timeEntriesCountGet (params: {  conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/time/entries/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.customFieldConditions !== undefined) {
                queryParameters['customFieldConditions'] = params.customFieldConditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Time Entry Defaults
         * @param timeEntry
         */
        public timeEntriesDefaultsPost (params: {  timeEntry: TimeEntry; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TimeEntry> {
            const localVarPath = this.basePath + '/time/entries/defaults';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'timeEntry' is set
            if (params.timeEntry == null) {
                throw new Error('Missing required parameter timeEntry when calling timeEntriesDefaultsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.timeEntry),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Time Entries
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public timeEntriesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<TimeEntry>> {
            const localVarPath = this.basePath + '/time/entries';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Time Entry By Id
         * @param id
         */
        public timeEntriesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/time/entries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeEntriesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Time Entry By Id
         * @param id
         */
        public timeEntriesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TimeEntry> {
            const localVarPath = this.basePath + '/time/entries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeEntriesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Time Entry
         * @param id
         * @param operations
         */
        public timeEntriesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TimeEntry> {
            const localVarPath = this.basePath + '/time/entries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeEntriesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling timeEntriesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Time Entry
         * @param id
         * @param timeEntry
         */
        public timeEntriesIdPut (params: {  id: number; timeEntry: TimeEntry; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TimeEntry> {
            const localVarPath = this.basePath + '/time/entries/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeEntriesIdPut');
            }
            // verify required parameter 'timeEntry' is set
            if (params.timeEntry == null) {
                throw new Error('Missing required parameter timeEntry when calling timeEntriesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.timeEntry),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Time Entry
         * @param timeEntry
         */
        public timeEntriesPost (params: {  timeEntry: TimeEntry; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TimeEntry> {
            const localVarPath = this.basePath + '/time/entries';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'timeEntry' is set
            if (params.timeEntry == null) {
                throw new Error('Missing required parameter timeEntry when calling timeEntriesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.timeEntry),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TimeExpensesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Time Expenses Count
         * @param conditions
         */
        public systemMyCompanyTimeExpenseCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/myCompany/timeExpense/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Time Expenses
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemMyCompanyTimeExpenseGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<TimeExpense>> {
            const localVarPath = this.basePath + '/system/myCompany/timeExpense';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Time Expense By Id
         * @param id
         */
        public systemMyCompanyTimeExpenseIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TimeExpense> {
            const localVarPath = this.basePath + '/system/myCompany/timeExpense/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMyCompanyTimeExpenseIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Time Expense
         * @param id
         * @param operations
         */
        public systemMyCompanyTimeExpenseIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TimeExpense> {
            const localVarPath = this.basePath + '/system/myCompany/timeExpense/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMyCompanyTimeExpenseIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemMyCompanyTimeExpenseIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Time Expense
         * @param id
         * @param timeExpense
         */
        public systemMyCompanyTimeExpenseIdPut (params: {  id: number; timeExpense: TimeExpense; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TimeExpense> {
            const localVarPath = this.basePath + '/system/myCompany/timeExpense/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemMyCompanyTimeExpenseIdPut');
            }
            // verify required parameter 'timeExpense' is set
            if (params.timeExpense == null) {
                throw new Error('Missing required parameter timeExpense when calling systemMyCompanyTimeExpenseIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.timeExpense),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TimePeriodSetupsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Time Period Setups Count
         * @param conditions
         */
        public timeTimePeriodSetupsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/time/timePeriodSetups/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Time Period Setups Default
         */
        public timeTimePeriodSetupsDefaultGet (params: {  }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TimePeriodSetupDefaults> {
            const localVarPath = this.basePath + '/time/timePeriodSetups/default';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Time Period Setups
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public timeTimePeriodSetupsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<TimePeriodSetup>> {
            const localVarPath = this.basePath + '/time/timePeriodSetups';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Time Period Setup By Id
         * @param id
         */
        public timeTimePeriodSetupsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/time/timePeriodSetups/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeTimePeriodSetupsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Time Period Setup By Id
         * @param id
         */
        public timeTimePeriodSetupsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TimePeriodSetup> {
            const localVarPath = this.basePath + '/time/timePeriodSetups/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeTimePeriodSetupsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Time Period Setup
         * @param timePeriodSetup
         */
        public timeTimePeriodSetupsPost (params: {  timePeriodSetup: TimePeriodSetup; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TimePeriodSetup> {
            const localVarPath = this.basePath + '/time/timePeriodSetups';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'timePeriodSetup' is set
            if (params.timePeriodSetup == null) {
                throw new Error('Missing required parameter timePeriodSetup when calling timeTimePeriodSetupsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.timePeriodSetup),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TimePeriodsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Time Periods Count
         * @param id
         * @param conditions
         */
        public timeTimePeriodSetupsIdPeriodsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/time/timePeriodSetups/{id}/periods/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeTimePeriodSetupsIdPeriodsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Time Periods
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public timeTimePeriodSetupsIdPeriodsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<TimePeriod>> {
            const localVarPath = this.basePath + '/time/timePeriodSetups/{id}/periods'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeTimePeriodSetupsIdPeriodsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Time Period By Id
         * @param id
         * @param periodID
         */
        public timeTimePeriodSetupsIdPeriodsPeriodIDGet (params: {  id: number; periodID: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TimePeriod> {
            const localVarPath = this.basePath + '/time/timePeriodSetups/{id}/periods/{periodID}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'periodID' + '}', String(params.periodID));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeTimePeriodSetupsIdPeriodsPeriodIDGet');
            }
            // verify required parameter 'periodID' is set
            if (params.periodID == null) {
                throw new Error('Missing required parameter periodID when calling timeTimePeriodSetupsIdPeriodsPeriodIDGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TimeSheetsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Time Sheet Count
         * @param conditions
         */
        public timeSheetsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/time/sheets/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Time Sheet
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public timeSheetsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<TimeSheet>> {
            const localVarPath = this.basePath + '/time/sheets';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Time Sheet By Id
         * @param id
         */
        public timeSheetsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TimeSheet> {
            const localVarPath = this.basePath + '/time/sheets/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeSheetsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Reverse Time Sheet
         * @param id
         */
        public timeSheetsIdReversePost (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SuccessResponse> {
            const localVarPath = this.basePath + '/time/sheets/{id}/reverse'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeSheetsIdReversePost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Submit Time Sheet
         * @param id
         */
        public timeSheetsIdSubmitPost (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SuccessResponse> {
            const localVarPath = this.basePath + '/time/sheets/{id}/submit'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeSheetsIdSubmitPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TimeZoneSetupsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Time Zones Count
         * @param conditions
         */
        public systemTimeZoneSetupsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/timeZoneSetups/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Time Zones
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemTimeZoneSetupsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<TimeZoneSetup>> {
            const localVarPath = this.basePath + '/system/timeZoneSetups';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Time Zone Setup By Id
         * @param id
         */
        public systemTimeZoneSetupsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/timeZoneSetups/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemTimeZoneSetupsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Time Zone By Id
         * @param id
         */
        public systemTimeZoneSetupsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TimeZoneSetup> {
            const localVarPath = this.basePath + '/system/timeZoneSetups/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemTimeZoneSetupsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Time Zone Setup
         * @param id
         * @param operations
         */
        public systemTimeZoneSetupsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TimeZoneSetup> {
            const localVarPath = this.basePath + '/system/timeZoneSetups/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemTimeZoneSetupsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemTimeZoneSetupsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Time Zone Setup
         * @param id
         * @param timeZoneSetup
         */
        public systemTimeZoneSetupsIdPut (params: {  id: number; timeZoneSetup: TimeZoneSetup; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TimeZoneSetup> {
            const localVarPath = this.basePath + '/system/timeZoneSetups/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemTimeZoneSetupsIdPut');
            }
            // verify required parameter 'timeZoneSetup' is set
            if (params.timeZoneSetup == null) {
                throw new Error('Missing required parameter timeZoneSetup when calling systemTimeZoneSetupsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.timeZoneSetup),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Time Zone Setup
         * @param timeZoneSetup
         */
        public systemTimeZoneSetupsPost (params: {  timeZoneSetup: TimeZoneSetup; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TimeZoneSetup> {
            const localVarPath = this.basePath + '/system/timeZoneSetups';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'timeZoneSetup' is set
            if (params.timeZoneSetup == null) {
                throw new Error('Missing required parameter timeZoneSetup when calling systemTimeZoneSetupsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.timeZoneSetup),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TimeZonesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Returns a count of system TimeZones
         * @param conditions
         */
        public systemTimeZonesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/timeZones/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Returns a list of system TimeZones
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemTimeZonesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<TimeZone>> {
            const localVarPath = this.basePath + '/system/timeZones';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Returns a system TimeZone that can be used to create a TimeZoneSetup
         * @param id
         */
        public systemTimeZonesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TimeZone> {
            const localVarPath = this.basePath + '/system/timeZones/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemTimeZonesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TodayPageCategoriesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Today Page Categories Count
         * @param conditions
         */
        public systemTodayPageCategoriesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/todayPageCategories/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Today Page Categories
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemTodayPageCategoriesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<TodayPageCategory>> {
            const localVarPath = this.basePath + '/system/todayPageCategories';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Today Page Category By Id
         * @param id
         */
        public systemTodayPageCategoriesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/todayPageCategories/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemTodayPageCategoriesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Today Page Category By Id
         * @param id
         */
        public systemTodayPageCategoriesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TodayPageCategory> {
            const localVarPath = this.basePath + '/system/todayPageCategories/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemTodayPageCategoriesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Today Page Category
         * @param id
         * @param operations
         */
        public systemTodayPageCategoriesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TodayPageCategory> {
            const localVarPath = this.basePath + '/system/todayPageCategories/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemTodayPageCategoriesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemTodayPageCategoriesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Today Page Category
         * @param id
         * @param todayPageCategory
         */
        public systemTodayPageCategoriesIdPut (params: {  id: number; todayPageCategory: TodayPageCategory; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TodayPageCategory> {
            const localVarPath = this.basePath + '/system/todayPageCategories/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemTodayPageCategoriesIdPut');
            }
            // verify required parameter 'todayPageCategory' is set
            if (params.todayPageCategory == null) {
                throw new Error('Missing required parameter todayPageCategory when calling systemTodayPageCategoriesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.todayPageCategory),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Today Page Category
         * @param todayPageCategory
         */
        public systemTodayPageCategoriesPost (params: {  todayPageCategory: TodayPageCategory; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TodayPageCategory> {
            const localVarPath = this.basePath + '/system/todayPageCategories';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'todayPageCategory' is set
            if (params.todayPageCategory == null) {
                throw new Error('Missing required parameter todayPageCategory when calling systemTodayPageCategoriesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.todayPageCategory),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TrackActionsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Delete Track Action By Id
         * @param id
         * @param actionId
         */
        public systemTracksIdActionsActionIdDelete (params: {  id: number; actionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/tracks/{id}/actions/{actionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'actionId' + '}', String(params.actionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemTracksIdActionsActionIdDelete');
            }
            // verify required parameter 'actionId' is set
            if (params.actionId == null) {
                throw new Error('Missing required parameter actionId when calling systemTracksIdActionsActionIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Track Action By Id
         * @param id
         * @param actionId
         */
        public systemTracksIdActionsActionIdGet (params: {  id: number; actionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TrackAction> {
            const localVarPath = this.basePath + '/system/tracks/{id}/actions/{actionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'actionId' + '}', String(params.actionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemTracksIdActionsActionIdGet');
            }
            // verify required parameter 'actionId' is set
            if (params.actionId == null) {
                throw new Error('Missing required parameter actionId when calling systemTracksIdActionsActionIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Track Action
         * @param id
         * @param actionId
         * @param operations
         */
        public systemTracksIdActionsActionIdPatch (params: {  id: number; actionId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TrackAction> {
            const localVarPath = this.basePath + '/system/tracks/{id}/actions/{actionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'actionId' + '}', String(params.actionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemTracksIdActionsActionIdPatch');
            }
            // verify required parameter 'actionId' is set
            if (params.actionId == null) {
                throw new Error('Missing required parameter actionId when calling systemTracksIdActionsActionIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemTracksIdActionsActionIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Track Action
         * @param id
         * @param actionId
         * @param trackAction
         */
        public systemTracksIdActionsActionIdPut (params: {  id: number; actionId: number; trackAction: TrackAction; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TrackAction> {
            const localVarPath = this.basePath + '/system/tracks/{id}/actions/{actionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'actionId' + '}', String(params.actionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemTracksIdActionsActionIdPut');
            }
            // verify required parameter 'actionId' is set
            if (params.actionId == null) {
                throw new Error('Missing required parameter actionId when calling systemTracksIdActionsActionIdPut');
            }
            // verify required parameter 'trackAction' is set
            if (params.trackAction == null) {
                throw new Error('Missing required parameter trackAction when calling systemTracksIdActionsActionIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.trackAction),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Track Actions Count
         * @param id
         * @param conditions
         */
        public systemTracksIdActionsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/tracks/{id}/actions/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemTracksIdActionsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Track Actions
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemTracksIdActionsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<TrackAction>> {
            const localVarPath = this.basePath + '/system/tracks/{id}/actions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemTracksIdActionsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Track Action
         * @param id
         * @param trackAction
         */
        public systemTracksIdActionsPost (params: {  id: number; trackAction: TrackAction; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TrackAction> {
            const localVarPath = this.basePath + '/system/tracks/{id}/actions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemTracksIdActionsPost');
            }
            // verify required parameter 'trackAction' is set
            if (params.trackAction == null) {
                throw new Error('Missing required parameter trackAction when calling systemTracksIdActionsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.trackAction),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class UnitOfMeasureConversionsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Delete Conversion By Id
         * @param id
         * @param conversionId
         */
        public procurementUnitOfMeasuresIdConversionsConversionIdDelete (params: {  id: number; conversionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/unitOfMeasures/{id}/conversions/{conversionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'conversionId' + '}', String(params.conversionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementUnitOfMeasuresIdConversionsConversionIdDelete');
            }
            // verify required parameter 'conversionId' is set
            if (params.conversionId == null) {
                throw new Error('Missing required parameter conversionId when calling procurementUnitOfMeasuresIdConversionsConversionIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Conversion By Id
         * @param id
         * @param conversionId
         */
        public procurementUnitOfMeasuresIdConversionsConversionIdGet (params: {  id: number; conversionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Conversion> {
            const localVarPath = this.basePath + '/procurement/unitOfMeasures/{id}/conversions/{conversionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'conversionId' + '}', String(params.conversionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementUnitOfMeasuresIdConversionsConversionIdGet');
            }
            // verify required parameter 'conversionId' is set
            if (params.conversionId == null) {
                throw new Error('Missing required parameter conversionId when calling procurementUnitOfMeasuresIdConversionsConversionIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Conversion
         * @param id
         * @param conversionId
         * @param operations
         */
        public procurementUnitOfMeasuresIdConversionsConversionIdPatch (params: {  id: number; conversionId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Conversion> {
            const localVarPath = this.basePath + '/procurement/unitOfMeasures/{id}/conversions/{conversionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'conversionId' + '}', String(params.conversionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementUnitOfMeasuresIdConversionsConversionIdPatch');
            }
            // verify required parameter 'conversionId' is set
            if (params.conversionId == null) {
                throw new Error('Missing required parameter conversionId when calling procurementUnitOfMeasuresIdConversionsConversionIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementUnitOfMeasuresIdConversionsConversionIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Conversion
         * @param id
         * @param conversionId
         * @param conversion
         */
        public procurementUnitOfMeasuresIdConversionsConversionIdPut (params: {  id: number; conversionId: number; conversion: Conversion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Conversion> {
            const localVarPath = this.basePath + '/procurement/unitOfMeasures/{id}/conversions/{conversionId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'conversionId' + '}', String(params.conversionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementUnitOfMeasuresIdConversionsConversionIdPut');
            }
            // verify required parameter 'conversionId' is set
            if (params.conversionId == null) {
                throw new Error('Missing required parameter conversionId when calling procurementUnitOfMeasuresIdConversionsConversionIdPut');
            }
            // verify required parameter 'conversion' is set
            if (params.conversion == null) {
                throw new Error('Missing required parameter conversion when calling procurementUnitOfMeasuresIdConversionsConversionIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.conversion),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Conversion Count
         * @param id
         * @param conditions
         */
        public procurementUnitOfMeasuresIdConversionsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/unitOfMeasures/{id}/conversions/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementUnitOfMeasuresIdConversionsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Conversion
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementUnitOfMeasuresIdConversionsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Conversion>> {
            const localVarPath = this.basePath + '/procurement/unitOfMeasures/{id}/conversions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementUnitOfMeasuresIdConversionsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Conversion
         * @param id
         * @param conversion
         */
        public procurementUnitOfMeasuresIdConversionsPost (params: {  id: number; conversion: Conversion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Conversion> {
            const localVarPath = this.basePath + '/procurement/unitOfMeasures/{id}/conversions'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementUnitOfMeasuresIdConversionsPost');
            }
            // verify required parameter 'conversion' is set
            if (params.conversion == null) {
                throw new Error('Missing required parameter conversion when calling procurementUnitOfMeasuresIdConversionsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.conversion),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class UnitOfMeasuresApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Unit Of Measure Count
         * @param conditions
         */
        public procurementUnitOfMeasuresCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/unitOfMeasures/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Unit Of Measure
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementUnitOfMeasuresGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<UnitOfMeasure>> {
            const localVarPath = this.basePath + '/procurement/unitOfMeasures';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Unit Of Measure By Id
         * @param id
         */
        public procurementUnitOfMeasuresIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/unitOfMeasures/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementUnitOfMeasuresIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Unit Of Measure By Id
         * @param id
         */
        public procurementUnitOfMeasuresIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<UnitOfMeasure> {
            const localVarPath = this.basePath + '/procurement/unitOfMeasures/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementUnitOfMeasuresIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Unit Of Measure
         * @param id
         * @param operations
         */
        public procurementUnitOfMeasuresIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<UnitOfMeasure> {
            const localVarPath = this.basePath + '/procurement/unitOfMeasures/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementUnitOfMeasuresIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementUnitOfMeasuresIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Unit Of Measure
         * @param id
         * @param unitOfMeasure
         */
        public procurementUnitOfMeasuresIdPut (params: {  id: number; unitOfMeasure: UnitOfMeasure; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<UnitOfMeasure> {
            const localVarPath = this.basePath + '/procurement/unitOfMeasures/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementUnitOfMeasuresIdPut');
            }
            // verify required parameter 'unitOfMeasure' is set
            if (params.unitOfMeasure == null) {
                throw new Error('Missing required parameter unitOfMeasure when calling procurementUnitOfMeasuresIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.unitOfMeasure),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Unit Of Measure
         * @param unitOfMeasure
         */
        public procurementUnitOfMeasuresPost (params: {  unitOfMeasure: UnitOfMeasure; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<UnitOfMeasure> {
            const localVarPath = this.basePath + '/procurement/unitOfMeasures';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'unitOfMeasure' is set
            if (params.unitOfMeasure == null) {
                throw new Error('Missing required parameter unitOfMeasure when calling procurementUnitOfMeasuresPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.unitOfMeasure),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class UserDefinedFieldsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get User Defined Fields Count
         * @param conditions
         */
        public systemUserDefinedFieldsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/userDefinedFields/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get User Defined Fields
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemUserDefinedFieldsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<UserDefinedField>> {
            const localVarPath = this.basePath + '/system/userDefinedFields';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete User Defined Field By Id
         * @param id
         */
        public systemUserDefinedFieldsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/userDefinedFields/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemUserDefinedFieldsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get User Defined Field By Id
         * @param id
         */
        public systemUserDefinedFieldsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<UserDefinedField> {
            const localVarPath = this.basePath + '/system/userDefinedFields/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemUserDefinedFieldsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update User Defined Field
         * @param id
         * @param operations
         */
        public systemUserDefinedFieldsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<UserDefinedField> {
            const localVarPath = this.basePath + '/system/userDefinedFields/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemUserDefinedFieldsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemUserDefinedFieldsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace User Defined Field
         * @param id
         * @param userDefinedField
         */
        public systemUserDefinedFieldsIdPut (params: {  id: number; userDefinedField: UserDefinedField; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<UserDefinedField> {
            const localVarPath = this.basePath + '/system/userDefinedFields/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemUserDefinedFieldsIdPut');
            }
            // verify required parameter 'userDefinedField' is set
            if (params.userDefinedField == null) {
                throw new Error('Missing required parameter userDefinedField when calling systemUserDefinedFieldsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.userDefinedField),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create User Defined Field
         * @param userDefinedField
         */
        public systemUserDefinedFieldsPost (params: {  userDefinedField: UserDefinedField; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<UserDefinedField> {
            const localVarPath = this.basePath + '/system/userDefinedFields';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'userDefinedField' is set
            if (params.userDefinedField == null) {
                throw new Error('Missing required parameter userDefinedField when calling systemUserDefinedFieldsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.userDefinedField),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class WarehouseBinsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Warehouse Bin Count
         * @param conditions
         */
        public procurementWarehouseBinsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/warehouseBins/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Warehouse Bin
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementWarehouseBinsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<WarehouseBin>> {
            const localVarPath = this.basePath + '/procurement/warehouseBins';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Warehouse Bin By Id
         * @param id
         */
        public procurementWarehouseBinsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/warehouseBins/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementWarehouseBinsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Warehouse Bin By Id
         * @param id
         */
        public procurementWarehouseBinsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WarehouseBin> {
            const localVarPath = this.basePath + '/procurement/warehouseBins/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementWarehouseBinsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Warehouse Bin
         * @param id
         * @param operations
         */
        public procurementWarehouseBinsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WarehouseBin> {
            const localVarPath = this.basePath + '/procurement/warehouseBins/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementWarehouseBinsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementWarehouseBinsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Warehouse Bin
         * @param id
         * @param warehouseBin
         */
        public procurementWarehouseBinsIdPut (params: {  id: number; warehouseBin: WarehouseBin; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WarehouseBin> {
            const localVarPath = this.basePath + '/procurement/warehouseBins/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementWarehouseBinsIdPut');
            }
            // verify required parameter 'warehouseBin' is set
            if (params.warehouseBin == null) {
                throw new Error('Missing required parameter warehouseBin when calling procurementWarehouseBinsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.warehouseBin),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Warehouse Bin
         * @param warehouseBin
         */
        public procurementWarehouseBinsPost (params: {  warehouseBin: WarehouseBin; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WarehouseBin> {
            const localVarPath = this.basePath + '/procurement/warehouseBins';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'warehouseBin' is set
            if (params.warehouseBin == null) {
                throw new Error('Missing required parameter warehouseBin when calling procurementWarehouseBinsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.warehouseBin),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class WarehousesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Warehouse Count
         * @param conditions
         */
        public procurementWarehousesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/procurement/warehouses/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Warehouse
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public procurementWarehousesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Warehouse>> {
            const localVarPath = this.basePath + '/procurement/warehouses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Warehouse By Id
         * @param id
         */
        public procurementWarehousesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/procurement/warehouses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementWarehousesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Warehouse By Id
         * @param id
         */
        public procurementWarehousesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Warehouse> {
            const localVarPath = this.basePath + '/procurement/warehouses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementWarehousesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Warehouse
         * @param id
         * @param operations
         */
        public procurementWarehousesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Warehouse> {
            const localVarPath = this.basePath + '/procurement/warehouses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementWarehousesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling procurementWarehousesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Warehouse
         * @param id
         * @param warehouse
         */
        public procurementWarehousesIdPut (params: {  id: number; warehouse: Warehouse; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Warehouse> {
            const localVarPath = this.basePath + '/procurement/warehouses/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling procurementWarehousesIdPut');
            }
            // verify required parameter 'warehouse' is set
            if (params.warehouse == null) {
                throw new Error('Missing required parameter warehouse when calling procurementWarehousesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.warehouse),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Warehouse
         * @param warehouse
         */
        public procurementWarehousesPost (params: {  warehouse: Warehouse; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Warehouse> {
            const localVarPath = this.basePath + '/procurement/warehouses';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'warehouse' is set
            if (params.warehouse == null) {
                throw new Error('Missing required parameter warehouse when calling procurementWarehousesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.warehouse),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class WorkRoleLocationsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Work Role Location Count
         * @param id
         * @param conditions
         */
        public timeWorkRolesIdLocationsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/time/workRoles/{id}/locations/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeWorkRolesIdLocationsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Work Role Location
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public timeWorkRolesIdLocationsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<WorkRoleLocation>> {
            const localVarPath = this.basePath + '/time/workRoles/{id}/locations'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeWorkRolesIdLocationsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Work Role Location By Id
         * @param id
         * @param locationId
         */
        public timeWorkRolesIdLocationsLocationIdDelete (params: {  id: number; locationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/time/workRoles/{id}/locations/{locationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'locationId' + '}', String(params.locationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeWorkRolesIdLocationsLocationIdDelete');
            }
            // verify required parameter 'locationId' is set
            if (params.locationId == null) {
                throw new Error('Missing required parameter locationId when calling timeWorkRolesIdLocationsLocationIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Work Role Location By Id
         * @param id
         * @param locationId
         */
        public timeWorkRolesIdLocationsLocationIdGet (params: {  id: number; locationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WorkRoleLocation> {
            const localVarPath = this.basePath + '/time/workRoles/{id}/locations/{locationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'locationId' + '}', String(params.locationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeWorkRolesIdLocationsLocationIdGet');
            }
            // verify required parameter 'locationId' is set
            if (params.locationId == null) {
                throw new Error('Missing required parameter locationId when calling timeWorkRolesIdLocationsLocationIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Work Role Location
         * @param id
         * @param locationId
         * @param operations
         */
        public timeWorkRolesIdLocationsLocationIdPatch (params: {  id: number; locationId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WorkRoleLocation> {
            const localVarPath = this.basePath + '/time/workRoles/{id}/locations/{locationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'locationId' + '}', String(params.locationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeWorkRolesIdLocationsLocationIdPatch');
            }
            // verify required parameter 'locationId' is set
            if (params.locationId == null) {
                throw new Error('Missing required parameter locationId when calling timeWorkRolesIdLocationsLocationIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling timeWorkRolesIdLocationsLocationIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Work Role Location
         * @param id
         * @param locationId
         * @param workRoleLocation
         */
        public timeWorkRolesIdLocationsLocationIdPut (params: {  id: number; locationId: number; workRoleLocation: WorkRoleLocation; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WorkRoleLocation> {
            const localVarPath = this.basePath + '/time/workRoles/{id}/locations/{locationId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'locationId' + '}', String(params.locationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeWorkRolesIdLocationsLocationIdPut');
            }
            // verify required parameter 'locationId' is set
            if (params.locationId == null) {
                throw new Error('Missing required parameter locationId when calling timeWorkRolesIdLocationsLocationIdPut');
            }
            // verify required parameter 'workRoleLocation' is set
            if (params.workRoleLocation == null) {
                throw new Error('Missing required parameter workRoleLocation when calling timeWorkRolesIdLocationsLocationIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.workRoleLocation),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Work Role Location
         * @param id
         * @param workRoleLocation
         */
        public timeWorkRolesIdLocationsPost (params: {  id: number; workRoleLocation: WorkRoleLocation; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WorkRoleLocation> {
            const localVarPath = this.basePath + '/time/workRoles/{id}/locations'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeWorkRolesIdLocationsPost');
            }
            // verify required parameter 'workRoleLocation' is set
            if (params.workRoleLocation == null) {
                throw new Error('Missing required parameter workRoleLocation when calling timeWorkRolesIdLocationsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.workRoleLocation),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class WorkRolesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Work Role Count
         * @param conditions
         */
        public timeWorkRolesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/time/workRoles/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Work Role
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public timeWorkRolesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<WorkRole>> {
            const localVarPath = this.basePath + '/time/workRoles';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Work Role By Id
         * @param id
         */
        public timeWorkRolesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/time/workRoles/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeWorkRolesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Work Role By Id
         * @param id
         */
        public timeWorkRolesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WorkRole> {
            const localVarPath = this.basePath + '/time/workRoles/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeWorkRolesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Work Role
         * @param id
         * @param operations
         */
        public timeWorkRolesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WorkRole> {
            const localVarPath = this.basePath + '/time/workRoles/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeWorkRolesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling timeWorkRolesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Work Role
         * @param id
         * @param workRole
         */
        public timeWorkRolesIdPut (params: {  id: number; workRole: WorkRole; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WorkRole> {
            const localVarPath = this.basePath + '/time/workRoles/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeWorkRolesIdPut');
            }
            // verify required parameter 'workRole' is set
            if (params.workRole == null) {
                throw new Error('Missing required parameter workRole when calling timeWorkRolesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.workRole),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Work Role
         * @param workRole
         */
        public timeWorkRolesPost (params: {  workRole: WorkRole; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WorkRole> {
            const localVarPath = this.basePath + '/time/workRoles';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'workRole' is set
            if (params.workRole == null) {
                throw new Error('Missing required parameter workRole when calling timeWorkRolesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.workRole),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class WorkTypeExternalIntegrationReferencesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get External Integration Reference Count
         * @param conditions
         */
        public timeWorkTypeExternalIntegrationReferencesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/time/workTypeExternalIntegrationReferences/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get External Integration Referencet
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public timeWorkTypeExternalIntegrationReferencesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<WorkTypeExternalIntegrationReference>> {
            const localVarPath = this.basePath + '/time/workTypeExternalIntegrationReferences';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get External Integration Reference By Id
         * @param id
         */
        public timeWorkTypeExternalIntegrationReferencesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WorkTypeExternalIntegrationReference> {
            const localVarPath = this.basePath + '/time/workTypeExternalIntegrationReferences/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeWorkTypeExternalIntegrationReferencesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class WorkTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Work Type Count
         * @param conditions
         */
        public timeWorkTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/time/workTypes/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Work Type
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public timeWorkTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<WorkType>> {
            const localVarPath = this.basePath + '/time/workTypes';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Work Type By Id
         * @param id
         */
        public timeWorkTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/time/workTypes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeWorkTypesIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Work Type By Id
         * @param id
         */
        public timeWorkTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WorkType> {
            const localVarPath = this.basePath + '/time/workTypes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeWorkTypesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Work Type
         * @param id
         * @param operations
         */
        public timeWorkTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WorkType> {
            const localVarPath = this.basePath + '/time/workTypes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeWorkTypesIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling timeWorkTypesIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Work Type
         * @param id
         * @param workType
         */
        public timeWorkTypesIdPut (params: {  id: number; workType: WorkType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WorkType> {
            const localVarPath = this.basePath + '/time/workTypes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling timeWorkTypesIdPut');
            }
            // verify required parameter 'workType' is set
            if (params.workType == null) {
                throw new Error('Missing required parameter workType when calling timeWorkTypesIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.workType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Work Type
         * @param workType
         */
        public timeWorkTypesPost (params: {  workType: WorkType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WorkType> {
            const localVarPath = this.basePath + '/time/workTypes';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'workType' is set
            if (params.workType == null) {
                throw new Error('Missing required parameter workType when calling timeWorkTypesPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.workType),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class WorkflowActionAutomateParametersApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Workflow Action Automate Parameters Count
         * @param id
         * @param conditions
         */
        public systemWorkflowActionsIdAutomateParametersCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/workflowActions/{id}/automateParameters/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemWorkflowActionsIdAutomateParametersCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Workflow Action Automate Parameters
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemWorkflowActionsIdAutomateParametersGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<WorkflowActionAutomateParameter>> {
            const localVarPath = this.basePath + '/system/workflowActions/{id}/automateParameters'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemWorkflowActionsIdAutomateParametersGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Workflow Action Automate Parameter By Id
         * @param id
         * @param parameterId
         */
        public systemWorkflowActionsIdAutomateParametersParameterIdDelete (params: {  id: number; parameterId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/workflowActions/{id}/automateParameters/{parameterId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'parameterId' + '}', String(params.parameterId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemWorkflowActionsIdAutomateParametersParameterIdDelete');
            }
            // verify required parameter 'parameterId' is set
            if (params.parameterId == null) {
                throw new Error('Missing required parameter parameterId when calling systemWorkflowActionsIdAutomateParametersParameterIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Workflow Action Automate Parameter By Id
         * @param id
         * @param parameterId
         */
        public systemWorkflowActionsIdAutomateParametersParameterIdGet (params: {  id: number; parameterId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WorkflowActionAutomateParameter> {
            const localVarPath = this.basePath + '/system/workflowActions/{id}/automateParameters/{parameterId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'parameterId' + '}', String(params.parameterId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemWorkflowActionsIdAutomateParametersParameterIdGet');
            }
            // verify required parameter 'parameterId' is set
            if (params.parameterId == null) {
                throw new Error('Missing required parameter parameterId when calling systemWorkflowActionsIdAutomateParametersParameterIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Workflow Action Automate Parameter
         * @param id
         * @param parameterId
         * @param operations
         */
        public systemWorkflowActionsIdAutomateParametersParameterIdPatch (params: {  id: number; parameterId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WorkflowActionAutomateParameter> {
            const localVarPath = this.basePath + '/system/workflowActions/{id}/automateParameters/{parameterId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'parameterId' + '}', String(params.parameterId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemWorkflowActionsIdAutomateParametersParameterIdPatch');
            }
            // verify required parameter 'parameterId' is set
            if (params.parameterId == null) {
                throw new Error('Missing required parameter parameterId when calling systemWorkflowActionsIdAutomateParametersParameterIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemWorkflowActionsIdAutomateParametersParameterIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Workflow Action Automate Parameter
         * @param id
         * @param parameterId
         * @param workflowActionAutomateParameter
         */
        public systemWorkflowActionsIdAutomateParametersParameterIdPut (params: {  id: number; parameterId: number; workflowActionAutomateParameter: WorkflowActionAutomateParameter; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WorkflowActionAutomateParameter> {
            const localVarPath = this.basePath + '/system/workflowActions/{id}/automateParameters/{parameterId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'parameterId' + '}', String(params.parameterId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemWorkflowActionsIdAutomateParametersParameterIdPut');
            }
            // verify required parameter 'parameterId' is set
            if (params.parameterId == null) {
                throw new Error('Missing required parameter parameterId when calling systemWorkflowActionsIdAutomateParametersParameterIdPut');
            }
            // verify required parameter 'workflowActionAutomateParameter' is set
            if (params.workflowActionAutomateParameter == null) {
                throw new Error('Missing required parameter workflowActionAutomateParameter when calling systemWorkflowActionsIdAutomateParametersParameterIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.workflowActionAutomateParameter),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Workflow Action Automate Parameter
         * @param id
         * @param workflowActionAutomateParameter
         */
        public systemWorkflowActionsIdAutomateParametersPost (params: {  id: number; workflowActionAutomateParameter: WorkflowActionAutomateParameter; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WorkflowActionAutomateParameter> {
            const localVarPath = this.basePath + '/system/workflowActions/{id}/automateParameters'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemWorkflowActionsIdAutomateParametersPost');
            }
            // verify required parameter 'workflowActionAutomateParameter' is set
            if (params.workflowActionAutomateParameter == null) {
                throw new Error('Missing required parameter workflowActionAutomateParameter when calling systemWorkflowActionsIdAutomateParametersPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.workflowActionAutomateParameter),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class WorkflowActionsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Delete Workflow Action By Id
         * @param workflowId
         * @param eventId
         * @param actionId
         */
        public systemWorkflowsWorkflowIdEventsEventIdActionsActionIdDelete (params: {  workflowId: number; eventId: number; actionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/workflows/{workflowId}/events/{eventId}/actions/{actionId}'
                .replace('{' + 'workflowId' + '}', String(params.workflowId))
                .replace('{' + 'eventId' + '}', String(params.eventId))
                .replace('{' + 'actionId' + '}', String(params.actionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'workflowId' is set
            if (params.workflowId == null) {
                throw new Error('Missing required parameter workflowId when calling systemWorkflowsWorkflowIdEventsEventIdActionsActionIdDelete');
            }
            // verify required parameter 'eventId' is set
            if (params.eventId == null) {
                throw new Error('Missing required parameter eventId when calling systemWorkflowsWorkflowIdEventsEventIdActionsActionIdDelete');
            }
            // verify required parameter 'actionId' is set
            if (params.actionId == null) {
                throw new Error('Missing required parameter actionId when calling systemWorkflowsWorkflowIdEventsEventIdActionsActionIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Workflow Action By Id
         * @param workflowId
         * @param eventId
         * @param actionId
         */
        public systemWorkflowsWorkflowIdEventsEventIdActionsActionIdGet (params: {  workflowId: number; eventId: number; actionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WorkflowAction> {
            const localVarPath = this.basePath + '/system/workflows/{workflowId}/events/{eventId}/actions/{actionId}'
                .replace('{' + 'workflowId' + '}', String(params.workflowId))
                .replace('{' + 'eventId' + '}', String(params.eventId))
                .replace('{' + 'actionId' + '}', String(params.actionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'workflowId' is set
            if (params.workflowId == null) {
                throw new Error('Missing required parameter workflowId when calling systemWorkflowsWorkflowIdEventsEventIdActionsActionIdGet');
            }
            // verify required parameter 'eventId' is set
            if (params.eventId == null) {
                throw new Error('Missing required parameter eventId when calling systemWorkflowsWorkflowIdEventsEventIdActionsActionIdGet');
            }
            // verify required parameter 'actionId' is set
            if (params.actionId == null) {
                throw new Error('Missing required parameter actionId when calling systemWorkflowsWorkflowIdEventsEventIdActionsActionIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Workflow Action
         * @param workflowId
         * @param eventId
         * @param actionId
         * @param operations
         */
        public systemWorkflowsWorkflowIdEventsEventIdActionsActionIdPatch (params: {  workflowId: number; eventId: number; actionId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WorkflowAction> {
            const localVarPath = this.basePath + '/system/workflows/{workflowId}/events/{eventId}/actions/{actionId}'
                .replace('{' + 'workflowId' + '}', String(params.workflowId))
                .replace('{' + 'eventId' + '}', String(params.eventId))
                .replace('{' + 'actionId' + '}', String(params.actionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'workflowId' is set
            if (params.workflowId == null) {
                throw new Error('Missing required parameter workflowId when calling systemWorkflowsWorkflowIdEventsEventIdActionsActionIdPatch');
            }
            // verify required parameter 'eventId' is set
            if (params.eventId == null) {
                throw new Error('Missing required parameter eventId when calling systemWorkflowsWorkflowIdEventsEventIdActionsActionIdPatch');
            }
            // verify required parameter 'actionId' is set
            if (params.actionId == null) {
                throw new Error('Missing required parameter actionId when calling systemWorkflowsWorkflowIdEventsEventIdActionsActionIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemWorkflowsWorkflowIdEventsEventIdActionsActionIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Workflow Action
         * @param workflowId
         * @param eventId
         * @param actionId
         * @param workflowAction
         */
        public systemWorkflowsWorkflowIdEventsEventIdActionsActionIdPut (params: {  workflowId: number; eventId: number; actionId: number; workflowAction: WorkflowAction; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WorkflowAction> {
            const localVarPath = this.basePath + '/system/workflows/{workflowId}/events/{eventId}/actions/{actionId}'
                .replace('{' + 'workflowId' + '}', String(params.workflowId))
                .replace('{' + 'eventId' + '}', String(params.eventId))
                .replace('{' + 'actionId' + '}', String(params.actionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'workflowId' is set
            if (params.workflowId == null) {
                throw new Error('Missing required parameter workflowId when calling systemWorkflowsWorkflowIdEventsEventIdActionsActionIdPut');
            }
            // verify required parameter 'eventId' is set
            if (params.eventId == null) {
                throw new Error('Missing required parameter eventId when calling systemWorkflowsWorkflowIdEventsEventIdActionsActionIdPut');
            }
            // verify required parameter 'actionId' is set
            if (params.actionId == null) {
                throw new Error('Missing required parameter actionId when calling systemWorkflowsWorkflowIdEventsEventIdActionsActionIdPut');
            }
            // verify required parameter 'workflowAction' is set
            if (params.workflowAction == null) {
                throw new Error('Missing required parameter workflowAction when calling systemWorkflowsWorkflowIdEventsEventIdActionsActionIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.workflowAction),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Workflow Actions Count
         * @param workflowId
         * @param eventId
         * @param conditions
         */
        public systemWorkflowsWorkflowIdEventsEventIdActionsCountGet (params: {  workflowId: number; eventId: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/workflows/{workflowId}/events/{eventId}/actions/count'
                .replace('{' + 'workflowId' + '}', String(params.workflowId))
                .replace('{' + 'eventId' + '}', String(params.eventId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'workflowId' is set
            if (params.workflowId == null) {
                throw new Error('Missing required parameter workflowId when calling systemWorkflowsWorkflowIdEventsEventIdActionsCountGet');
            }
            // verify required parameter 'eventId' is set
            if (params.eventId == null) {
                throw new Error('Missing required parameter eventId when calling systemWorkflowsWorkflowIdEventsEventIdActionsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Workflow Actions
         * @param workflowId
         * @param eventId
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemWorkflowsWorkflowIdEventsEventIdActionsGet (params: {  workflowId: number; eventId: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<WorkflowAction>> {
            const localVarPath = this.basePath + '/system/workflows/{workflowId}/events/{eventId}/actions'
                .replace('{' + 'workflowId' + '}', String(params.workflowId))
                .replace('{' + 'eventId' + '}', String(params.eventId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'workflowId' is set
            if (params.workflowId == null) {
                throw new Error('Missing required parameter workflowId when calling systemWorkflowsWorkflowIdEventsEventIdActionsGet');
            }
            // verify required parameter 'eventId' is set
            if (params.eventId == null) {
                throw new Error('Missing required parameter eventId when calling systemWorkflowsWorkflowIdEventsEventIdActionsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Workflow Action
         * @param workflowId
         * @param eventId
         * @param workflowAction
         */
        public systemWorkflowsWorkflowIdEventsEventIdActionsPost (params: {  workflowId: number; eventId: number; workflowAction: WorkflowAction; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WorkflowAction> {
            const localVarPath = this.basePath + '/system/workflows/{workflowId}/events/{eventId}/actions'
                .replace('{' + 'workflowId' + '}', String(params.workflowId))
                .replace('{' + 'eventId' + '}', String(params.eventId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'workflowId' is set
            if (params.workflowId == null) {
                throw new Error('Missing required parameter workflowId when calling systemWorkflowsWorkflowIdEventsEventIdActionsPost');
            }
            // verify required parameter 'eventId' is set
            if (params.eventId == null) {
                throw new Error('Missing required parameter eventId when calling systemWorkflowsWorkflowIdEventsEventIdActionsPost');
            }
            // verify required parameter 'workflowAction' is set
            if (params.workflowAction == null) {
                throw new Error('Missing required parameter workflowAction when calling systemWorkflowsWorkflowIdEventsEventIdActionsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.workflowAction),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class WorkflowEventsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Workflow Events Count
         * @param id
         * @param conditions
         */
        public systemWorkflowsIdEventsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/workflows/{id}/events/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemWorkflowsIdEventsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Workflow Event By Id
         * @param id
         * @param eventId
         */
        public systemWorkflowsIdEventsEventIdDelete (params: {  id: number; eventId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/workflows/{id}/events/{eventId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'eventId' + '}', String(params.eventId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemWorkflowsIdEventsEventIdDelete');
            }
            // verify required parameter 'eventId' is set
            if (params.eventId == null) {
                throw new Error('Missing required parameter eventId when calling systemWorkflowsIdEventsEventIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Workflow Event By Id
         * @param id
         * @param eventId
         */
        public systemWorkflowsIdEventsEventIdGet (params: {  id: number; eventId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WorkflowEvent> {
            const localVarPath = this.basePath + '/system/workflows/{id}/events/{eventId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'eventId' + '}', String(params.eventId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemWorkflowsIdEventsEventIdGet');
            }
            // verify required parameter 'eventId' is set
            if (params.eventId == null) {
                throw new Error('Missing required parameter eventId when calling systemWorkflowsIdEventsEventIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Workflow Event
         * @param id
         * @param eventId
         * @param operations
         */
        public systemWorkflowsIdEventsEventIdPatch (params: {  id: number; eventId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WorkflowEvent> {
            const localVarPath = this.basePath + '/system/workflows/{id}/events/{eventId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'eventId' + '}', String(params.eventId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemWorkflowsIdEventsEventIdPatch');
            }
            // verify required parameter 'eventId' is set
            if (params.eventId == null) {
                throw new Error('Missing required parameter eventId when calling systemWorkflowsIdEventsEventIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemWorkflowsIdEventsEventIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Workflow Event
         * @param id
         * @param eventId
         * @param workflowEvent
         */
        public systemWorkflowsIdEventsEventIdPut (params: {  id: number; eventId: number; workflowEvent: WorkflowEvent; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WorkflowEvent> {
            const localVarPath = this.basePath + '/system/workflows/{id}/events/{eventId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'eventId' + '}', String(params.eventId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemWorkflowsIdEventsEventIdPut');
            }
            // verify required parameter 'eventId' is set
            if (params.eventId == null) {
                throw new Error('Missing required parameter eventId when calling systemWorkflowsIdEventsEventIdPut');
            }
            // verify required parameter 'workflowEvent' is set
            if (params.workflowEvent == null) {
                throw new Error('Missing required parameter workflowEvent when calling systemWorkflowsIdEventsEventIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.workflowEvent),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Test Workflow Evemt
         * @param id
         * @param eventId
         */
        public systemWorkflowsIdEventsEventIdTestGet (params: {  id: number; eventId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<JArray> {
            const localVarPath = this.basePath + '/system/workflows/{id}/events/{eventId}/test'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'eventId' + '}', String(params.eventId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemWorkflowsIdEventsEventIdTestGet');
            }
            // verify required parameter 'eventId' is set
            if (params.eventId == null) {
                throw new Error('Missing required parameter eventId when calling systemWorkflowsIdEventsEventIdTestGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Workflow Events
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemWorkflowsIdEventsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<WorkflowEvent>> {
            const localVarPath = this.basePath + '/system/workflows/{id}/events'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemWorkflowsIdEventsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Workflow Event
         * @param id
         * @param workflowEvent
         */
        public systemWorkflowsIdEventsPost (params: {  id: number; workflowEvent: WorkflowEvent; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WorkflowEvent> {
            const localVarPath = this.basePath + '/system/workflows/{id}/events'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemWorkflowsIdEventsPost');
            }
            // verify required parameter 'workflowEvent' is set
            if (params.workflowEvent == null) {
                throw new Error('Missing required parameter workflowEvent when calling systemWorkflowsIdEventsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.workflowEvent),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class WorkflowNotifyTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Workflow Notify Types Count
         * @param id
         * @param conditions
         */
        public systemWorkflowsIdNotifyTypesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/workflows/{id}/notifyTypes/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemWorkflowsIdNotifyTypesCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Workflow Notify Types
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemWorkflowsIdNotifyTypesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<WorkflowNotifyType>> {
            const localVarPath = this.basePath + '/system/workflows/{id}/notifyTypes'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemWorkflowsIdNotifyTypesGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Workflow Notify Type By Id
         * @param id
         * @param typeId
         */
        public systemWorkflowsIdNotifyTypesTypeIdGet (params: {  id: number; typeId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WorkflowNotifyType> {
            const localVarPath = this.basePath + '/system/workflows/{id}/notifyTypes/{typeId}'
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'typeId' + '}', String(params.typeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemWorkflowsIdNotifyTypesTypeIdGet');
            }
            // verify required parameter 'typeId' is set
            if (params.typeId == null) {
                throw new Error('Missing required parameter typeId when calling systemWorkflowsIdNotifyTypesTypeIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class WorkflowTableTypesApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Workflow Table Types Count
         * @param conditions
         */
        public systemWorkflowsTableTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/workflows/tableTypes/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Workflow Table Types
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemWorkflowsTableTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<WorkflowTableType>> {
            const localVarPath = this.basePath + '/system/workflows/tableTypes';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Workflow Table Type By Id
         * @param id
         */
        public systemWorkflowsTableTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<WorkflowTableType> {
            const localVarPath = this.basePath + '/system/workflows/tableTypes/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemWorkflowsTableTypesIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class WorkflowTriggerOptionsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Workflow Triggers Count
         * @param workflowId
         * @param triggerId
         * @param conditions
         */
        public systemWorkflowsWorkflowIdTriggersTriggerIdOptionsCountGet (params: {  workflowId: number; triggerId: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/workflows/{workflowId}/triggers/{triggerId}/options/count'
                .replace('{' + 'workflowId' + '}', String(params.workflowId))
                .replace('{' + 'triggerId' + '}', String(params.triggerId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'workflowId' is set
            if (params.workflowId == null) {
                throw new Error('Missing required parameter workflowId when calling systemWorkflowsWorkflowIdTriggersTriggerIdOptionsCountGet');
            }
            // verify required parameter 'triggerId' is set
            if (params.triggerId == null) {
                throw new Error('Missing required parameter triggerId when calling systemWorkflowsWorkflowIdTriggersTriggerIdOptionsCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Trigger Options
         * @param workflowId
         * @param triggerId
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemWorkflowsWorkflowIdTriggersTriggerIdOptionsGet (params: {  workflowId: number; triggerId: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<WorkflowTriggerOption>> {
            const localVarPath = this.basePath + '/system/workflows/{workflowId}/triggers/{triggerId}/options'
                .replace('{' + 'workflowId' + '}', String(params.workflowId))
                .replace('{' + 'triggerId' + '}', String(params.triggerId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'workflowId' is set
            if (params.workflowId == null) {
                throw new Error('Missing required parameter workflowId when calling systemWorkflowsWorkflowIdTriggersTriggerIdOptionsGet');
            }
            // verify required parameter 'triggerId' is set
            if (params.triggerId == null) {
                throw new Error('Missing required parameter triggerId when calling systemWorkflowsWorkflowIdTriggersTriggerIdOptionsGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class WorkflowTriggersApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Workflow Triggers Count
         * @param id
         * @param conditions
         */
        public systemWorkflowsIdTriggersCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/workflows/{id}/triggers/count'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemWorkflowsIdTriggersCountGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Workflow Triggers
         * @param id
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemWorkflowsIdTriggersGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<WorkflowTrigger>> {
            const localVarPath = this.basePath + '/system/workflows/{id}/triggers'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemWorkflowsIdTriggersGet');
            }
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class WorkflowsApi {
        protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         *
         * Get Workflows Count
         * @param conditions
         */
        public systemWorkflowsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
            const localVarPath = this.basePath + '/system/workflows/count';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Workflows
         * @param conditions
         * @param orderBy
         * @param childconditions
         * @param customfieldconditions
         * @param page
         * @param pageSize
         */
        public systemWorkflowsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Workflow>> {
            const localVarPath = this.basePath + '/system/workflows';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            if (params.conditions !== undefined) {
                queryParameters['conditions'] = params.conditions;
            }

            if (params.orderBy !== undefined) {
                queryParameters['orderBy'] = params.orderBy;
            }

            if (params.childconditions !== undefined) {
                queryParameters['childconditions'] = params.childconditions;
            }

            if (params.customfieldconditions !== undefined) {
                queryParameters['customfieldconditions'] = params.customfieldconditions;
            }

            if (params.page !== undefined) {
                queryParameters['page'] = params.page;
            }

            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Copy Workflow
         * @param id
         */
        public systemWorkflowsIdCopyPost (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Workflow> {
            const localVarPath = this.basePath + '/system/workflows/{id}/copy'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemWorkflowsIdCopyPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Delete Workflow By Id
         * @param id
         */
        public systemWorkflowsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
            const localVarPath = this.basePath + '/system/workflows/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemWorkflowsIdDelete');
            }
            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Get Workflow By Id
         * @param id
         */
        public systemWorkflowsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Workflow> {
            const localVarPath = this.basePath + '/system/workflows/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemWorkflowsIdGet');
            }
            let fetchParams = {
                method: 'GET',
                headers: headerParams,

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Update Workflow
         * @param id
         * @param operations
         */
        public systemWorkflowsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Workflow> {
            const localVarPath = this.basePath + '/system/workflows/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemWorkflowsIdPatch');
            }
            // verify required parameter 'operations' is set
            if (params.operations == null) {
                throw new Error('Missing required parameter operations when calling systemWorkflowsIdPatch');
            }
            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.operations),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Replace Workflow
         * @param id
         * @param workflow
         */
        public systemWorkflowsIdPut (params: {  id: number; workflow: Workflow; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Workflow> {
            const localVarPath = this.basePath + '/system/workflows/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling systemWorkflowsIdPut');
            }
            // verify required parameter 'workflow' is set
            if (params.workflow == null) {
                throw new Error('Missing required parameter workflow when calling systemWorkflowsIdPut');
            }
            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.workflow),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         *
         * Create Workflow
         * @param workflow
         */
        public systemWorkflowsPost (params: {  workflow: Workflow; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Workflow> {
            const localVarPath = this.basePath + '/system/workflows';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'workflow' is set
            if (params.workflow == null) {
                throw new Error('Missing required parameter workflow when calling systemWorkflowsPost');
            }
            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.workflow),

            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}

